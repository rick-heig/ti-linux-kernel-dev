From 3619c1cff93f3e6e70e348ce6eda6ca637e5e75f Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Wed, 15 May 2024 15:41:39 -0500
Subject: [PATCH 2/3] cc33xx-linux-package-1.0.0.3

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 drivers/net/wireless/ti/cc33xx/acx.c          |  913 ++++----
 drivers/net/wireless/ti/cc33xx/acx.h          |  629 ++----
 drivers/net/wireless/ti/cc33xx/boot.c         |   87 +-
 drivers/net/wireless/ti/cc33xx/boot.h         |   12 +-
 drivers/net/wireless/ti/cc33xx/cc33xx_80211.h |   13 +-
 drivers/net/wireless/ti/cc33xx/cmd.c          |  586 ++---
 drivers/net/wireless/ti/cc33xx/cmd.h          |  185 +-
 drivers/net/wireless/ti/cc33xx/conf.h         |  651 +++---
 drivers/net/wireless/ti/cc33xx/debug.h        |    6 +-
 drivers/net/wireless/ti/cc33xx/debugfs.c      |  785 +++++--
 drivers/net/wireless/ti/cc33xx/event.c        |  354 +--
 drivers/net/wireless/ti/cc33xx/event.h        |   40 +-
 drivers/net/wireless/ti/cc33xx/ini.h          |  218 --
 drivers/net/wireless/ti/cc33xx/init.c         |  252 +--
 drivers/net/wireless/ti/cc33xx/init.h         |    7 +-
 drivers/net/wireless/ti/cc33xx/io.c           |   90 +-
 drivers/net/wireless/ti/cc33xx/io.h           |  129 +-
 drivers/net/wireless/ti/cc33xx/main.c         | 2008 ++++++++---------
 drivers/net/wireless/ti/cc33xx/ps.c           |   39 +-
 drivers/net/wireless/ti/cc33xx/ps.h           |    8 +-
 drivers/net/wireless/ti/cc33xx/rx.c           |  138 +-
 drivers/net/wireless/ti/cc33xx/rx.h           |   79 +-
 drivers/net/wireless/ti/cc33xx/scan.c         |  794 +++----
 drivers/net/wireless/ti/cc33xx/scan.h         |  164 +-
 drivers/net/wireless/ti/cc33xx/sdio.c         |   64 +-
 drivers/net/wireless/ti/cc33xx/spi.c          |   88 +-
 drivers/net/wireless/ti/cc33xx/sysfs.c        |    5 +-
 drivers/net/wireless/ti/cc33xx/sysfs.h        |    4 +-
 drivers/net/wireless/ti/cc33xx/testmode.c     |   13 +-
 drivers/net/wireless/ti/cc33xx/testmode.h     |    4 +-
 drivers/net/wireless/ti/cc33xx/tx.c           |  367 +--
 drivers/net/wireless/ti/cc33xx/tx.h           |  109 +-
 drivers/net/wireless/ti/cc33xx/wlcore.h       |  289 +--
 drivers/net/wireless/ti/cc33xx/wlcore_i.h     |   37 +-
 drivers/tty/serial/8250/8250_omap.c           |    4 +-
 net/mac80211/mlme.c                           |   51 +-
 net/mac80211/util.c                           |   12 +-
 37 files changed, 3953 insertions(+), 5281 deletions(-)
 delete mode 100644 drivers/net/wireless/ti/cc33xx/ini.h

diff --git a/drivers/net/wireless/ti/cc33xx/acx.c b/drivers/net/wireless/ti/cc33xx/acx.c
index 5ce2e526d73a..fe48ad9a185c 100644
--- a/drivers/net/wireless/ti/cc33xx/acx.c
+++ b/drivers/net/wireless/ti/cc33xx/acx.c
@@ -9,16 +9,6 @@
 
 #include "acx.h"
 
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/spi/spi.h>
-#include <linux/slab.h>
-
-#include "wlcore.h"
-#include "tx.h"
-#include "debug.h"
-#include "cc33xx_80211.h"
-
 
 int cc33xx_acx_dynamic_fw_traces(struct cc33xx *wl)
 {
@@ -49,7 +39,7 @@ int cc33xx_acx_dynamic_fw_traces(struct cc33xx *wl)
 
 int cc33xx_acx_clear_statistics(struct cc33xx *wl)
 {
-	struct cc33xx_acx_clear_statistics *acx;
+	struct acx_header *acx;
 	int ret = 0;
 
 	cc33xx_debug(DEBUG_ACX, "acx clear statistics");
@@ -71,14 +61,14 @@ int cc33xx_acx_clear_statistics(struct cc33xx *wl)
 	return ret;
 }
 
-
 int cc33xx_acx_wake_up_conditions(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				  u8 wake_up_event, u8 listen_interval)
 {
 	struct acx_wake_up_condition *wake_up;
 	int ret;
 
-	cc33xx_debug(DEBUG_ACX, "acx wake up conditions (wake_up_event %d listen_interval %d)",
+	cc33xx_debug(DEBUG_ACX,
+		     "acx wake up conditions (wake_up_event %d listen_interval %d)",
 		     wake_up_event, listen_interval);
 
 	wake_up = kzalloc(sizeof(*wake_up), GFP_KERNEL);
@@ -143,9 +133,7 @@ int cc33xx_ble_enable(struct cc33xx *wl, u8 ble_enable)
 		goto out;
 	}
 
-	//cc33xx_cmd_debug
-
-	ret = cc33xx_cmd_debug(wl, BLE_ENABLE ,buf ,sizeof(*buf));
+	ret = cc33xx_cmd_debug(wl, BLE_ENABLE, buf, sizeof(*buf));
 	if (ret < 0) {
 		cc33xx_error("could not enable ble");
 		goto out;
@@ -229,8 +217,8 @@ int cc33xx_acx_feature_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	return ret;
 }
 
-int cc33xx_acx_mem_map(struct cc33xx *wl, struct acx_header *mem_map,
-		       size_t len)
+static int cc33xx_acx_mem_map(struct cc33xx *wl,
+			      struct acx_header *mem_map, size_t len)
 {
 	int ret;
 
@@ -244,7 +232,9 @@ int cc33xx_acx_mem_map(struct cc33xx *wl, struct acx_header *mem_map,
 	return 0;
 }
 
-int cc33xx_acx_get_fw_versions(struct cc33xx *wl, struct cc33xx_acx_fw_versions *get_fw_versions, size_t len)
+static int cc33xx_acx_get_fw_versions(struct cc33xx *wl,
+				      struct cc33xx_acx_fw_versions *get_fw_versions,
+				      size_t len)
 {
 	int ret;
 	cc33xx_debug(DEBUG_ACX, "acx get FW versions");
@@ -256,32 +246,6 @@ int cc33xx_acx_get_fw_versions(struct cc33xx *wl, struct cc33xx_acx_fw_versions
 	return 0;
 }
 
-int cc33xx_acx_rx_msdu_life_time(struct cc33xx *wl)
-{
-	struct acx_rx_msdu_lifetime *acx;
-	int ret;
-
-	cc33xx_debug(DEBUG_ACX, "acx rx msdu life time");
-
-	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
-	if (!acx) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	acx->lifetime = cpu_to_le32(wl->conf.host_conf.rx.rx_msdu_life_time);
-	ret = cc33xx_cmd_configure(wl, DOT11_RX_MSDU_LIFE_TIME,
-				   acx, sizeof(*acx));
-	if (ret < 0) {
-		cc33xx_warning("failed to set rx msdu life time: %d", ret);
-		goto out;
-	}
-
-out:
-	kfree(acx);
-	return ret;
-}
-
 int cc33xx_acx_slot(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 		    enum acx_slot_type slot_time)
 {
@@ -314,34 +278,36 @@ int cc33xx_acx_group_address_tbl(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				 bool enable, void *mc_list, u32 mc_list_len)
 {
 	struct acx_dot11_grp_addr_tbl *acx;
-    int ret;
+	int ret;
 
-    acx = kzalloc(sizeof(*acx), GFP_KERNEL);
-    if (!acx) {
-        ret = -ENOMEM;
-        goto out;
-    }
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
 	cc33xx_debug(DEBUG_ACX, "acx group address tbl");
 
-    acx->enabled = enable;
-    acx->num_groups = mc_list_len;
-    memcpy(acx->mac_table, mc_list, mc_list_len * ETH_ALEN);
+	acx->enabled = enable;
+	acx->num_groups = mc_list_len;
+	memcpy(acx->mac_table, mc_list, mc_list_len * ETH_ALEN);
 
-    ret = cc33xx_cmd_configure(wl, DOT11_GROUP_ADDRESS_TBL, acx, sizeof(*acx));
-    if (ret < 0) {
-        cc33xx_warning("failed to set group addr table: %d", ret);
-        goto out;
-    }
+	ret = cc33xx_cmd_configure(wl, DOT11_GROUP_ADDRESS_TBL,
+				   acx, sizeof(*acx));
+	if (ret < 0) {
+		cc33xx_warning("failed to set group addr table: %d", ret);
+		goto out;
+	}
 out:
-    kfree(acx);
-    return ret;
+	kfree(acx);
+	return ret;
 }
 
 int cc33xx_acx_service_period_timeout(struct cc33xx *wl,
 				      struct cc33xx_vif *wlvif)
 {
 	struct acx_rx_timeout *rx_timeout;
+	struct conf_rx_settings *rx_settings = &wl->conf.host_conf.rx;
 	int ret;
 
 	rx_timeout = kzalloc(sizeof(*rx_timeout), GFP_KERNEL);
@@ -353,14 +319,13 @@ int cc33xx_acx_service_period_timeout(struct cc33xx *wl,
 	cc33xx_debug(DEBUG_ACX, "acx service period timeout");
 
 	rx_timeout->role_id = wlvif->role_id;
-	rx_timeout->ps_poll_timeout = cpu_to_le16(wl->conf.host_conf.rx.ps_poll_timeout);
-	rx_timeout->upsd_timeout = cpu_to_le16(wl->conf.host_conf.rx.upsd_timeout);
+	rx_timeout->ps_poll_timeout = cpu_to_le16(rx_settings->ps_poll_timeout);
+	rx_timeout->upsd_timeout = cpu_to_le16(rx_settings->upsd_timeout);
 
 	ret = cc33xx_cmd_configure(wl, ACX_SERVICE_PERIOD_TIMEOUT,
 				   rx_timeout, sizeof(*rx_timeout));
 	if (ret < 0) {
-		cc33xx_warning("failed to set service period timeout: %d",
-			       ret);
+		cc33xx_warning("failed to set service period timeout: %d", ret);
 		goto out;
 	}
 
@@ -404,35 +369,6 @@ int cc33xx_acx_rts_threshold(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-int cc33xx_acx_dco_itrim_params(struct cc33xx *wl)
-{
-	struct acx_dco_itrim_params *dco;
-	struct conf_itrim_settings *c = &wl->conf.host_conf.itrim;
-	int ret;
-
-	cc33xx_debug(DEBUG_ACX, "acx dco itrim parameters");
-
-	dco = kzalloc(sizeof(*dco), GFP_KERNEL);
-	if (!dco) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	dco->enable = c->enable;
-	dco->timeout = cpu_to_le32(c->timeout);
-
-	ret = cc33xx_cmd_configure(wl, ACX_SET_DCO_ITRIM_PARAMS,
-				   dco, sizeof(*dco));
-	if (ret < 0) {
-		cc33xx_warning("failed to set dco itrim parameters: %d", ret);
-		goto out;
-	}
-
-out:
-	kfree(dco);
-	return ret;
-}
-
 int cc33xx_acx_beacon_filter_opt(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				 bool enable_filter)
 {
@@ -461,7 +397,7 @@ int cc33xx_acx_beacon_filter_opt(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	 */
 	beacon_filter->max_num_beacons = 0;
 
-	ret = cc33xx_cmd_configure(wl, ACX_BEACON_FILTER_OPT,
+	ret = cc33xx_cmd_configure(wl, BEACON_FILTER_OPT,
 				   beacon_filter, sizeof(*beacon_filter));
 	if (ret < 0) {
 		cc33xx_warning("failed to set beacon filter opt: %d", ret);
@@ -473,8 +409,7 @@ int cc33xx_acx_beacon_filter_opt(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-int cc33xx_acx_beacon_filter_table(struct cc33xx *wl,
-				   struct cc33xx_vif *wlvif)
+int cc33xx_acx_beacon_filter_table(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 {
 	struct acx_beacon_filter_ie_table *ie_table;
 	struct conf_bcn_filt_rule bcn_filt_ie[32];
@@ -521,7 +456,7 @@ int cc33xx_acx_beacon_filter_table(struct cc33xx *wl,
 		ie_table->num_ie++;
 	}
 
-	ret = cc33xx_cmd_configure(wl, ACX_BEACON_FILTER_TABLE,
+	ret = cc33xx_cmd_configure(wl, BEACON_FILTER_TABLE,
 				   ie_table, sizeof(*ie_table));
 	if (ret < 0) {
 		cc33xx_warning("failed to set beacon filter table: %d", ret);
@@ -574,35 +509,10 @@ int cc33xx_acx_conn_monit_params(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-int cc33xx_acx_cca_threshold(struct cc33xx *wl)
-{
-	struct acx_energy_detection *detection;
-	int ret;
-
-	cc33xx_debug(DEBUG_ACX, "acx cca threshold");
-
-	detection = kzalloc(sizeof(*detection), GFP_KERNEL);
-	if (!detection) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	detection->rx_cca_threshold = cpu_to_le16(wl->conf.host_conf.rx.rx_cca_threshold);
-	detection->tx_energy_detection = wl->conf.host_conf.tx.tx_energy_detection;
-
-	ret = cc33xx_cmd_configure(wl, ACX_CCA_THRESHOLD,
-				   detection, sizeof(*detection));
-	if (ret < 0)
-		cc33xx_warning("failed to set cca threshold: %d", ret);
-
-out:
-	kfree(detection);
-	return ret;
-}
-
 int cc33xx_acx_bcn_dtim_options(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 {
 	struct acx_beacon_broadcast *bb;
+	struct conf_conn_settings *conn_settings = &wl->conf.host_conf.conn;
 	int ret;
 
 	cc33xx_debug(DEBUG_ACX, "acx bcn dtim options");
@@ -614,10 +524,10 @@ int cc33xx_acx_bcn_dtim_options(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	}
 
 	bb->role_id = wlvif->role_id;
-	bb->beacon_rx_timeout = cpu_to_le16(wl->conf.host_conf.conn.beacon_rx_timeout);
-	bb->broadcast_timeout = cpu_to_le16(wl->conf.host_conf.conn.broadcast_timeout);
-	bb->rx_broadcast_in_ps = wl->conf.host_conf.conn.rx_broadcast_in_ps;
-	bb->ps_poll_threshold = wl->conf.host_conf.conn.ps_poll_threshold;
+	bb->beacon_rx_timeout = cpu_to_le16(conn_settings->beacon_rx_timeout);
+	bb->broadcast_timeout = cpu_to_le16(conn_settings->broadcast_timeout);
+	bb->rx_broadcast_in_ps = conn_settings->rx_broadcast_in_ps;
+	bb->ps_poll_threshold = conn_settings->ps_poll_threshold;
 
 	ret = cc33xx_cmd_configure(wl, ACX_BCN_DTIM_OPTIONS, bb, sizeof(*bb));
 	if (ret < 0) {
@@ -630,67 +540,39 @@ int cc33xx_acx_bcn_dtim_options(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	return ret;
 }
 
-int cc33xx_assoc_info_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif, struct ieee80211_sta *sta,u16 aid)
-{
-    struct assoc_info_cfg *cfg;
-    int ret;
-
-    cc33xx_debug(DEBUG_ACX, "acx aid");
-
-    cfg = kzalloc(sizeof(*cfg), GFP_KERNEL);
-    if (!cfg) {
-        ret = -ENOMEM;
-        goto out;
-    }
-
-    cfg->role_id = wlvif->role_id;
-    cfg->aid = cpu_to_le16(aid);
-    cfg->wmm_enabled = wlvif->wmm_enabled;
-
-    cfg->nontransmitted = wlvif->nontransmitted;
-    cfg->bssid_index = wlvif->bssid_index;
-    cfg->bssid_indicator = wlvif->bssid_indicator;
-	cfg->ht_supported = sta->deflink.ht_cap.ht_supported;
-	cfg->vht_supported = sta->deflink.vht_cap.vht_supported;
-	cfg->has_he = sta->deflink.he_cap.has_he;
-    memcpy(cfg->transmitter_bssid,
-		wlvif->transmitter_bssid,
-		ETH_ALEN);
-    ret = cc33xx_cmd_configure(wl, ASSOC_INFO_CFG, cfg, sizeof(*cfg));
-    if (ret < 0) {
-        cc33xx_warning("failed to set aid: %d", ret);
-        goto out;
-    }
-
-out:
-    kfree(cfg);
-    return ret;
-}
-
-int cc33xx_acx_aid(struct cc33xx *wl, struct cc33xx_vif *wlvif, u16 aid)
+int cc33xx_assoc_info_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+			  struct ieee80211_sta *sta, u16 aid)
 {
-	struct acx_aid *acx_aid;
+	struct assoc_info_cfg *cfg;
 	int ret;
 
 	cc33xx_debug(DEBUG_ACX, "acx aid");
 
-	acx_aid = kzalloc(sizeof(*acx_aid), GFP_KERNEL);
-	if (!acx_aid) {
+	cfg = kzalloc(sizeof(*cfg), GFP_KERNEL);
+	if (!cfg) {
 		ret = -ENOMEM;
 		goto out;
 	}
 
-	acx_aid->role_id = wlvif->role_id;
-	acx_aid->aid = cpu_to_le16(aid);
+	cfg->role_id = wlvif->role_id;
+	cfg->aid = cpu_to_le16(aid);
+	cfg->wmm_enabled = wlvif->wmm_enabled;
 
-	ret = cc33xx_cmd_configure(wl, ACX_AID, acx_aid, sizeof(*acx_aid));
+	cfg->nontransmitted = wlvif->nontransmitted;
+	cfg->bssid_index = wlvif->bssid_index;
+	cfg->bssid_indicator = wlvif->bssid_indicator;
+	cfg->ht_supported = sta->deflink.ht_cap.ht_supported;
+	cfg->vht_supported = sta->deflink.vht_cap.vht_supported;
+	cfg->has_he = sta->deflink.he_cap.has_he;
+	memcpy(cfg->transmitter_bssid, wlvif->transmitter_bssid, ETH_ALEN);
+	ret = cc33xx_cmd_configure(wl, ASSOC_INFO_CFG, cfg, sizeof(*cfg));
 	if (ret < 0) {
 		cc33xx_warning("failed to set aid: %d", ret);
 		goto out;
 	}
 
 out:
-	kfree(acx_aid);
+	kfree(cfg);
 	return ret;
 }
 
@@ -787,7 +669,7 @@ int cc33xx_acx_statistics(struct cc33xx *wl, void *stats)
 
 	ret = cc33xx_cmd_interrogate(wl, ACX_STATISTICS, stats,
 				     sizeof(struct acx_header),
-				     wl->stats.fw_stats_len);
+				     sizeof(struct cc33xx_acx_statistics_t));
 	if (ret < 0) {
 		cc33xx_warning("acx statistics failed: %d", ret);
 		return -ENOMEM;
@@ -796,18 +678,20 @@ int cc33xx_acx_statistics(struct cc33xx *wl, void *stats)
 	return 0;
 }
 
-int cc33xx_update_ap_rates(struct cc33xx *wl,u8 role_id,u32 basic_rates_set,u32 supported_rates){
-
+int cc33xx_update_ap_rates(struct cc33xx *wl, u8 role_id,
+			   u32 basic_rates_set, u32 supported_rates)
+{
 	struct ap_rates_class_cfg *cfg;
 	int ret;
-	cc33xx_debug(DEBUG_AP, "Attempting to Update Basic Rates and Supported Rates");
+	cc33xx_debug(DEBUG_AP,
+		     "Attempting to Update Basic Rates and Supported Rates");
 
 	cfg = kzalloc(sizeof(*cfg), GFP_KERNEL);
 
-    if (!cfg) {
-        ret = -ENOMEM;
-        goto out;
-    }
+	if (!cfg) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
 	cfg->basic_rates_set = cpu_to_le32(basic_rates_set);
 	cfg->supported_rates = cpu_to_le32(supported_rates);
@@ -823,121 +707,51 @@ int cc33xx_update_ap_rates(struct cc33xx *wl,u8 role_id,u32 basic_rates_set,u32
     return ret;
 }
 
-int cc33xx_tx_param_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-              u8 ac, u8 cw_min, u16 cw_max, u8 aifsn, u16 txop, bool acm,
-              u8 ps_scheme, u8 is_mu_edca, u8 mu_edca_aifs, u8 mu_edca_ecw_min_max,
-              u8 mu_edca_timer)
-{
-    struct tx_param_cfg *cfg;
-    int ret = 0;
-
-    cc33xx_debug(DEBUG_ACX, "tx param cfg %d cw_ming %d cw_max %d "
-             "aifs %d txop %d", ac, cw_min, cw_max, aifsn, txop);
-
-    cc33xx_debug(DEBUG_ACX, "tx param cfg ps_scheme %d is_mu_edca %d mu_edca_aifs %d "
-                 "mu_edca_ecw_min_max %d mu_edca_timer %d",
-                 ps_scheme, is_mu_edca, mu_edca_aifs, mu_edca_ecw_min_max, mu_edca_timer);
-
-    cfg = kzalloc(sizeof(*cfg), GFP_KERNEL);
-
-    if (!cfg) {
-        ret = -ENOMEM;
-        goto out;
-    }
-
-    cfg->role_id = wlvif->role_id;
-    cfg->ac = ac;
-    cfg->cw_min = cw_min;
-    cfg->cw_max = cpu_to_le16(cw_max);
-    cfg->aifsn = aifsn;
-    cfg->tx_op_limit = cpu_to_le16(txop);
-    cfg->acm = cpu_to_le16(acm);
-
-    cfg->ps_scheme = ps_scheme;
-    cfg->is_mu_edca = is_mu_edca;
-    cfg->mu_edca_aifs = mu_edca_aifs;
-    cfg->mu_edca_ecw_min_max = mu_edca_ecw_min_max;
-    cfg->mu_edca_timer = mu_edca_timer;
-
-    ret = cc33xx_cmd_configure(wl, TX_PARAMS_CFG, cfg, sizeof(*cfg));
-    if (ret < 0) {
-        cc33xx_warning("tx param cfg failed: %d", ret);
-        goto out;
-    }
-
-out:
-    kfree(cfg);
-    return ret;
-}
-
-int cc33xx_acx_ac_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-		      u8 ac, u8 cw_min, u16 cw_max, u8 aifsn, u16 txop)
+int cc33xx_tx_param_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 ac,
+			u8 cw_min, u16 cw_max, u8 aifsn, u16 txop, bool acm,
+			u8 ps_scheme, u8 is_mu_edca, u8 mu_edca_aifs,
+			u8 mu_edca_ecw_min_max, u8 mu_edca_timer)
 {
-	struct acx_ac_cfg *acx;
+	struct tx_param_cfg *cfg;
 	int ret = 0;
 
-	cc33xx_debug(DEBUG_ACX, "acx ac cfg %d cw_ming %d cw_max %d "
-		     "aifs %d txop %d", ac, cw_min, cw_max, aifsn, txop);
-
-	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
-
-	if (!acx) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	acx->role_id = wlvif->role_id;
-	acx->ac = ac;
-	acx->cw_min = cw_min;
-	acx->cw_max = cpu_to_le16(cw_max);
-	acx->aifsn = aifsn;
-	acx->tx_op_limit = cpu_to_le16(txop);
-
-	ret = cc33xx_cmd_configure(wl, ACX_AC_CFG, acx, sizeof(*acx));
-	if (ret < 0) {
-		cc33xx_warning("acx ac cfg failed: %d", ret);
-		goto out;
-	}
-
-out:
-	kfree(acx);
-	return ret;
-}
-
-int cc33xx_acx_tid_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-		       u8 queue_id, u8 channel_type,
-		       u8 tsid, u8 ps_scheme, u8 ack_policy,
-		       u32 apsd_conf0, u32 apsd_conf1)
-{
-	struct acx_tid_config *acx;
-	int ret = 0;
+	cc33xx_debug(DEBUG_ACX,
+		     "tx param cfg %d cw_ming %d cw_max %d aifs %d txop %d",
+		     ac, cw_min, cw_max, aifsn, txop);
 
-	cc33xx_debug(DEBUG_ACX, "acx tid config");
+	cc33xx_debug(DEBUG_ACX, "tx param cfg ps_scheme %d is_mu_edca %d "
+		     "mu_edca_aifs %d mu_edca_ecw_min_max %d mu_edca_timer %d",
+		     ps_scheme, is_mu_edca, mu_edca_aifs, mu_edca_ecw_min_max,
+		     mu_edca_timer);
 
-	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	cfg = kzalloc(sizeof(*cfg), GFP_KERNEL);
 
-	if (!acx) {
+	if (!cfg) {
 		ret = -ENOMEM;
 		goto out;
 	}
 
-	acx->role_id = wlvif->role_id;
-	acx->queue_id = queue_id;
-	acx->channel_type = channel_type;
-	acx->tsid = tsid;
-	acx->ps_scheme = ps_scheme;
-	acx->ack_policy = ack_policy;
-	acx->apsd_conf[0] = cpu_to_le32(apsd_conf0);
-	acx->apsd_conf[1] = cpu_to_le32(apsd_conf1);
-
-	ret = cc33xx_cmd_configure(wl, ACX_TID_CFG, acx, sizeof(*acx));
+	cfg->role_id = wlvif->role_id;
+	cfg->ac = ac;
+	cfg->cw_min = cw_min;
+	cfg->cw_max = cpu_to_le16(cw_max);
+	cfg->aifsn = aifsn;
+	cfg->tx_op_limit = cpu_to_le16(txop);
+	cfg->acm = cpu_to_le16(acm);
+	cfg->ps_scheme = ps_scheme;
+	cfg->is_mu_edca = is_mu_edca;
+	cfg->mu_edca_aifs = mu_edca_aifs;
+	cfg->mu_edca_ecw_min_max = mu_edca_ecw_min_max;
+	cfg->mu_edca_timer = mu_edca_timer;
+
+	ret = cc33xx_cmd_configure(wl, TX_PARAMS_CFG, cfg, sizeof(*cfg));
 	if (ret < 0) {
-		cc33xx_warning("Setting of tid config failed: %d", ret);
+		cc33xx_warning("tx param cfg failed: %d", ret);
 		goto out;
 	}
 
 out:
-	kfree(acx);
+	kfree(cfg);
 	return ret;
 }
 
@@ -974,33 +788,6 @@ int cc33xx_acx_frag_threshold(struct cc33xx *wl, u32 frag_threshold)
 	return ret;
 }
 
-int cc33xx_acx_tx_config_options(struct cc33xx *wl)
-{
-	struct acx_tx_config_options *acx;
-	int ret = 0;
-
-	cc33xx_debug(DEBUG_ACX, "acx tx config options");
-
-	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
-
-	if (!acx) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	acx->tx_compl_timeout = cpu_to_le16(wl->conf.host_conf.tx.tx_compl_timeout);
-	acx->tx_compl_threshold = cpu_to_le16(wl->conf.host_conf.tx.tx_compl_threshold);
-	ret = cc33xx_cmd_configure(wl, ACX_TX_CONFIG_OPT, acx, sizeof(*acx));
-	if (ret < 0) {
-		cc33xx_warning("Setting of tx options failed: %d", ret);
-		goto out;
-	}
-
-out:
-	kfree(acx);
-	return ret;
-}
-
 int cc33xx_acx_mem_cfg(struct cc33xx *wl)
 {
 	struct cc33xx_acx_config_memory *mem_conf;
@@ -1022,7 +809,7 @@ int cc33xx_acx_mem_cfg(struct cc33xx *wl)
 	mem_conf->rx_mem_block_num = mem->rx_block_num;
 	mem_conf->tx_min_mem_block_num = mem->tx_min_block_num;
 	mem_conf->num_ssid_profiles = mem->ssid_profiles;
-	mem_conf->total_tx_descriptors = cpu_to_le32(wl->num_tx_desc);
+	mem_conf->total_tx_descriptors = cpu_to_le32(CC33XX_NUM_TX_DESCRIPTORS);
 	mem_conf->dyn_mem_enable = mem->dynamic_memory;
 	mem_conf->tx_free_req = mem->min_req_tx_blocks;
 	mem_conf->rx_free_req = mem->min_req_rx_blocks;
@@ -1045,7 +832,7 @@ int cc33xx_acx_init_mem_config(struct cc33xx *wl)
 {
 	int ret;
 
-	wl->target_mem_map = kzalloc(sizeof(struct cc33xx_acx_mem_map),
+	wl->target_mem_map = kzalloc(sizeof(struct cc33xx_acx_mem_map_t),
 				     GFP_KERNEL);
 	if (!wl->target_mem_map) {
 		cc33xx_error("couldn't allocate target memory map");
@@ -1054,7 +841,7 @@ int cc33xx_acx_init_mem_config(struct cc33xx *wl)
 
 	/* we now ask for the firmware built memory map */
 	ret = cc33xx_acx_mem_map(wl, (void *)wl->target_mem_map,
-				 sizeof(struct cc33xx_acx_mem_map));
+				 sizeof(struct cc33xx_acx_mem_map_t));
 	if (ret < 0) {
 		cc33xx_error("couldn't retrieve firmware memory map");
 		kfree(wl->target_mem_map);
@@ -1068,7 +855,8 @@ int cc33xx_acx_init_mem_config(struct cc33xx *wl)
 	cc33xx_debug(DEBUG_TX, "available tx blocks: %d",
 		     wl->tx_blocks_available);
 
-	cc33xx_debug(DEBUG_TX, "available tx descriptor: %d available rx blocks %d",
+	cc33xx_debug(DEBUG_TX,
+		     "available tx descriptor: %d available rx blocks %d",
 		     wl->target_mem_map->num_tx_descriptor,
 		     wl->target_mem_map->num_rx_mem_blocks);
 
@@ -1101,6 +889,7 @@ int cc33xx_acx_init_get_fw_versions(struct cc33xx *wl)
 int cc33xx_acx_init_rx_interrupt(struct cc33xx *wl)
 {
 	struct cc33xx_acx_rx_config_opt *rx_conf;
+	struct conf_rx_settings *rx_settings = &wl->conf.host_conf.rx;
 	int ret;
 
 	cc33xx_debug(DEBUG_ACX, "cc33xx rx interrupt config");
@@ -1111,10 +900,10 @@ int cc33xx_acx_init_rx_interrupt(struct cc33xx *wl)
 		goto out;
 	}
 
-	rx_conf->threshold = cpu_to_le16(wl->conf.host_conf.rx.irq_pkt_threshold);
-	rx_conf->timeout = cpu_to_le16(wl->conf.host_conf.rx.irq_timeout);
-	rx_conf->mblk_threshold = cpu_to_le16(wl->conf.host_conf.rx.irq_blk_threshold);
-	rx_conf->queue_type = wl->conf.host_conf.rx.queue_type;
+	rx_conf->threshold = cpu_to_le16(rx_settings->irq_pkt_threshold);
+	rx_conf->timeout = cpu_to_le16(rx_settings->irq_timeout);
+	rx_conf->mblk_threshold = cpu_to_le16(rx_settings->irq_blk_threshold);
+	rx_conf->queue_type = rx_settings->queue_type;
 
 	ret = cc33xx_cmd_configure(wl, ACX_RX_CONFIG_OPT, rx_conf,
 				   sizeof(*rx_conf));
@@ -1128,8 +917,8 @@ int cc33xx_acx_init_rx_interrupt(struct cc33xx *wl)
 	return ret;
 }
 
-int cc33xx_acx_bet_enable(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			  bool enable)
+int cc33xx_acx_bet_enable(struct cc33xx *wl,
+			  struct cc33xx_vif *wlvif, bool enable)
 {
 	struct cc33xx_acx_bet_enable *acx = NULL;
 	int ret = 0;
@@ -1160,7 +949,7 @@ int cc33xx_acx_bet_enable(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-int cc33x_acx_arp_ip_filter(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+int cc33xx_acx_arp_ip_filter(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			     u8 enable, __be32 address)
 {
 	struct cc33xx_acx_arp_filter *acx;
@@ -1181,8 +970,7 @@ int cc33x_acx_arp_ip_filter(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	if (enable)
 		memcpy(acx->address, &address, ACX_IPV4_ADDR_SIZE);
 
-	ret = cc33xx_cmd_configure(wl, ACX_ARP_IP_FILTER,
-				   acx, sizeof(*acx));
+	ret = cc33xx_cmd_configure(wl, ACX_ARP_IP_FILTER, acx, sizeof(*acx));
 	if (ret < 0) {
 		cc33xx_warning("failed to set arp ip filter: %d", ret);
 		goto out;
@@ -1193,34 +981,6 @@ int cc33x_acx_arp_ip_filter(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-int cc33xx_acx_pm_config(struct cc33xx *wl)
-{
-	struct cc33xx_acx_pm_config *acx = NULL;
-	struct  conf_pm_config_settings *c = &wl->conf.host_conf.pm_config;
-	int ret = 0;
-
-	cc33xx_debug(DEBUG_ACX, "acx pm config");
-
-	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
-	if (!acx) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	acx->host_clk_settling_time = cpu_to_le32(c->host_clk_settling_time);
-	acx->host_fast_wakeup_support = c->host_fast_wakeup_support;
-
-	ret = cc33xx_cmd_configure(wl, ACX_PM_CONFIG, acx, sizeof(*acx));
-	if (ret < 0) {
-		cc33xx_warning("acx pm config failed: %d", ret);
-		goto out;
-	}
-
-out:
-	kfree(acx);
-	return ret;
-}
-
 int cc33xx_acx_rssi_snr_trigger(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				bool enable, s16 thold, u8 hyst)
 {
@@ -1262,10 +1022,9 @@ int cc33xx_acx_rssi_snr_trigger(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-int cc33xx_acx_rssi_snr_avg_weights(struct cc33xx *wl,
-				    struct cc33xx_vif *wlvif)
+int cc33xx_acx_rssi_snr_avg_weights(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 {
-	struct cc33xx_acx_rssi_snr_avg_weights *acx = NULL;
+	struct cc33xx_acx_rssi_snr_avg_weights_t *acx = NULL;
 	struct conf_roam_trigger_settings *c = &wl->conf.host_conf.roam_trigger;
 	int ret = 0;
 
@@ -1302,9 +1061,9 @@ int cc33xx_acx_set_ht_capabilities(struct cc33xx *wl,
 	int ret = 0;
 	u32 ht_capabilites = 0;
 
-	cc33xx_debug(DEBUG_ACX, "acx ht capabilities setting "
-		     "sta supp: %d sta cap: %d", ht_cap->ht_supported,
-		     ht_cap->cap);
+	cc33xx_debug(DEBUG_ACX,
+		     "acx ht capabilities setting sta supp: %d sta cap: %d",
+		     ht_cap->ht_supported, ht_cap->cap);
 
 	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
 	if (!acx) {
@@ -1342,10 +1101,9 @@ int cc33xx_acx_set_ht_capabilities(struct cc33xx *wl,
 }
 
 
-int cc33xx_acx_set_ht_information(struct cc33xx *wl,
-				   struct cc33xx_vif *wlvif,
-				   u16 ht_operation_mode,
-				   u32 he_oper_params, u16 he_oper_nss_set)
+int cc33xx_acx_set_ht_information(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+				  u16 ht_operation_mode, u32 he_oper_params,
+				  u16 he_oper_nss_set)
 {
 	struct cc33xx_acx_ht_information *acx;
 	int ret = 0;
@@ -1367,7 +1125,8 @@ int cc33xx_acx_set_ht_information(struct cc33xx *wl,
 
 	acx->dual_cts_protection = 0;
 
-	cc33xx_debug(DEBUG_ACX, "HE operation: 0x%xm mcs: 0x%x",he_oper_params, he_oper_nss_set);
+	cc33xx_debug(DEBUG_ACX, "HE operation: 0x%xm mcs: 0x%x",
+		     he_oper_params, he_oper_nss_set);
 
 	acx->he_operation = cpu_to_le32(he_oper_params);
 	acx->bss_basic_mcs_set = cpu_to_le16(he_oper_nss_set);
@@ -1389,6 +1148,7 @@ int cc33xx_acx_set_ba_initiator_policy(struct cc33xx *wl,
 				       struct cc33xx_vif *wlvif)
 {
 	struct cc33xx_acx_ba_initiator_policy *acx;
+	struct conf_ht_setting *ht_settings = &wl->conf.host_conf.ht;
 	int ret;
 
 	cc33xx_debug(DEBUG_ACX, "acx ba initiator policy");
@@ -1401,14 +1161,12 @@ int cc33xx_acx_set_ba_initiator_policy(struct cc33xx *wl,
 
 	/* set for the current role */
 	acx->role_id = wlvif->role_id;
-	acx->tid_bitmap = wl->conf.host_conf.ht.tx_ba_tid_bitmap;
-	acx->win_size = wl->conf.host_conf.ht.tx_ba_win_size;
-	acx->inactivity_timeout = cpu_to_le16(wl->conf.host_conf.ht.inactivity_timeout);
+	acx->tid_bitmap = ht_settings->tx_ba_tid_bitmap;
+	acx->win_size = ht_settings->tx_ba_win_size;
+	acx->inactivity_timeout = cpu_to_le16(ht_settings->inactivity_timeout);
 
-	ret = cc33xx_cmd_configure(wl,
-				   ACX_BA_SESSION_INIT_POLICY,
-				   acx,
-				   sizeof(*acx));
+	ret = cc33xx_cmd_configure(wl, ACX_BA_SESSION_INIT_POLICY,
+				   acx, sizeof(*acx));
 	if (ret < 0) {
 		cc33xx_warning("acx ba initiator policy failed: %d", ret);
 		goto out;
@@ -1420,9 +1178,8 @@ int cc33xx_acx_set_ba_initiator_policy(struct cc33xx *wl,
 }
 
 /* setup BA session receiver setting in the FW. */
-int cc33xx_acx_set_ba_receiver_session(struct cc33xx *wl, u8 tid_index,
-				       u16 ssn, bool enable, u8 peer_hlid,
-				       u8 win_size)
+int cc33xx_acx_set_ba_receiver_session(struct cc33xx *wl, u8 tid_index, u16 ssn,
+				       bool enable, u8 peer_hlid, u8 win_size)
 {
 	struct cc33xx_acx_ba_receiver_setup *acx;
 	int ret;
@@ -1441,8 +1198,8 @@ int cc33xx_acx_set_ba_receiver_session(struct cc33xx *wl, u8 tid_index,
 	acx->win_size =	win_size;
 	acx->ssn = cpu_to_le16(ssn);
 
-	ret = wlcore_cmd_configure_failsafe(wl, BA_SESSION_RX_SETUP_CFG, acx,
-					    sizeof(*acx),
+	ret = wlcore_cmd_configure_failsafe(wl, BA_SESSION_RX_SETUP_CFG,
+					    acx, sizeof(*acx),
 					    BIT(CMD_STATUS_NO_RX_BA_SESSION));
 	if (ret < 0) {
 		cc33xx_warning("acx ba receiver session failed: %d", ret);
@@ -1513,10 +1270,7 @@ int cc33xx_acx_static_calibration_configure(struct cc33xx *wl,
 			acx->calibration_header.length);
 
 out:
-	ret = cc33xx_cmd_configure(wl,
-				   STATIC_CALIBRATION_CFG,
-				   acx,
-				   size);
+	ret = cc33xx_cmd_configure(wl, STATIC_CALIBRATION_CFG, acx, size);
 
 	if (ret < 0)
 		cc33xx_warning("acx command sending failed: %d", ret);
@@ -1540,7 +1294,8 @@ int cc33xx_acx_tsf_info(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	tsf_info->role_id = wlvif->role_id;
 
 	ret = cc33xx_cmd_interrogate(wl, ACX_TSF_INFO, tsf_info,
-				sizeof(struct acx_header), sizeof(*tsf_info));
+				     sizeof(struct acx_header),
+				     sizeof(*tsf_info));
 	if (ret < 0) {
 		cc33xx_warning("acx tsf info interrogate failed");
 		goto out;
@@ -1554,10 +1309,11 @@ int cc33xx_acx_tsf_info(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-int cc33xx_acx_ps_rx_streaming(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			       bool enable)
+int cc33xx_acx_ps_rx_streaming(struct cc33xx *wl,
+			       struct cc33xx_vif *wlvif, bool enable)
 {
 	struct cc33xx_acx_ps_rx_streaming *rx_streaming;
+	struct cc33xx_host_conf *host_conf = &wl->conf.host_conf;
 	u32 conf_queues, enable_queues;
 	int i, ret = 0;
 
@@ -1569,7 +1325,7 @@ int cc33xx_acx_ps_rx_streaming(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 		goto out;
 	}
 
-	conf_queues = wl->conf.host_conf.rx_streaming.queues;
+	conf_queues = host_conf->rx_streaming.queues;
 	if (enable)
 		enable_queues = conf_queues;
 	else
@@ -1587,8 +1343,8 @@ int cc33xx_acx_ps_rx_streaming(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 		rx_streaming->role_id = wlvif->role_id;
 		rx_streaming->tid = i;
 		rx_streaming->enable = enable_queues & BIT(i);
-		rx_streaming->period = wl->conf.host_conf.rx_streaming.interval;
-		rx_streaming->timeout = wl->conf.host_conf.rx_streaming.interval;
+		rx_streaming->period = host_conf->rx_streaming.interval;
+		rx_streaming->timeout = host_conf->rx_streaming.interval;
 
 		ret = cc33xx_cmd_configure(wl, ACX_PS_RX_STREAMING,
 					   rx_streaming,
@@ -1685,55 +1441,12 @@ int cc33xx_acx_set_inconnection_sta(struct cc33xx *wl,
 	return ret;
 }
 
-int cc33xx_acx_set_rate_mgmt_params(struct cc33xx *wl)
-{
-	struct cc33xx_acx_set_rate_mgmt_params *acx = NULL;
-	struct conf_rate_policy_settings *conf = &wl->conf.host_conf.rate;
-	int ret;
-
-	cc33xx_debug(DEBUG_ACX, "acx set rate mgmt params");
-
-	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
-	if (!acx)
-		return -ENOMEM;
-
-	acx->index = ACX_RATE_MGMT_ALL_PARAMS;
-	acx->rate_retry_score = cpu_to_le16(conf->rate_retry_score);
-	acx->per_add = cpu_to_le16(conf->per_add);
-	acx->per_th1 = cpu_to_le16(conf->per_th1);
-	acx->per_th2 = cpu_to_le16(conf->per_th2);
-	acx->max_per = cpu_to_le16(conf->max_per);
-	acx->inverse_curiosity_factor = conf->inverse_curiosity_factor;
-	acx->tx_fail_low_th = conf->tx_fail_low_th;
-	acx->tx_fail_high_th = conf->tx_fail_high_th;
-	acx->per_alpha_shift = conf->per_alpha_shift;
-	acx->per_add_shift = conf->per_add_shift;
-	acx->per_beta1_shift = conf->per_beta1_shift;
-	acx->per_beta2_shift = conf->per_beta2_shift;
-	acx->rate_check_up = conf->rate_check_up;
-	acx->rate_check_down = conf->rate_check_down;
-	memcpy(acx->rate_retry_policy, conf->rate_retry_policy,
-	       sizeof(acx->rate_retry_policy));
-
-	ret = cc33xx_cmd_configure(wl, ACX_SET_RATE_MGMT_PARAMS,
-				   acx, sizeof(*acx));
-	if (ret < 0) {
-		cc33xx_warning("acx set rate mgmt params failed: %d", ret);
-		goto out;
-	}
-
-out:
-	kfree(acx);
-	return ret;
-}
-
-int cc33xx_acx_config_hangover(struct cc33xx *wl)
+int wlcore_acx_average_rssi(struct cc33xx *wl,
+			    struct cc33xx_vif *wlvif, s8 *avg_rssi)
 {
-	struct cc33xx_acx_config_hangover *acx;
-	struct conf_hangover_settings *conf = &wl->conf.host_conf.hangover;
-	int ret;
-
-	cc33xx_debug(DEBUG_ACX, "acx config hangover");
+	struct acx_roaming_stats *acx;
+	int ret = 0;
+	cc33xx_debug(DEBUG_ACX, "acx roaming statistics");
 
 	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
 	if (!acx) {
@@ -1741,38 +1454,29 @@ int cc33xx_acx_config_hangover(struct cc33xx *wl)
 		goto out;
 	}
 
-	acx->recover_time = cpu_to_le32(conf->recover_time);
-	acx->hangover_period = conf->hangover_period;
-	acx->dynamic_mode = conf->dynamic_mode;
-	acx->early_termination_mode = conf->early_termination_mode;
-	acx->max_period = conf->max_period;
-	acx->min_period = conf->min_period;
-	acx->increase_delta = conf->increase_delta;
-	acx->decrease_delta = conf->decrease_delta;
-	acx->quiet_time = conf->quiet_time;
-	acx->increase_time = conf->increase_time;
-	acx->window_size = conf->window_size;
-
-	ret = cc33xx_cmd_configure(wl, ACX_CONFIG_HANGOVER, acx,
-				   sizeof(*acx));
+	acx->role_id = wlvif->role_id;
 
-	if (ret < 0) {
-		cc33xx_warning("acx config hangover failed: %d", ret);
+	ret = cc33xx_cmd_interrogate(wl, RSSI_INTR,
+				     acx, sizeof(*acx), sizeof(*acx));
+	if (ret	< 0) {
+		cc33xx_warning("acx roaming statistics failed: %d", ret);
+		ret = -ENOMEM;
 		goto out;
 	}
 
+	*avg_rssi = acx->rssi_beacon;
+
 out:
 	kfree(acx);
 	return ret;
-
 }
 
-int wlcore_acx_average_rssi(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			    s8 *avg_rssi)
+int wlcore_acx_get_tx_rate(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+			    struct station_info *sinfo)
 {
-	struct acx_roaming_stats *acx;
-	int ret = 0;
-	cc33xx_debug(DEBUG_ACX, "acx roaming statistics");
+	struct acx_preamble_and_tx_rate *acx;
+	int ret;
+	cc33xx_debug(DEBUG_ACX, "acx get tx rate");
 
 	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
 	if (!acx) {
@@ -1782,19 +1486,41 @@ int wlcore_acx_average_rssi(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 
 	acx->role_id = wlvif->role_id;
 
-	ret = cc33xx_cmd_interrogate(wl, RSSI_INTR,
+	ret = cc33xx_cmd_interrogate(wl, GET_PREAMBLE_AND_TX_RATE_INTR,
 				     acx, sizeof(*acx), sizeof(*acx));
 	if (ret	< 0) {
-		cc33xx_warning("acx roaming statistics failed: %d", ret);
+		cc33xx_warning("acx get preamble and tx rate failed: %d", ret);
 		ret = -ENOMEM;
 		goto out;
 	}
 
-	*avg_rssi = acx->rssi_beacon;
+	//flags handler:
+    sinfo->txrate.flags = 0;
+	if(acx->preamble == CONF_PREAMBLE_TYPE_AC_VHT)
+		sinfo->txrate.flags = RATE_INFO_FLAGS_VHT_MCS;
+	else if((acx->preamble >= CONF_PREAMBLE_TYPE_AX_SU) && (acx->preamble <= CONF_PREAMBLE_TYPE_AX_TB_NDP_FB))
+		sinfo->txrate.flags = RATE_INFO_FLAGS_HE_MCS;
+    else if((acx->preamble == CONF_PREAMBLE_TYPE_N_MIXED_MODE) || (acx->preamble == CONF_PREAMBLE_TYPE_GREENFIELD)){
+        sinfo->txrate.flags = RATE_INFO_FLAGS_MCS;
+    }
 
+	//mcs & legacy handler:
+	if (acx->tx_rate >= CONF_HW_RATE_INDEX_MCS0)
+		sinfo->txrate.mcs = acx->tx_rate - CONF_HW_RATE_INDEX_MCS0;
+	else
+		sinfo->txrate.legacy = cc33xx_idx_to_rate_100Kbps[acx->tx_rate -1];
+
+    sinfo->txrate.nss = 1;
+    sinfo->txrate.bw = RATE_INFO_BW_20;
+    sinfo->txrate.he_gi = NL80211_RATE_INFO_HE_GI_3_2;
+    sinfo->txrate.he_dcm = 0;
+	sinfo->txrate.he_ru_alloc = 0;
+    sinfo->txrate.n_bonded_ch = 0;
+	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);
 out:
 	kfree(acx);
 	return ret;
+
 }
 
 #ifdef CONFIG_PM
@@ -1814,6 +1540,7 @@ int cc33xx_acx_default_rx_filter_enable(struct cc33xx *wl, bool enable,
 
 	acx->enable = enable;
 	acx->default_action = action;
+	acx->special_packet_bitmask = 0;
 
 	ret = cc33xx_cmd_configure(wl, ACX_ENABLE_RX_DATA_FILTER, acx,
 				   sizeof(*acx));
@@ -1879,8 +1606,6 @@ int cc33xx_acx_set_rx_filter(struct cc33xx *wl, u8 index, bool enable,
 }
 #endif /* CONFIG_PM */
 
-
-
 int cc33xx_acx_host_if_cfg_bitmap(struct cc33xx *wl, u32 host_cfg_bitmap,
 				  u32 sdio_blk_size, u32 extra_mem_blks,
 				  u32 len_field_size)
@@ -1916,33 +1641,6 @@ int cc33xx_acx_host_if_cfg_bitmap(struct cc33xx *wl, u32 host_cfg_bitmap,
 	return ret;
 }
 
-int cc33xx_acx_set_checksum_state(struct cc33xx *wl)
-{
-	struct cc33xx_acx_checksum_state *acx;
-	int ret;
-
-	cc33xx_debug(DEBUG_ACX, "acx checksum state");
-
-	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
-	if (!acx) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	acx->checksum_state = CHECKSUM_OFFLOAD_ENABLED;
-
-	ret = cc33xx_cmd_configure(wl, ACX_CSUM_CONFIG, acx, sizeof(*acx));
-	if (ret < 0) {
-		cc33xx_warning("failed to set Tx checksum state: %d", ret);
-		goto out;
-	}
-
-out:
-	kfree(acx);
-	return ret;
-}
-
-
 int cc33xx_acx_peer_ht_operation_mode(struct cc33xx *wl, u8 hlid, bool wide)
 {
 	struct wlcore_peer_ht_operation_mode *acx;
@@ -1982,13 +1680,15 @@ int cc33xx_acx_peer_ht_operation_mode(struct cc33xx *wl, u8 hlid, bool wide)
 int cc33xx_acx_set_peer_cap(struct cc33xx *wl,
 			    struct ieee80211_sta_ht_cap *ht_cap,
 			    struct ieee80211_sta_he_cap *he_cap,
-			    struct cc33xx_vif *wlvif,
-			    bool allow_ht_operation,
+			    struct cc33xx_vif *wlvif, bool allow_ht_operation,
 			    u32 rate_set, u8 hlid)
 {
 	struct wlcore_acx_peer_cap *acx;
 	int ret = 0;
 	u32 ht_capabilites = 0;
+	u8 *cap_info = NULL;
+	u8 dcm_max_const_rx_mask = IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_MASK;
+	u8 partial_bw_ext_range = IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE;
 
 	cc33xx_debug(DEBUG_ACX,
 		     "acx set cap ht_supp: %d ht_cap: %d rates: 0x%x",
@@ -2021,11 +1721,12 @@ int cc33xx_acx_set_peer_cap(struct cc33xx *wl,
 	acx->role_id = wlvif->role_id;
 	acx->has_he = he_cap->has_he;
 	memcpy(acx->mac_cap_info, he_cap->he_cap_elem.mac_cap_info, 6);
-	acx->nominal_packet_padding = (he_cap->he_cap_elem.phy_cap_info[8] & NOMINAL_PACKET_PADDING);
+	cap_info = he_cap->he_cap_elem.phy_cap_info;
+	acx->nominal_packet_padding = (cap_info[8] & NOMINAL_PACKET_PADDING);
 	/* Max DCM constelation for RX - bits [4:3] in PHY capabilities byte 3 */
-	acx->dcm_max_constelation = (he_cap->he_cap_elem.phy_cap_info[3] & IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_MASK) >> 3;
-	acx->er_upper_supported = ((he_cap->he_cap_elem.phy_cap_info[6] & IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE) != 0) ? 1 : 0;
-    ret = cc33xx_cmd_configure(wl, PEER_CAP_CFG, acx, sizeof(*acx));
+	acx->dcm_max_constelation = (cap_info[3] & dcm_max_const_rx_mask) >> 3;
+	acx->er_upper_supported = ((cap_info[6] & partial_bw_ext_range) != 0);
+	ret = cc33xx_cmd_configure(wl, PEER_CAP_CFG, acx, sizeof(*acx));
 
 	if (ret < 0) {
 		cc33xx_warning("acx ht capabilities setting failed: %d", ret);
@@ -2041,8 +1742,7 @@ int cc33xx_acx_set_peer_cap(struct cc33xx *wl,
  * When the host is suspended, we don't want to get any fast-link/PSM
  * notifications
  */
-int cc33xx_acx_interrupt_notify_config(struct cc33xx *wl,
-				       bool action)
+int cc33xx_acx_interrupt_notify_config(struct cc33xx *wl, bool action)
 {
 	struct cc33xx_acx_interrupt_notify *acx;
 	int ret = 0;
@@ -2123,6 +1823,145 @@ int cc33xx_acx_ap_sleep(struct cc33xx *wl)
 	return ret;
 }
 
+int cc33xx_acx_twt_setup(struct cc33xx *wl, u32 min_wake_duration_usec,
+		       u32 min_wake_interval_mantissa, u32 min_wake_interval_exponent,
+			   u32 max_wake_interval_mantissa, u32 max_wake_interval_exponent,
+			   u8 valid_params)
+{
+	struct acx_twt_setup *acx;
+	int ret;
+
+	cc33xx_debug(DEBUG_ACX, "acx config twt setup. valid_params: %d, "
+				"min_wake_duration_usec: %d, min_wake_interval_mantissa: %d, "
+				"min_wake_interval_exponent: %d, max_wake_interval_mantissa: %d, "
+				"max_wake_interval_exponent: %d",
+				valid_params, min_wake_duration_usec,
+				min_wake_interval_mantissa, min_wake_interval_exponent,
+				max_wake_interval_mantissa, max_wake_interval_exponent);
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->min_wake_duration_usec = cpu_to_le32(min_wake_duration_usec);
+	acx->min_wake_interval_mantissa = cpu_to_le32(min_wake_interval_mantissa);
+	acx->min_wake_interval_exponent = cpu_to_le32(min_wake_interval_exponent);
+	acx->max_wake_interval_mantissa = cpu_to_le32(max_wake_interval_mantissa);
+	acx->max_wake_interval_exponent = cpu_to_le32(max_wake_interval_exponent);
+	acx->valid_params = valid_params;
+
+	ret = cc33xx_cmd_configure(wl, TWT_SETUP, acx, sizeof(*acx));
+	if (ret < 0) {
+		cc33xx_warning("acx config twt setup failed: %d", ret);
+		goto out;
+	}
+
+	wl->min_wake_duration_usec = min_wake_duration_usec;
+	wl->min_wake_interval_mantissa = min_wake_interval_mantissa;
+	wl->min_wake_interval_exponent = min_wake_interval_exponent;
+	wl->max_wake_interval_mantissa = max_wake_interval_mantissa;
+	wl->max_wake_interval_exponent = max_wake_interval_exponent;
+out:
+	kfree(acx);
+	return ret;
+}
+
+int cc33xx_acx_twt_terminate(struct cc33xx *wl)
+{
+	struct acx_twt_terminate *acx;
+	int ret;
+
+	cc33xx_debug(DEBUG_ACX, "acx config twt terminate");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = cc33xx_cmd_configure(wl, TWT_TERMINATE, acx, sizeof(*acx));
+	if (ret < 0) {
+		cc33xx_warning("acx config twt terminate failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int cc33xx_acx_twt_suspend(struct cc33xx *wl)
+{
+	struct acx_twt_terminate *acx;
+	int ret;
+
+	cc33xx_debug(DEBUG_ACX, "acx config twt suspend");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = cc33xx_cmd_configure(wl, TWT_SUSPEND, acx, sizeof(*acx));
+	if (ret < 0) {
+		cc33xx_warning("acx config twt suspend failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int cc33xx_acx_twt_resume(struct cc33xx *wl)
+{
+	struct acx_twt_terminate *acx;
+	int ret;
+
+	cc33xx_debug(DEBUG_ACX, "acx config twt resume");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = cc33xx_cmd_configure(wl, TWT_RESUME, acx, sizeof(*acx));
+	if (ret < 0) {
+		cc33xx_warning("acx config twt resume failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//Bashar
 int cc33xx_acx_set_antenna_select(struct cc33xx *wl, u8 selection)
 {
 	struct acx_antenna_select *acx;
@@ -2138,7 +1977,8 @@ int cc33xx_acx_set_antenna_select(struct cc33xx *wl, u8 selection)
 
 	acx->selection = selection;
 
-	ret = cc33xx_cmd_configure(wl, SET_ANTENNA_SELECT_CFG, acx, sizeof(*acx));
+	ret = cc33xx_cmd_configure(wl, SET_ANTENNA_SELECT_CFG,
+				   acx, sizeof(*acx));
 	if (ret < 0) {
 		cc33xx_warning("acx setting antenna failed: %d", ret);
 		goto out;
@@ -2204,7 +2044,8 @@ int cc33xx_acx_burst_mode_cfg(struct cc33xx *wl, u8 burst_disable)
 	struct debug_burst_mode_cfg *burst_mode_cfg;
 	int ret;
 
-	cc33xx_debug(DEBUG_ACX, "acx burst mode cfg. burst_disable = %d", burst_disable);
+	cc33xx_debug(DEBUG_ACX, "acx burst mode cfg. burst_disable = %d",
+		     burst_disable);
 
 	burst_mode_cfg = kzalloc(sizeof(*burst_mode_cfg), GFP_KERNEL);
 	if (!burst_mode_cfg) {
@@ -2214,7 +2055,8 @@ int cc33xx_acx_burst_mode_cfg(struct cc33xx *wl, u8 burst_disable)
 
 	burst_mode_cfg->burst_disable = burst_disable;
 
-	ret = cc33xx_cmd_debug(wl, BURST_MODE_CFG, burst_mode_cfg, sizeof(*burst_mode_cfg));
+	ret = cc33xx_cmd_debug(wl, BURST_MODE_CFG, burst_mode_cfg,
+			       sizeof(*burst_mode_cfg));
 	if (ret < 0) {
 		cc33xx_warning("acx burst mode cfg failed: %d", ret);
 		goto out;
@@ -2224,3 +2066,84 @@ int cc33xx_acx_burst_mode_cfg(struct cc33xx *wl, u8 burst_disable)
 	kfree(burst_mode_cfg);
 	return ret;
 }
+
+int cc33xx_acx_antenna_diversity_enable(struct cc33xx *wl, u8 diversity_enable)
+{
+	struct acx_antenna_diversity_enable *antenna_diversity_enable;
+	int ret;
+
+	cc33xx_debug(DEBUG_ACX, "acx antenna diversity enable. diversity_enable = %d", diversity_enable);
+
+	antenna_diversity_enable = kzalloc(sizeof(*antenna_diversity_enable), GFP_KERNEL);
+	if (!antenna_diversity_enable) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	antenna_diversity_enable->diversity_enable = diversity_enable;
+
+	ret = cc33xx_cmd_configure(wl, ANT_DIV_ENABLE, antenna_diversity_enable,
+							sizeof(*antenna_diversity_enable));
+	if (ret < 0) {
+		cc33xx_warning("acx antenna diversity enable failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(antenna_diversity_enable);
+	return ret;
+}
+
+int cc33xx_acx_antenna_diversity_set_rssi_threshold(struct cc33xx *wl, s8 rssi_threshold)
+{
+	struct acx_antenna_diversity_rssi_threshold *set_rssi_threshold_cmd;
+	int ret;
+
+	cc33xx_debug(DEBUG_ACX, "acx antenna diversity set rssi threshold to %d",
+					rssi_threshold);
+
+	set_rssi_threshold_cmd = kzalloc(sizeof(*set_rssi_threshold_cmd), GFP_KERNEL);
+	if (!set_rssi_threshold_cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	set_rssi_threshold_cmd->rssi_threshold = rssi_threshold;
+
+	ret = cc33xx_cmd_configure(wl, ANT_DIV_SET_RSSI_THRESHOLD, set_rssi_threshold_cmd,
+					sizeof(*set_rssi_threshold_cmd));
+	if (ret < 0) {
+		cc33xx_warning("acx antenna diversity set rssi threshold failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(set_rssi_threshold_cmd);
+	return ret;
+}
+
+int cc33xx_acx_antenna_diversity_select_default_antenna(struct cc33xx *wl, u8 default_antenna)
+{
+	struct acx_antenna_diversity_select_default_antenna *select_default_antenna_cmd;
+	int ret;
+
+	cc33xx_debug(DEBUG_ACX, "acx antenna diversity select default antenna. default_antenna = %d", default_antenna);
+
+	select_default_antenna_cmd = kzalloc(sizeof(*select_default_antenna_cmd), GFP_KERNEL);
+	if (!select_default_antenna_cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	select_default_antenna_cmd->default_antenna = default_antenna;
+
+	ret = cc33xx_cmd_configure(wl, ANT_DIV_SELECT_DEFAULT_ANTENNA, select_default_antenna_cmd, sizeof(*select_default_antenna_cmd));
+	if (ret < 0) {
+		cc33xx_warning("acx antenna diversity select default antenna failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(select_default_antenna_cmd);
+	return ret;
+}
diff --git a/drivers/net/wireless/ti/cc33xx/acx.h b/drivers/net/wireless/ti/cc33xx/acx.h
index db3f3f6645ea..2a7e58fef8e0 100644
--- a/drivers/net/wireless/ti/cc33xx/acx.h
+++ b/drivers/net/wireless/ti/cc33xx/acx.h
@@ -11,45 +11,9 @@
 #ifndef __ACX_H__
 #define __ACX_H__
 
-
-#include "wlcore.h"
 #include "cmd.h"
+#include "debug.h"
 
-/*************************************************************************
-
-    Host Interrupt Register (WiLink -> Host)
-
-**************************************************************************/
-/* HW Initiated interrupt Watchdog timer expiration */
-#define CC33XX_ACX_INTR_WATCHDOG           BIT(0)
-/* Init sequence is done (masked interrupt, detection through polling only ) */
-#define CC33XX_ACX_INTR_INIT_COMPLETE      BIT(1)
-/* Event was entered to Event MBOX #A*/
-#define CC33XX_ACX_INTR_EVENT_A            BIT(2)
-/* Event was entered to Event MBOX #B*/
-#define CC33XX_ACX_INTR_EVENT_B            BIT(3)
-/* Command processing completion*/
-#define CC33XX_ACX_INTR_CMD_COMPLETE       BIT(4)
-/* Signaling the host on HW wakeup */
-#define CC33XX_ACX_INTR_HW_AVAILABLE       BIT(5)
-/* The MISC bit is used for aggregation of RX, TxComplete and TX rate update */
-#define CC33XX_ACX_INTR_DATA               BIT(6)
-/* Trace message on MBOX #A */
-#define CC33XX_ACX_INTR_TRACE_A            BIT(7)
-/* Trace message on MBOX #B */
-#define CC33XX_ACX_INTR_TRACE_B            BIT(8)
-/* SW FW Initiated interrupt Watchdog timer expiration */
-#define CC33XX_ACX_SW_INTR_WATCHDOG        BIT(9)
-
-#define CC33XX_ACX_INTR_ALL             0xFFFFFFFF
-
-/* all possible interrupts - only appropriate ones will be masked in */
-#define WLCORE_ALL_INTR_MASK		(CC33XX_ACX_INTR_WATCHDOG     | \
-					CC33XX_ACX_INTR_EVENT_A       | \
-					CC33XX_ACX_INTR_EVENT_B       | \
-					CC33XX_ACX_INTR_HW_AVAILABLE  | \
-					CC33XX_ACX_INTR_DATA          | \
-					CC33XX_ACX_SW_INTR_WATCHDOG)
 
 enum {
 	/* Regular PS: simple sending of packets */
@@ -72,7 +36,6 @@ enum {
 	MAX_PS_SCHEME = PS_SCHEME_NOPSPOLL
 };
 
-
 /* Target's information element */
 struct acx_header {
 	struct cc33xx_cmd_header cmd;
@@ -94,29 +57,6 @@ struct debug_header {
 	__le16 len;
 } __packed;
 
-struct acx_error_counter {
-	struct acx_header header;
-
-	/* The number of PLCP errors since the last time this */
-	/* information element was interrogated. This field is */
-	/* automatically cleared when it is interrogated.*/
-	__le32 PLCP_error;
-
-	/* The number of FCS errors since the last time this */
-	/* information element was interrogated. This field is */
-	/* automatically cleared when it is interrogated.*/
-	__le32 FCS_error;
-
-	/* The number of MPDUs without PLCP header errors received*/
-	/* since the last time this information element was interrogated. */
-	/* This field is automatically cleared when it is interrogated.*/
-	__le32 valid_frame;
-
-	/* the number of missed sequence numbers in the squentially */
-	/* values of frames seq numbers */
-	__le32 seq_num_miss;
-} __packed;
-
 enum cc33xx_role {
 	CC33XX_ROLE_STA = 0,
 	CC33XX_ROLE_IBSS,
@@ -158,43 +98,6 @@ struct acx_sleep_auth {
 	u8  padding[3];
 } __packed;
 
-enum {
-	HOSTIF_PCI_MASTER_HOST_INDIRECT,
-	HOSTIF_PCI_MASTER_HOST_DIRECT,
-	HOSTIF_SLAVE,
-	HOSTIF_PKT_RING,
-	HOSTIF_DONTCARE = 0xFF
-};
-
-#define DEFAULT_UCAST_PRIORITY          0
-#define DEFAULT_RX_Q_PRIORITY           0
-#define DEFAULT_RXQ_PRIORITY            0 /* low 0 .. 15 high  */
-#define DEFAULT_RXQ_TYPE                0x07    /* All frames, Data/Ctrl/Mgmt */
-#define TRACE_BUFFER_MAX_SIZE           256
-
-#define  DP_RX_PACKET_RING_CHUNK_SIZE 1600
-#define  DP_TX_PACKET_RING_CHUNK_SIZE 1600
-#define  DP_RX_PACKET_RING_CHUNK_NUM 2
-#define  DP_TX_PACKET_RING_CHUNK_NUM 2
-#define  DP_TX_COMPLETE_TIME_OUT 20
-
-#define TX_MSDU_LIFETIME_MIN       0
-#define TX_MSDU_LIFETIME_MAX       3000
-#define TX_MSDU_LIFETIME_DEF       512
-#define RX_MSDU_LIFETIME_MIN       0
-#define RX_MSDU_LIFETIME_MAX       0xFFFFFFFF
-#define RX_MSDU_LIFETIME_DEF       512000
-
-struct acx_rx_msdu_lifetime {
-	struct acx_header header;
-
-	/*
-	 * The maximum amount of time, in TU, before the
-	 * firmware discards the MSDU.
-	 */
-	__le32 lifetime;
-} __packed;
-
 enum acx_slot_type {
 	SLOT_TIME_LONG = 0,
 	SLOT_TIME_SHORT = 1,
@@ -202,8 +105,6 @@ enum acx_slot_type {
 	MAX_SLOT_TIMES = 0xFF
 };
 
-#define STATION_WONE_INDEX 0
-
 struct acx_slot {
 	struct acx_header header;
 
@@ -212,7 +113,6 @@ struct acx_slot {
 	u8 reserved[2];
 } __packed;
 
-
 #define ACX_MC_ADDRESS_GROUP_MAX	(20)
 #define ADDRESS_GROUP_MAX_LEN		(ETH_ALEN * ACX_MC_ADDRESS_GROUP_MAX)
 
@@ -283,14 +183,19 @@ struct acx_beacon_filter_option {
  * with each appearance or disappearance.
  * Note that both bits can be set at the same time.
  */
-#define	BEACON_FILTER_TABLE_MAX_IE_NUM		       (32)
-#define BEACON_FILTER_TABLE_MAX_VENDOR_SPECIFIC_IE_NUM (6)
-#define BEACON_FILTER_TABLE_IE_ENTRY_SIZE	       (2)
-#define BEACON_FILTER_TABLE_EXTRA_VENDOR_SPECIFIC_IE_SIZE (6)
-#define BEACON_FILTER_TABLE_MAX_SIZE ((BEACON_FILTER_TABLE_MAX_IE_NUM * \
-			    BEACON_FILTER_TABLE_IE_ENTRY_SIZE) + \
-			   (BEACON_FILTER_TABLE_MAX_VENDOR_SPECIFIC_IE_NUM * \
-			    BEACON_FILTER_TABLE_EXTRA_VENDOR_SPECIFIC_IE_SIZE))
+
+enum {
+	BEACON_FILTER_TABLE_MAX_IE_NUM				= 32,
+	BEACON_FILTER_TABLE_MAX_VENDOR_SPECIFIC_IE_NUM		= 6,
+	BEACON_FILTER_TABLE_IE_ENTRY_SIZE			= 2,
+	BEACON_FILTER_TABLE_EXTRA_VENDOR_SPECIFIC_IE_SIZE	= 6
+};
+
+#define BEACON_FILTER_TABLE_MAX_SIZE					\
+		((BEACON_FILTER_TABLE_MAX_IE_NUM *			\
+		BEACON_FILTER_TABLE_IE_ENTRY_SIZE) +			\
+		(BEACON_FILTER_TABLE_MAX_VENDOR_SPECIFIC_IE_NUM *	\
+		BEACON_FILTER_TABLE_EXTRA_VENDOR_SPECIFIC_IE_SIZE))
 
 struct acx_beacon_filter_ie_table {
 	struct acx_header header;
@@ -310,22 +215,6 @@ struct acx_conn_monit_params {
        __le32 bss_lose_timeout; /* number of TU's from synch fail */
 } __packed;
 
-struct acx_bt_wlan_coex {
-	struct acx_header header;
-
-	u8 enable;
-	u8 pad[3];
-} __packed;
-
-
-struct acx_dco_itrim_params {
-	struct acx_header header;
-
-	u8 enable;
-	u8 padding[3];
-	__le32 timeout;
-} __packed;
-
 struct acx_energy_detection {
 	struct acx_header header;
 
@@ -357,15 +246,6 @@ struct acx_event_mask {
 	__le32 high_event_mask; /* Unused */
 } __packed;
 
-#define SCAN_PASSIVE		BIT(0)
-#define SCAN_5GHZ_BAND		BIT(1)
-#define SCAN_TRIGGERED		BIT(2)
-#define SCAN_PRIORITY_HIGH	BIT(3)
-
-/* When set, disable HW encryption */
-#define DF_ENCRYPTION_DISABLE      0x01
-#define DF_SNIFF_MODE_ENABLE       0x80
-
 struct acx_feature_config {
 	struct acx_header header;
 
@@ -391,7 +271,6 @@ struct acx_wake_up_condition {
 	u8 padding[2];
 } __packed;
 
-
 struct assoc_info_cfg
 {
 	struct acx_header header;
@@ -406,22 +285,8 @@ struct assoc_info_cfg
 	u8 ht_supported;
 	u8 vht_supported;
 	u8 has_he;
-	//u8 padding[3]; incase total size of the struct variables isnt a multiple of 32 bit then add padding
 }__packed;
 
-
-struct acx_aid {
-	struct acx_header header;
-
-	/*
-	 * To be set when associated with an AP.
-	 *
-	 */
-	u8 role_id;
-	u8 reserved;
-	__le16 aid;
-} __packed;
-
 enum acx_preamble_type {
 	ACX_PREAMBLE_LONG = 0,
 	ACX_PREAMBLE_SHORT = 1
@@ -451,14 +316,6 @@ struct acx_ctsprotect {
 	u8 padding[2];
 } __packed;
 
-struct acx_rate_class {
-	__le32 enabled_rates;
-	u8 short_retry_limit;
-	u8 long_retry_limit;
-	u8 aflags;
-	u8 reserved;
-};
-
 struct ap_rates_class_cfg {
 
 	struct acx_header header;
@@ -468,13 +325,6 @@ struct ap_rates_class_cfg {
     u8 padding[3];
 }__packed;
 
-struct acx_rate_policy {
-	struct acx_header header;
-
-	__le32 rate_policy_idx;
-	struct acx_rate_class rate_policy;
-} __packed;
-
 struct tx_param_cfg {
     struct acx_header header;
 
@@ -499,41 +349,12 @@ struct tx_param_cfg {
 
 } __packed;
 
-struct acx_ac_cfg {
-	struct acx_header header;
-	u8 role_id;
-	u8 ac;
-	u8 aifsn;
-	u8 cw_min;
-	__le16 cw_max;
-	__le16 tx_op_limit;
-	u8 ps_scheme;
-} __packed;
-
-struct acx_tid_config {
-	struct acx_header header;
-	u8 role_id;
-	u8 queue_id;
-	u8 channel_type;
-	u8 tsid;
-	u8 ps_scheme;
-	u8 ack_policy;
-	u8 padding[2];
-	__le32 apsd_conf[2];
-} __packed;
-
 struct acx_frag_threshold {
 	struct acx_header header;
 	__le16 frag_threshold;
 	u8 padding[2];
 } __packed;
 
-struct acx_tx_config_options {
-	struct acx_header header;
-	__le16 tx_compl_timeout;     /* msec */
-	__le16 tx_compl_threshold;   /* number of packets */
-} __packed;
-
 struct cc33xx_acx_config_memory {
 	struct acx_header header;
 
@@ -550,7 +371,7 @@ struct cc33xx_acx_config_memory {
 	u8 padding[3];
 } __packed;
 
-struct cc33xx_acx_mem_map {
+struct cc33xx_acx_mem_map_t {
 	struct acx_header header;
 
 	/* Number of blocks FW allocated for TX packets */
@@ -588,7 +409,6 @@ struct cc33xx_acx_rx_config_opt {
 	u8 reserved;
 } __packed;
 
-
 struct cc33xx_acx_bet_enable {
 	struct acx_header header;
 
@@ -599,7 +419,6 @@ struct cc33xx_acx_bet_enable {
 } __packed;
 
 #define ACX_IPV4_VERSION 4
-#define ACX_IPV6_VERSION 6
 #define ACX_IPV4_ADDR_SIZE 4
 
 /* bitmap of enabled arp_filter features */
@@ -618,20 +437,14 @@ struct cc33xx_acx_arp_filter {
 			       used. */
 } __packed;
 
-struct cc33xx_acx_pm_config {
-	struct acx_header header;
-
-	__le32 host_clk_settling_time;
-	u8 host_fast_wakeup_support;
-	u8 padding[3];
-} __packed;
-
 /* TODO: maybe this needs to be moved somewhere else? */
-#define HOST_IF_CFG_RX_FIFO_ENABLE     BIT(0)
-#define HOST_IF_CFG_TX_EXTRA_BLKS_SWAP BIT(1)
-#define HOST_IF_CFG_TX_PAD_TO_SDIO_BLK BIT(3)
-#define HOST_IF_CFG_RX_PAD_TO_SDIO_BLK BIT(4)
-#define HOST_IF_CFG_ADD_RX_ALIGNMENT   BIT(6)
+enum {
+	HOST_IF_CFG_RX_FIFO_ENABLE	= BIT(0),
+	HOST_IF_CFG_TX_EXTRA_BLKS_SWAP	= BIT(1),
+	HOST_IF_CFG_TX_PAD_TO_SDIO_BLK	= BIT(3),
+	HOST_IF_CFG_RX_PAD_TO_SDIO_BLK	= BIT(4),
+	HOST_IF_CFG_ADD_RX_ALIGNMENT	= BIT(6)
+};
 
 enum {
 	CC33XX_ACX_TRIG_TYPE_LEVEL = 0,
@@ -676,7 +489,7 @@ struct cc33xx_acx_rssi_snr_trigger {
 	u8 padding[1];
 };
 
-struct cc33xx_acx_rssi_snr_avg_weights {
+struct cc33xx_acx_rssi_snr_avg_weights_t {
 	struct acx_header header;
 
 	u8 role_id;
@@ -687,7 +500,6 @@ struct cc33xx_acx_rssi_snr_avg_weights {
 	u8 snr_data;
 };
 
-
 /* special capability bit (not employed by the 802.11n spec) */
 #define CC33XX_HT_CAP_HT_OPERATION BIT(16)
 
@@ -745,7 +557,6 @@ struct cc33xx_acx_ht_information {
 	u8 dual_cts_protection;
 
 	__le32 he_operation;
-	//u8 bss_color_info;
 
 	__le16 bss_basic_mcs_set;
 	u8 qos_info_more_data_ack_bit;
@@ -817,12 +628,6 @@ struct calibration_file_header {
 	__le16 entries_count;
 } __packed;
 
-
-
-
-
-
-
 struct cc33xx_acx_static_calibration_cfg {
 
 	struct acx_header header;
@@ -895,46 +700,6 @@ struct cc33xx_acx_inconnection_sta {
 } __packed;
 
 #define ACX_RATE_MGMT_ALL_PARAMS 0xff
-struct cc33xx_acx_set_rate_mgmt_params {
-	struct acx_header header;
-
-	u8 index; /* 0xff to configure all params */
-	u8 padding1;
-	__le16 rate_retry_score;
-	__le16 per_add;
-	__le16 per_th1;
-	__le16 per_th2;
-	__le16 max_per;
-	u8 inverse_curiosity_factor;
-	u8 tx_fail_low_th;
-	u8 tx_fail_high_th;
-	u8 per_alpha_shift;
-	u8 per_add_shift;
-	u8 per_beta1_shift;
-	u8 per_beta2_shift;
-	u8 rate_check_up;
-	u8 rate_check_down;
-	u8 rate_retry_policy[ACX_RATE_MGMT_NUM_OF_RATES];
-	u8 padding2[2];
-} __packed;
-
-struct cc33xx_acx_config_hangover {
-	struct acx_header header;
-
-	__le32 recover_time;
-	u8 hangover_period;
-	u8 dynamic_mode;
-	u8 early_termination_mode;
-	u8 max_period;
-	u8 min_period;
-	u8 increase_delta;
-	u8 decrease_delta;
-	u8 quiet_time;
-	u8 increase_time;
-	u8 window_size;
-	u8 padding[2];
-} __packed;
-
 
 struct acx_default_rx_filter {
 	struct acx_header header;
@@ -943,9 +708,11 @@ struct acx_default_rx_filter {
 	/* action of type FILTER_XXX */
 	u8 default_action;
 
-	u8 pad[2];
-} __packed;
+	/* special packet bitmask - packet that use for trigger the host */
+	u8 special_packet_bitmask;
 
+	u8 padding;
+} __packed;
 
 struct acx_rx_filter_cfg {
 	struct acx_header header;
@@ -974,25 +741,40 @@ struct acx_roaming_stats {
 } __packed;
 
 typedef enum {
-	CTS_PROTECTION_CFG = 0,
-	TX_PARAMS_CFG = 1,
-	ASSOC_INFO_CFG = 2,
-	PEER_CAP_CFG = 3,
-	BSS_OPERATION_CFG = 4,
-	SLOT_CFG = 5,
-	PREAMBLE_TYPE_CFG = 6,
-	DOT11_GROUP_ADDRESS_TBL = 7,
-	BA_SESSION_RX_SETUP_CFG = 8,
-	ACX_SLEEP_AUTH = 9,
-	STATIC_CALIBRATION_CFG = 10,
-	AP_RATES_CFG = 11,
-	WAKE_UP_CONDITIONS_CFG = 12,
-	SET_ANTENNA_SELECT_CFG = 13,
-	TX_POWER_CFG = 14,
-	LAST_CFG_VALUE,
-	MAX_DOT11_CFG = LAST_CFG_VALUE,
-
-	MAX_CFG = 0xFFFF /*force enumeration to 16bits*/
+	CTS_PROTECTION_CFG				= 0,
+	TX_PARAMS_CFG					= 1,
+	ASSOC_INFO_CFG					= 2,
+	PEER_CAP_CFG					= 3,
+	BSS_OPERATION_CFG				= 4,
+	SLOT_CFG						= 5,
+	PREAMBLE_TYPE_CFG				= 6,
+	DOT11_GROUP_ADDRESS_TBL			= 7,
+	BA_SESSION_RX_SETUP_CFG			= 8,
+	ACX_SLEEP_AUTH					= 9,
+	STATIC_CALIBRATION_CFG			= 10,
+	AP_RATES_CFG					= 11,
+	WAKE_UP_CONDITIONS_CFG			= 12,
+	SET_ANTENNA_SELECT_CFG			= 13,
+	TX_POWER_CFG					= 14,
+	VENDOR_IE_CFG					= 15,
+	START_COEX_STATISTICS_CFG		= 16,
+	BEACON_FILTER_OPT				= 17,
+	BEACON_FILTER_TABLE				= 18,
+	ACX_ENABLE_RX_DATA_FILTER		= 19,
+	ACX_SET_RX_DATA_FILTER			= 20,
+	ACX_GET_DATA_FILTER_STATISTICS	= 21,
+    TWT_SETUP                	    = 22,
+    TWT_TERMINATE            	    = 23,
+    TWT_SUSPEND           	   	    = 24,
+    TWT_RESUME              	    = 25,
+	ANT_DIV_ENABLE 					= 26,
+	ANT_DIV_SET_RSSI_THRESHOLD 		= 27,
+	ANT_DIV_SELECT_DEFAULT_ANTENNA 	= 28,
+
+	LAST_CFG_VALUE			,
+	MAX_DOT11_CFG = LAST_CFG_VALUE	,
+
+	MAX_CFG = 0xFFFF	/*force enumeration to 16bits*/
 } Cfg_e;
 
 typedef enum {
@@ -1013,7 +795,7 @@ typedef enum {
 	RTS_TH_CFG,
 	LINK_ADAPT_CFG,
 	CALIB_BITMAP_CFG,
-    PWR_PARTIAL_MODES_CFG,
+	PWR_PARTIAL_MODES_CFG,
 	TRIGGER_FW_ASSERT,
 	BURST_MODE_CFG,
 
@@ -1023,18 +805,14 @@ typedef enum {
 
 } cmdDebug_e;
 
-typedef enum {
-	BEACON_RSSI_INTR,
-	LAST_DEBUG_READ_VALUE,
-
-	MAX_DEBUG_READ = 0xFFFF /*force enumeration to 16bits*/
-} cmdDebugRead_e;
-
 typedef enum {
 	MEM_MAP_INTR = 0,
 	GET_FW_VERSIONS_INTR = 1,
 	RSSI_INTR = 2,
 	GET_ANTENNA_SELECT_INTR = 3,
+	GET_PREAMBLE_AND_TX_RATE_INTR = 4,
+	GET_MAC_ADDRESS = 5,
+	READ_COEX_STATISTICS = 6,
 	LAST_IE_VALUE,
 	MAX_DOT11_IE = LAST_IE_VALUE,
 
@@ -1077,9 +855,6 @@ enum {
 	ACX_SERVICE_PERIOD_TIMEOUT       ,
 	ACX_TSF_INFO                     ,
 	ACX_CONFIG_PS_WMM                ,
-	ACX_ENABLE_RX_DATA_FILTER        ,
-	ACX_SET_RX_DATA_FILTER           ,
-	ACX_GET_DATA_FILTER_STATISTICS   ,
 	ACX_RX_CONFIG_OPT                ,
 	ACX_FRAG_CFG                     ,
 	ACX_BET_ENABLE                   ,
@@ -1110,8 +885,6 @@ enum {
 	ACX_PROTECTION_CFG               ,
 };
 
-
-
 enum {
 	ACX_NS_IPV6_FILTER		 = 0x0050,
 	ACX_PEER_HT_OPERATION_MODE_CFG	 = 0x0051,
@@ -1136,31 +909,9 @@ struct acx_dynamic_fw_traces_cfg {
 	__le32 dynamic_fw_traces;
 } __packed;
 
-struct cc33xx_acx_clear_statistics {
-	struct acx_header header;
-};
-
-
-
 /* numbers of bits the length field takes (add 1 for the actual number) */
 #define CC33XX_HOST_IF_LEN_SIZE_FIELD 15
 
-#define CC33XX_ACX_EVENTS_VECTOR	(CC33XX1_ACX_INTR_WATCHDOG	| \
-					 CC33XX_ACX_INTR_INIT_COMPLETE	| \
-					 CC33XX_ACX_INTR_EVENT_A	| \
-					 CC33XX_ACX_INTR_EVENT_B	| \
-					 CC33XX_ACX_INTR_CMD_COMPLETE	| \
-					 CC33XX_ACX_INTR_HW_AVAILABLE	| \
-					 CC33XX_ACX_INTR_DATA		| \
-					 CC33XX_ACX_SW_INTR_WATCHDOG)
-
-#define CC33XX_INTR_MASK		(CC33XX_ACX_INTR_WATCHDOG	| \
-					 CC33XX_ACX_INTR_EVENT_A	| \
-					 CC33XX_ACX_INTR_EVENT_B	| \
-					 CC33XX_ACX_INTR_HW_AVAILABLE	| \
-					 CC33XX_ACX_INTR_DATA		| \
-					 CC33XX_ACX_SW_INTR_WATCHDOG)
-
 struct cc33xx_acx_host_config_bitmap {
 	struct acx_header header;
 
@@ -1179,22 +930,6 @@ struct cc33xx_acx_host_config_bitmap {
 
 } __packed;
 
-enum {
-	CHECKSUM_OFFLOAD_DISABLED = 0,
-	CHECKSUM_OFFLOAD_ENABLED  = 1,
-	CHECKSUM_OFFLOAD_FAKE_RX  = 2,
-	CHECKSUM_OFFLOAD_INVALID  = 0xFF
-};
-
-struct cc33xx_acx_checksum_state {
-	struct acx_header header;
-
-	 /* enum acx_checksum_state */
-	u8 checksum_state;
-	u8 pad[3];
-} __packed;
-
-
 struct cc33xx_acx_error_stats {
 	__le32 error_frame_non_ctrl;
 	__le32 error_frame_ctrl;
@@ -1379,7 +1114,7 @@ struct cc33xx_dfs_stats {
 	__le32 num_of_radar_detections;
 } __packed;
 
-struct cc33xx_acx_statistics {
+struct cc33xx_acx_statistics_t {
 	struct acx_header header;
 
 	struct cc33xx_acx_error_stats		error;
@@ -1411,7 +1146,6 @@ struct wlcore_peer_ht_operation_mode {
 	u8 padding[2];
 };
 
-
 /*
  * ACX_PEER_CAP
  * this struct is very similar to cc33xx_acx_ht_capabilities, with the
@@ -1419,40 +1153,38 @@ struct wlcore_peer_ht_operation_mode {
  */
 #define NOMINAL_PACKET_PADDING (0xC0)
 struct wlcore_acx_peer_cap {
-    struct acx_header header;
+	struct acx_header header;
 
-    u8 role_id;
+	u8 role_id;
 
-    /* rates supported by the remote peer */
-    __le32 supported_rates;
+	/* rates supported by the remote peer */
+	__le32 supported_rates;
 
-    /* bitmask of capability bits supported by the peer */
-    __le32 ht_capabilites;
-    /*
-     * This the maximum A-MPDU length supported by the AP. The FW may not
-     * exceed this length when sending A-MPDUs
-     */
-    u8 ampdu_max_length;
+	/* bitmask of capability bits supported by the peer */
+	__le32 ht_capabilites;
+	/*
+	* This the maximum A-MPDU length supported by the AP. The FW may not
+	* exceed this length when sending A-MPDUs
+	*/
+	u8 ampdu_max_length;
 
-    /* This is the minimal spacing required when sending A-MPDUs to the AP*/
-    u8 ampdu_min_spacing;
+	/* This is the minimal spacing required when sending A-MPDUs to the AP*/
+	u8 ampdu_min_spacing;
 
-    /* HE capabilities */
-    u8 mac_cap_info[8];
+	/* HE capabilities */
+	u8 mac_cap_info[8];
 
-    /* Nominal packet padding value, used for determining the packet extension duration */
-    u8 nominal_packet_padding;
+	/* Nominal packet padding value, used for determining the packet extension duration */
+	u8 nominal_packet_padding;
 
-    /* HE peer support */
-    bool has_he;
+	/* HE peer support */
+	bool has_he;
 
-    /* */
 	u8 dcm_max_constelation;
 
-	/* */
 	u8 er_upper_supported;
 
-    u8 paddin[1];
+	u8 paddin[1];
 } __packed;
 
 /*
@@ -1509,7 +1241,104 @@ struct debug_set_tsf {
 struct debug_burst_mode_cfg {
 	struct debug_header header;
 
-    u8 burst_disable;
+	u8 burst_disable;
+	u8 padding[3];
+} __packed;
+struct acx_twt_setup {
+	struct acx_header header;
+	__le32 min_wake_duration_usec;
+	__le32 min_wake_interval_mantissa;
+	__le32 min_wake_interval_exponent;
+	__le32 max_wake_interval_mantissa;
+	__le32 max_wake_interval_exponent;
+	u8 valid_params;
+	u8 padding [3];
+} __packed;
+
+#define MIN_WAKE_DURATION_VALID				BIT(0)
+#define MIN_WAKE_INTERVAL_MANTISSA_VALID	BIT(1)
+#define MIN_WAKE_INTERVAL_EXPONENT_VALID	BIT(2)
+#define MAX_WAKE_INTERVAL_MANTISSA_VALID	BIT(3)
+#define MAX_WAKE_INTERVAL_EXPONENT_VALID	BIT(4)
+
+struct acx_twt_terminate {
+	struct acx_header header;
+} __packed;
+
+struct acx_preamble_and_tx_rate {
+	struct acx_header header;
+	u16 tx_rate;
+	u8 preamble;
+	u8 role_id;
+} __packed;
+
+static const u16 cc33xx_idx_to_rate_100Kbps[] =
+{
+    10, 20, 55, 110, 60, 90, 120, 180, 240, 360, 480, 540
+};
+
+struct cc33xx_coex_statistics {
+	__le32 wifi_request_assertion_log;
+	__le32 wifi_request_de_assertion_log;
+	__le32 wifi_grant_assertion_log;
+	__le32 wifi_grant_deassertion_log;
+	__le32 wifi_prio_reject_log;
+	__le32 wifi_grant_during_dual_ant_assertion_log;
+	__le32 wifi_grant_during_dual_ant_deassertion_log;
+	__le32 ble_request_assertion_log;
+	__le32 ble_request_deassertion_log;
+	__le32 ble_grant_assertion_log;
+	__le32 ble_grant_deassertion_log;
+	__le32 ble_tx_high_prio_reject_log;
+	__le32 ble_tx_low_prio_reject_log;
+	__le32 ble_rx_high_prio_reject_log;
+	__le32 ble_rx_low_prio_reject_log;
+	__le32 soc_request_assertion_log;
+	__le32 soc_request_deassertion_log;
+	__le32 soc_grant_assertion_log;
+	__le32 soc_grant_deassertion_log;
+	__le32 soc_high_prio_reject_log;
+	__le32 soc_low_prio_reject_log;
+} __packed;
+
+struct cc33xx_coex_stat_and_entities {
+	__u8 coex_entities_bitmap;
+	__u8 padding[3];
+	struct cc33xx_coex_statistics coex_statistics;
+} __packed;
+
+
+struct cc33xx_acx_coex_statistics {
+	struct acx_header header;
+
+	struct cc33xx_coex_stat_and_entities coex_stat;
+} __packed;
+
+struct cc33xx_acx_coex_statistics_cfg {
+	struct acx_header header;
+
+	__u8 coex_statictics;
+	__u8 padding[3];
+} __packed;
+
+struct acx_antenna_diversity_enable {
+	struct acx_header header;
+
+    u8 diversity_enable;
+	u8 padding[3];
+} __packed;
+
+struct acx_antenna_diversity_rssi_threshold {
+	struct acx_header header;
+
+    s8 rssi_threshold;
+	u8 padding[3];
+} __packed;
+
+struct acx_antenna_diversity_select_default_antenna {
+	struct acx_header header;
+
+    u8 default_antenna;
 	u8 padding[3];
 } __packed;
 
@@ -1519,12 +1348,8 @@ int cc33xx_acx_wake_up_conditions(struct cc33xx *wl,
 				  u8 wake_up_event, u8 listen_interval);
 int cc33xx_acx_sleep_auth(struct cc33xx *wl, u8 sleep_auth);
 int cc33xx_ble_enable(struct cc33xx *wl, u8 ble_enable);
-int cc33xx_acx_tx_power(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			int power);
+int cc33xx_acx_tx_power(struct cc33xx *wl, struct cc33xx_vif *wlvif, int power);
 int cc33xx_acx_feature_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif);
-int cc33xx_acx_mem_map(struct cc33xx *wl,
-		       struct acx_header *mem_map, size_t len);
-int cc33xx_acx_rx_msdu_life_time(struct cc33xx *wl);
 int cc33xx_acx_slot(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 		    enum acx_slot_type slot_time);
 int cc33xx_acx_group_address_tbl(struct cc33xx *wl, struct cc33xx_vif *wlvif,
@@ -1533,106 +1358,96 @@ int cc33xx_acx_service_period_timeout(struct cc33xx *wl,
 				      struct cc33xx_vif *wlvif);
 int cc33xx_acx_rts_threshold(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			     u32 rts_threshold);
-int cc33xx_acx_dco_itrim_params(struct cc33xx *wl);
 int cc33xx_acx_beacon_filter_opt(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				 bool enable_filter);
-int cc33xx_acx_beacon_filter_table(struct cc33xx *wl,
-				   struct cc33xx_vif *wlvif);
+int cc33xx_acx_beacon_filter_table(struct cc33xx *wl, struct cc33xx_vif *wlvif);
 int cc33xx_acx_conn_monit_params(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				 bool enable);
-int cc33xx_acx_cca_threshold(struct cc33xx *wl);
 int cc33xx_acx_bcn_dtim_options(struct cc33xx *wl, struct cc33xx_vif *wlvif);
-int cc33xx_assoc_info_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif, struct ieee80211_sta *sta,u16 aid);
-int cc33xx_acx_aid(struct cc33xx *wl, struct cc33xx_vif *wlvif, u16 aid);
+int cc33xx_assoc_info_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+			  struct ieee80211_sta *sta,u16 aid);
 int cc33xx_acx_event_mbox_mask(struct cc33xx *wl, u32 event_mask);
 int cc33xx_acx_set_preamble(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			    enum acx_preamble_type preamble);
 int cc33xx_acx_cts_protect(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			   enum acx_ctsprotect_type ctsprotect);
 int cc33xx_acx_statistics(struct cc33xx *wl, void *stats);
-int cc33xx_tx_param_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-              u8 ac, u8 cw_min, u16 cw_max, u8 aifsn, u16 txop, bool acm,
-              u8 ps_scheme, u8 is_mu_edca, u8 mu_edca_aifs, u8 mu_edca_ecw_min_max,
-              u8 mu_edca_timer);
-int cc33xx_update_ap_rates(struct cc33xx *wl,u8 role_id,u32 basic_rates_set,u32 supported_rates);
-int cc33xx_acx_ac_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-		      u8 ac, u8 cw_min, u16 cw_max, u8 aifsn, u16 txop);
-int cc33xx_acx_tid_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-		       u8 queue_id, u8 channel_type,
-		       u8 tsid, u8 ps_scheme, u8 ack_policy,
-		       u32 apsd_conf0, u32 apsd_conf1);
+int cc33xx_tx_param_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 ac,
+			u8 cw_min, u16 cw_max, u8 aifsn, u16 txop, bool acm,
+			u8 ps_scheme, u8 is_mu_edca, u8 mu_edca_aifs,
+			u8 mu_edca_ecw_min_max, u8 mu_edca_timer);
+int cc33xx_update_ap_rates(struct cc33xx *wl, u8 role_id, u32 basic_rates_set,
+			   u32 supported_rates);
 int cc33xx_acx_frag_threshold(struct cc33xx *wl, u32 frag_threshold);
-int cc33xx_acx_tx_config_options(struct cc33xx *wl);
 int cc33xx_acx_mem_cfg(struct cc33xx *wl);
 int cc33xx_acx_init_mem_config(struct cc33xx *wl);
 int cc33xx_acx_init_get_fw_versions(struct cc33xx *wl);
 int cc33xx_acx_init_rx_interrupt(struct cc33xx *wl);
-int cc33xx_acx_smart_reflex(struct cc33xx *wl);
-int cc33xx_acx_bet_enable(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			  bool enable);
-int cc33x_acx_arp_ip_filter(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+int cc33xx_acx_bet_enable(struct cc33xx *wl,
+			  struct cc33xx_vif *wlvif, bool enable);
+int cc33xx_acx_arp_ip_filter(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			     u8 enable, __be32 address);
-int cc33xx_acx_pm_config(struct cc33xx *wl);
 int cc33xx_acx_rssi_snr_trigger(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				bool enable, s16 thold, u8 hyst);
 int cc33xx_acx_rssi_snr_avg_weights(struct cc33xx *wl,
 				    struct cc33xx_vif *wlvif);
 int cc33xx_acx_set_ht_capabilities(struct cc33xx *wl,
-				    struct ieee80211_sta_ht_cap *ht_cap,
-				    bool allow_ht_operation, u8 hlid);
-int cc33xx_acx_set_ht_information(struct cc33xx *wl,
-				   struct cc33xx_vif *wlvif,
-				   u16 ht_operation_mode,
-				   u32 he_oper_params, u16 he_oper_nss_set);
+				   struct ieee80211_sta_ht_cap *ht_cap,
+				   bool allow_ht_operation, u8 hlid);
+int cc33xx_acx_set_ht_information(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+				  u16 ht_operation_mode, u32 he_oper_params,
+				  u16 he_oper_nss_set);
 int cc33xx_acx_set_ba_initiator_policy(struct cc33xx *wl,
 				       struct cc33xx_vif *wlvif);
-int cc33xx_acx_set_ba_receiver_session(struct cc33xx *wl, u8 tid_index,
-				       u16 ssn, bool enable, u8 peer_hlid,
-				       u8 win_size);
+int cc33xx_acx_set_ba_receiver_session(struct cc33xx *wl, u8 tid_index, u16 ssn,
+				       bool enable, u8 peer_hlid, u8 win_size);
 int cc33xx_acx_static_calibration_configure(struct cc33xx *wl,
 					    struct calibration_file_header *file_header,
 					    u8 *calibration_entry_ptr,
 					    bool valid_data);
-int cc33xx_acx_tsf_info(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			u64 *mactime);
-int cc33xx_acx_ps_rx_streaming(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			       bool enable);
+int cc33xx_acx_tsf_info(struct cc33xx *wl,
+			struct cc33xx_vif *wlvif, u64 *mactime);
+int cc33xx_acx_ps_rx_streaming(struct cc33xx *wl,
+			       struct cc33xx_vif *wlvif, bool enable);
 int cc33xx_acx_ap_max_tx_retry(struct cc33xx *wl, struct cc33xx_vif *wlvif);
 int cc33xx_acx_config_ps(struct cc33xx *wl, struct cc33xx_vif *wlvif);
 int cc33xx_acx_set_inconnection_sta(struct cc33xx *wl,
 				    struct cc33xx_vif *wlvif, u8 *addr);
-int cc33xx_acx_set_rate_mgmt_params(struct cc33xx *wl);
-int cc33xx_acx_config_hangover(struct cc33xx *wl);
-int wlcore_acx_average_rssi(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			    s8 *avg_rssi);
-
+int wlcore_acx_get_tx_rate(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+			   struct station_info *sinfo);
+int wlcore_acx_average_rssi(struct cc33xx *wl,
+			    struct cc33xx_vif *wlvif, s8 *avg_rssi);
 int cc33xx_acx_default_rx_filter_enable(struct cc33xx *wl, bool enable,
 					enum rx_filter_action action);
 int cc33xx_acx_set_rx_filter(struct cc33xx *wl, u8 index, bool enable,
 			     struct cc33xx_rx_filter *filter);
-
 int cc33xx_acx_dynamic_fw_traces(struct cc33xx *wl);
 int cc33xx_acx_clear_statistics(struct cc33xx *wl);
-
 int cc33xx_acx_host_if_cfg_bitmap(struct cc33xx *wl, u32 host_cfg_bitmap,
 				  u32 sdio_blk_size, u32 extra_mem_blks,
 				  u32 len_field_size);
-int cc33xx_acx_set_checksum_state(struct cc33xx *wl);
 int cc33xx_acx_peer_ht_operation_mode(struct cc33xx *wl, u8 hlid, bool wide);
 int cc33xx_acx_set_peer_cap(struct cc33xx *wl,
 			    struct ieee80211_sta_ht_cap *ht_cap,
 			    struct ieee80211_sta_he_cap *he_cap,
-			    struct cc33xx_vif *wlvif,
-			    bool allow_ht_operation,
+			    struct cc33xx_vif *wlvif, bool allow_ht_operation,
 			    u32 rate_set, u8 hlid);
 int cc33xx_acx_interrupt_notify_config(struct cc33xx *wl, bool action);
 int cc33xx_acx_rx_ba_filter(struct cc33xx *wl, bool action);
 int cc33xx_acx_ap_sleep(struct cc33xx *wl);
 int cc33xx_acx_set_antenna_select(struct cc33xx *wl, u8 selection);
-int cc33xx_acx_get_fw_versions(struct cc33xx *wl, struct cc33xx_acx_fw_versions *get_fw_versions, size_t len);
 int cc33xx_acx_set_tsf(struct cc33xx *wl, u64 tsf_val);
 int cc33xx_acx_trigger_fw_assert(struct cc33xx *wl);
 int cc33xx_acx_burst_mode_cfg(struct cc33xx *wl, u8 burst_disable);
+int cc33xx_acx_antenna_diversity_enable(struct cc33xx *wl, u8 diversity_enable);
+int cc33xx_acx_antenna_diversity_set_rssi_threshold(struct cc33xx *wl, s8 rssi_threshold);
+int cc33xx_acx_antenna_diversity_select_default_antenna(struct cc33xx *wl, u8 default_antenna);
+
+int cc33xx_acx_twt_setup(struct cc33xx *wl, u32 min_wake_duration_usec,
+               u32 min_wake_interval_mantissa, u32 min_wake_interval_exponent, u32 max_wake_interval_mantissa, u32 max_wake_interval_exponent, u8 valid_params);
+int cc33xx_acx_twt_terminate(struct cc33xx *wl);
+int cc33xx_acx_twt_resume(struct cc33xx *wl);
+int cc33xx_acx_twt_suspend(struct cc33xx *wl);
 
 
 #endif /* __CC33XX_ACX_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/boot.c b/drivers/net/wireless/ti/cc33xx/boot.c
index 22c1bc0cea68..df5fa9612bd1 100644
--- a/drivers/net/wireless/ti/cc33xx/boot.c
+++ b/drivers/net/wireless/ti/cc33xx/boot.c
@@ -7,18 +7,13 @@
  * Contact: Luciano Coelho <luciano.coelho@nokia.com>
  */
 
-#include <linux/slab.h>
-#include <linux/export.h>
 #include <linux/firmware.h>
 
-#include "debug.h"
-#include "acx.h"
 #include "boot.h"
-#include "io.h"
-#include "event.h"
-#include "rx.h"
-#include "tx.h"
+#include "cmd.h"
+#include "debug.h"
 #include "init.h"
+#include "io.h"
 
 
 #define CC33XX_BOOT_TIMEOUT 2000
@@ -45,16 +40,12 @@ struct hwinfo_bitmap
     u32 reserved                    : 13u;
 } /* Aligned with boot code, must not be __packed */;
 
-
 union hw_info
 {
     struct hwinfo_bitmap	bitmap;
     u8 				bytes[sizeof (struct hwinfo_bitmap)] ;
 };
 
-
-int wlcore_boot_upload_nvs(struct cc33xx *wl);
-
 int cc33xx_hw_init(struct cc33xx *wl);
 
 /* Called from threaded irq context */
@@ -69,20 +60,10 @@ void cc33xx_handle_boot_irqs(struct cc33xx *wl, u32 pending_interrupts)
 	complete(&wl->fw_download->wait_on_irq);
 }
 
-int wlcore_boot_run_firmware(struct cc33xx *wl)
-{
-	cc33xx_debug(DEBUG_CC33xx, "FW reset not implemented");
-
-
-	cc33xx_debug(DEBUG_CC33xx, "Skipping wait for init complete");
-
-	return 0;
-}
-
 static u8 * fetch_container(struct cc33xx *wl, const char* container_name,
-						size_t *container_len)
+			    size_t *container_len)
 {
-	u8 *container_data=NULL;
+	u8 *container_data = NULL;
 	const struct firmware *container;
 	int ret;
 
@@ -90,7 +71,7 @@ static u8 * fetch_container(struct cc33xx *wl, const char* container_name,
 
 	if (ret < 0) {
 		cc33xx_error("could not get container %s: (%d)",
-				container_name, ret);
+			     container_name, ret);
 		return NULL;
 	}
 
@@ -100,7 +81,6 @@ static u8 * fetch_container(struct cc33xx *wl, const char* container_name,
 		goto out;
 	}
 
-
 	*container_len = container->size;
 	container_data = vmalloc(container->size);
 
@@ -132,7 +112,6 @@ static int cc33xx_set_power_on(struct cc33xx *wl)
 	return ret;
 }
 
-
 static int cc33xx_chip_wakeup(struct cc33xx *wl)
 {
 	int ret = 0;
@@ -163,8 +142,8 @@ static int cc33xx_chip_wakeup(struct cc33xx *wl)
 	return ret;
 }
 
-static int wait_for_boot_irq(struct cc33xx *wl,
-				u32 boot_irq_mask, unsigned long timeout)
+static int wait_for_boot_irq(struct cc33xx *wl, u32 boot_irq_mask,
+			     unsigned long timeout)
 {
 	int ret;
 	u32 pending_irqs;
@@ -175,7 +154,7 @@ static int wait_for_boot_irq(struct cc33xx *wl,
 	ret = wait_for_completion_interruptible_timeout(
 			&fw_download->wait_on_irq, msecs_to_jiffies(timeout));
 
-	// Fetch pending IRQs while clearing them in fw_download
+	/* Fetch pending IRQs while clearing them in fw_download */
 	pending_irqs = atomic_fetch_and(0, &fw_download->pending_irqs);
 	pending_irqs &= ~HINT_COMMAND_COMPLETE;
 
@@ -192,7 +171,7 @@ static int wait_for_boot_irq(struct cc33xx *wl,
 
 	if (boot_irq_mask != pending_irqs){
 		cc33xx_error("Unexpected IRQ received @ boot: 0x%x",
-		pending_irqs);
+			     pending_irqs);
 		return -3;
 	}
 
@@ -232,10 +211,9 @@ static int download_container(struct cc33xx *wl, u8 *container, size_t len)
 	return ret;
 }
 
-static int container_download_and_wait(
-	struct cc33xx *wl,
-	const char* container_name,
-	const u32 irq_wait_mask)
+static int container_download_and_wait(struct cc33xx *wl,
+				       const char* container_name,
+				       const u32 irq_wait_mask)
 {
 	int ret=-1;
 	u8 *container_data;
@@ -293,7 +271,7 @@ static void fw_download_free(struct cc33xx *wl)
 	wl->fw_download = NULL;
 }
 
-int get_device_info(struct cc33xx *wl)
+static int get_device_info(struct cc33xx *wl)
 {
 	int ret;
 	union hw_info hw_info;
@@ -303,12 +281,15 @@ int get_device_info(struct cc33xx *wl)
 	if (ret < 0)
 		return ret;
 
-	cc33xx_debug(DEBUG_BOOT, "CC33XX device info: "
-		"PG version: %d, Metal version: %d, Boot ROM version: %d "
-		"M3 ROM version: %d, MAC address: 0x%llx, Device part number: %d",
-		hw_info.bitmap.pg_version, hw_info.bitmap.metal_version,
-		hw_info.bitmap.boot_rom_version, hw_info.bitmap.m3_rom_version,
-		(u64) hw_info.bitmap.mac_address, hw_info.bitmap.device_part_number);
+	cc33xx_debug(DEBUG_BOOT,
+		     "CC33XX device info: PG version: %d, Metal version: %d, "
+		     "Boot ROM version: %d, M3 ROM version: %d, "
+		     "MAC address: 0x%llx, Device part number: %d",
+		     hw_info.bitmap.pg_version, hw_info.bitmap.metal_version,
+		     hw_info.bitmap.boot_rom_version,
+		     hw_info.bitmap.m3_rom_version,
+		     (u64) hw_info.bitmap.mac_address,
+		     hw_info.bitmap.device_part_number);
 
 	wl->fw_download->max_transfer_size = 640;
 
@@ -347,9 +328,8 @@ int cc33xx_init_fw(struct cc33xx *wl)
 
 	wlcore_enable_interrupts(wl);
 
-	ret = wait_for_boot_irq(wl,
-		HINT_ROM_LOADER_INIT_COMPLETE,
-		CC33XX_BOOT_TIMEOUT);
+	ret = wait_for_boot_irq(wl, HINT_ROM_LOADER_INIT_COMPLETE,
+				CC33XX_BOOT_TIMEOUT);
 	if (ret < 0)
 		goto disable_irq;
 
@@ -357,15 +337,13 @@ int cc33xx_init_fw(struct cc33xx *wl)
 	if (ret < 0)
 		goto disable_irq;
 
-	ret = container_download_and_wait(wl,
-		SECOND_LOADER_NAME,
-		HINT_SECOND_LOADER_INIT_COMPLETE);
+	ret = container_download_and_wait(wl, SECOND_LOADER_NAME,
+					  HINT_SECOND_LOADER_INIT_COMPLETE);
 	if (ret < 0)
 		goto disable_irq;
 
-	ret = container_download_and_wait(wl,
-		FW_NAME,
-		HINT_FW_WAKEUP_COMPLETE);
+	ret = container_download_and_wait(wl,  FW_NAME,
+					  HINT_FW_WAKEUP_COMPLETE);
 	if (ret < 0)
 		goto disable_irq;
 
@@ -374,7 +352,7 @@ int cc33xx_init_fw(struct cc33xx *wl)
 	if (ret < 0)
 		goto disable_irq;
 
-	ret = wait_for_boot_irq(wl, HINT_FW_INIT_COMPLETE , CC33XX_BOOT_TIMEOUT);
+	ret = wait_for_boot_irq(wl, HINT_FW_INIT_COMPLETE, CC33XX_BOOT_TIMEOUT);
 
 
 	if (ret < 0)
@@ -398,7 +376,10 @@ int cc33xx_init_fw(struct cc33xx *wl)
 	cc33xx_debug(DEBUG_MAC80211, "11a is %ssupported",
 		     wl->enable_11a ? "" : "not ");
 
-	wl->state = WLCORE_STATE_ON;
+	if (wl->state != WLCORE_STATE_RESTARTING){
+		wl->state = WLCORE_STATE_ON;
+	}
+
 	ret = 0;
 	goto out;
 
diff --git a/drivers/net/wireless/ti/cc33xx/boot.h b/drivers/net/wireless/ti/cc33xx/boot.h
index 534221c8b66e..312ada6193fe 100644
--- a/drivers/net/wireless/ti/cc33xx/boot.h
+++ b/drivers/net/wireless/ti/cc33xx/boot.h
@@ -12,6 +12,7 @@
 
 #include "wlcore.h"
 
+
 int cc33xx_init_fw(struct cc33xx *wl);
 
 void cc33xx_handle_boot_irqs(struct cc33xx *wl, u32 pending_interrupts);
@@ -19,20 +20,11 @@ void cc33xx_handle_boot_irqs(struct cc33xx *wl, u32 pending_interrupts);
 #define SECOND_LOADER_NAME "ti-connectivity/cc33xx_2nd_loader.bin"
 #define FW_NAME "ti-connectivity/cc33xx_fw.bin"
 
-
 struct cc33xx_fw_download {
 	atomic_t pending_irqs;
 	struct completion wait_on_irq;
 	size_t max_transfer_size;
 };
 
-/* number of times we try to read the INIT interrupt */
-#define INIT_LOOP 20000
-
-/* delay between retries */
-#define INIT_LOOP_DELAY 50
-
-#define WU_COUNTER_PAUSE_VAL 0x3FF
-#define WELP_ARM_COMMAND_VAL 0x4
 
-#endif
+#endif /* __BOOT_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/cc33xx_80211.h b/drivers/net/wireless/ti/cc33xx/cc33xx_80211.h
index 34be85ee73b8..430391f9f400 100644
--- a/drivers/net/wireless/ti/cc33xx/cc33xx_80211.h
+++ b/drivers/net/wireless/ti/cc33xx/cc33xx_80211.h
@@ -2,14 +2,9 @@
 #ifndef __CC33XX_80211_H__
 #define __CC33XX_80211_H__
 
-#include <linux/if_ether.h>	/* ETH_ALEN */
 #include <linux/if_arp.h>
 
 
-/* This really should be 8, but not for our firmware */
-#define MAX_SUPPORTED_RATES 32
-#define MAX_COUNTRY_TRIPLETS 32
-
 /* Headers */
 struct ieee80211_header {
 	__le16 frame_ctl;
@@ -21,13 +16,8 @@ struct ieee80211_header {
 	u8 payload[0];
 } __packed;
 
-
 /* Templates */
 
-struct cc33xx_null_data_template {
-	struct ieee80211_header header;
-} __packed;
-
 struct cc33xx_arp_rsp_template {
 	/* not including ieee80211 header */
 
@@ -46,4 +36,5 @@ struct cc33xx_disconn_template {
 	__le16 disconn_reason;
 } __packed;
 
-#endif
+
+#endif /* __CC33XX_80211_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/cmd.c b/drivers/net/wireless/ti/cc33xx/cmd.c
index aab892ebc123..ffd5fef42b6f 100644
--- a/drivers/net/wireless/ti/cc33xx/cmd.c
+++ b/drivers/net/wireless/ti/cc33xx/cmd.c
@@ -7,31 +7,16 @@
  * Contact: Luciano Coelho <luciano.coelho@nokia.com>
  */
 
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/spi/spi.h>
-#include <linux/etherdevice.h>
-#include <linux/ieee80211.h>
-#include <linux/slab.h>
-#include <linux/timer.h>
-
-#include "wlcore.h"
-#include "debug.h"
-#include "io.h"
 #include "acx.h"
 #include "cc33xx_80211.h"
-#include "cmd.h"
 #include "event.h"
+#include "io.h"
 #include "tx.h"
 
 #define CC33XX_REBOOT_TIMEOUT_MSEC		100
 
-#define CC33XX_CMD_FAST_POLL_COUNT       50
-#define CC33XX_WAIT_EVENT_FAST_POLL_COUNT 20
-static inline void init_cmd_header(
-	struct cc33xx_cmd_header* header,
-	size_t cmd_len,
-	u16 id)
+static void init_cmd_header(struct cc33xx_cmd_header* header,
+			    size_t cmd_len, u16 id)
 {
 	header->NAB_header.len = cpu_to_le16(cmd_len);
 	BUG_ON(header->NAB_header.len != cmd_len);
@@ -39,37 +24,43 @@ static inline void init_cmd_header(
 	header->NAB_header.sync_pattern = cpu_to_le32(HOST_SYNC_PATTERN);
 	header->NAB_header.opcode = cpu_to_le16(id);
 }
+
 int cc33xx_set_max_buffer_size(struct cc33xx *wl, BufferSize_e max_buffer_size)
 {
 	switch(max_buffer_size)
 	{
-		case INI_MAX_BUFFER_SIZE:
-			wl->max_cmd_size = CC33XX_INI_CMD_MAX_SIZE + sizeof(struct cc33xx_cmd_ini_params_download)+ sizeof(u32);//INI FILE PAYLOAD SIZE + INI CMD PARAM + INT
-			break;
+	case INI_MAX_BUFFER_SIZE:
+		/* INI FILE PAYLOAD SIZE + INI CMD PARAM + INT */
+		wl->max_cmd_size = CC33XX_INI_CMD_MAX_SIZE;
+		wl->max_cmd_size += sizeof(struct cc33xx_cmd_ini_params_download);
+		wl->max_cmd_size += sizeof(u32);
+		break;
 
-		case CMD_MAX_BUFFER_SIZE:
-			wl->max_cmd_size = CC33XX_CMD_MAX_SIZE;
-			break;
-		default:
-			cc33xx_warning("max_buffer_size invalid, not changing buffer size");
-			break;
+	case CMD_MAX_BUFFER_SIZE:
+		wl->max_cmd_size = CC33XX_CMD_MAX_SIZE;
+		break;
+
+	default:
+		cc33xx_warning("max_buffer_size invalid, not changing buffer size");
+		break;
 	}
-	return 0;
 
+	return 0;
 }
 
 static int send_buffer(struct cc33xx *wl, int cmd_box_addr,
-			       void *buf, size_t len)
+		       void *buf, size_t len)
 {
 	size_t max_cmd_size_align;
 	memcpy(wl->cmd_buf, buf, len);
 
 	memset(wl->cmd_buf + len, 0, (CC33XX_CMD_BUFFER_SIZE) - len);
 
-	max_cmd_size_align = __ALIGN_MASK(wl->max_cmd_size,CC33XX_BUS_BLOCK_SIZE*2 - 1);
+	max_cmd_size_align = __ALIGN_MASK(wl->max_cmd_size,
+					  CC33XX_BUS_BLOCK_SIZE * 2 - 1);
 
 	return wlcore_write(wl, cmd_box_addr, wl->cmd_buf,
-				(max_cmd_size_align), true);
+			    max_cmd_size_align, true);
 }
 
 /*
@@ -88,58 +79,51 @@ static int __wlcore_cmd_send(struct cc33xx *wl, u16 id, void *buf,
 	unsigned long timeout;
 	int ret;
 
-	if (id >= CMD_LAST_SUPPORTED_COMMAND)
-	{
+	if (id >= CMD_LAST_SUPPORTED_COMMAND) {
 	    cc33xx_debug(DEBUG_CMD, "command ID: %d, blocked",id);
 	    return(CMD_STATUS_SUCCESS);
 	}
 
-	if (unlikely(wl->state == WLCORE_STATE_RESTARTING &&
-		     id != CMD_STOP_FWLOGGER))
-		return -EIO;
-
-	if (WARN_ON_ONCE(len < sizeof(*cmd)))
+	if (WARN_ON(len < sizeof(*cmd))		||
+	    WARN_ON(len > wl->max_cmd_size)	||
+	    WARN_ON(len % 4 != 0))
 		return -EIO;
 
-	BUG_ON(len > wl->max_cmd_size);
-
 	cmd = buf;
 	cmd->id = cpu_to_le16(id);
 	cmd->status = 0;
 
-	WARN_ON(len % 4 != 0);
-	WARN_ON(test_bit(CC33XX_FLAG_IN_ELP, &wl->flags));
 	init_cmd_header(cmd, len, id);
 	init_completion (&wl->command_complete);
 	ret = send_buffer(wl, NAB_DATA_ADDR, buf, len);
+
 	if (ret < 0)
 		return ret;
 
 	if (unlikely(!sync))
 		return CMD_STATUS_SUCCESS;
+
 	timeout = msecs_to_jiffies(CC33XX_COMMAND_TIMEOUT);
-	ret = wait_for_completion_timeout(
-		&wl->command_complete, timeout);
-	if (ret < 1)
-	{
+	ret = wait_for_completion_timeout(&wl->command_complete, timeout);
+
+	if (ret < 1) {
 		cc33xx_debug(DEBUG_CMD, "Command T.O");
 		return -EIO;
 	}
 
-	switch(id){
+	switch(id) {
 	case CMD_INTERROGATE:
 	case CMD_DEBUG_READ:
 	case CMD_TEST_MODE:
 	case CMD_BM_READ_DEVICE_INFO:
 		cc33xx_debug(DEBUG_CMD,
-			"Response len %d, allocated buffer len %d",
-			wl->result_length,
-			res_len);
+			     "Response len %d, allocated buffer len %d",
+			     wl->result_length, res_len);
 
 		if (!res_len)
-			break; // Response should be discarded
+			break; /* Response should be discarded */
 
-		if (WARN_ON(wl->result_length > res_len)){
+		if (WARN_ON(wl->result_length > res_len)) {
 			cc33xx_error("Error, insufficient response buffer");
 			break;
 		}
@@ -167,7 +151,6 @@ static int wlcore_cmd_send_failsafe(struct cc33xx *wl, u16 id, void *buf,
 {
 	int ret = __wlcore_cmd_send(wl, id, buf, len, res_len, true);
 
-
 	cc33xx_debug(DEBUG_TESTMODE, "CMD# %d, len=%d", id, len);
 
 	if (ret < 0)
@@ -176,12 +159,11 @@ static int wlcore_cmd_send_failsafe(struct cc33xx *wl, u16 id, void *buf,
 	/* success is always a valid status */
 	valid_rets |= BIT(CMD_STATUS_SUCCESS);
 
-	if (ret >= MAX_COMMAND_STATUS ||
-	    !test_bit(ret, &valid_rets)) {
+	if (ret >= MAX_COMMAND_STATUS || !test_bit(ret, &valid_rets)) {
 		cc33xx_error("command execute failure %d", ret);
 		ret = -EIO;
-		//goto fail;
 	}
+
 	return ret;
 fail:
 	cc33xx_queue_recovery_work(wl);
@@ -192,35 +174,33 @@ static int wlcore_cmd_send_failsafe(struct cc33xx *wl, u16 id, void *buf,
  * wrapper for wlcore_cmd_send that accept only CMD_STATUS_SUCCESS
  * return 0 on success.
  */
-int cc33xx_cmd_send(struct cc33xx *wl, u16 id, void *buf, size_t len,
-		    size_t res_len)
+int cc33xx_cmd_send(struct cc33xx *wl, u16 id, void *buf,
+		    size_t len, size_t res_len)
 {
 	int ret;
 	/* Support id */
 	switch((enum cc33xx_cmd)id)
 	{
-		case CMD_EMPTY:
-		case CMD_CHANNEL_SWITCH          :
-		case CMD_STOP_CHANNEL_SWICTH     :
-		case CMD_START_DHCP_MGMT_SEQ     :
-		case CMD_STOP_DHCP_MGMT_SEQ      :
-		case CMD_START_SECURITY_MGMT_SEQ :
-		case CMD_STOP_SECURITY_MGMT_SEQ  :
-		case CMD_START_ARP_MGMT_SEQ      :
-		case CMD_STOP_ARP_MGMT_SEQ       :
-		case CMD_START_DNS_MGMT_SEQ      :
-		case CMD_STOP_DNS_MGMT_SEQ       :
-		case CMD_SEND_DEAUTH_DISASSOC    :
-		case CMD_SCHED_STATE_EVENT	 :
-		{
+	case CMD_EMPTY:
+	case CMD_START_DHCP_MGMT_SEQ     :
+	case CMD_STOP_DHCP_MGMT_SEQ      :
+	case CMD_START_SECURITY_MGMT_SEQ :
+	case CMD_STOP_SECURITY_MGMT_SEQ  :
+	case CMD_START_ARP_MGMT_SEQ      :
+	case CMD_STOP_ARP_MGMT_SEQ       :
+	case CMD_START_DNS_MGMT_SEQ      :
+	case CMD_STOP_DNS_MGMT_SEQ       :
+	case CMD_SEND_DEAUTH_DISASSOC    :
+	case CMD_SCHED_STATE_EVENT	 :
+	{
+		return 0;
+	}break;
+	default:
+	{
+		if ((enum cc33xx_cmd)id >= CMD_LAST_SUPPORTED_COMMAND)
 			return 0;
-		}break;
-		default:
-		{
-			if ( (enum cc33xx_cmd)id >= CMD_LAST_SUPPORTED_COMMAND)
-				return 0;
-			goto send;
-		}
+		goto send;
+	}
 	}
 send:
 	ret = wlcore_cmd_send_failsafe(wl, id, buf, len, res_len, 0);
@@ -229,47 +209,49 @@ int cc33xx_cmd_send(struct cc33xx *wl, u16 id, void *buf, size_t len,
 	return 0;
 }
 
-int cc33xx_count_role_set_bits(unsigned long role_map)
+static int cc33xx_count_role_set_bits(unsigned long role_map)
 {
 	int count = 0;
-	// if device bit is set ( BIT_2 = ROLE_DEVICE)
-	// since role device is not counted
-	// remove it from map
+	/* if device bit is set ( BIT_2 = ROLE_DEVICE)
+	 * since role device is not counted
+	 * remove it from map */
 	role_map &= ~BIT(2);
 
-	while (role_map != 0)
-	{
+	while (role_map != 0) {
 		count += role_map & 1;
 		role_map >>= 1;
 	}
+
 	return count;
 }
 
-int cc33xx_cmd_role_enable(struct cc33xx *wl, u8 *addr, u8 role_type,
-			   u8 *role_id)
+int cc33xx_cmd_role_enable(struct cc33xx *wl, u8 *addr,
+			   u8 role_type, u8 *role_id)
 {
 	struct cc33xx_cmd_role_enable *cmd;
 
 	int ret;
 	unsigned long role_count;
 
-
 	struct cc33xx_cmd_complete_role_enable *command_complete =
 		  (struct cc33xx_cmd_complete_role_enable *)&wl->command_result;
 
 	role_count = *wl->roles_map;
-        ret = cc33xx_count_role_set_bits(role_count);
-	cc33xx_debug(DEBUG_CMD, "cmd roles enabled: bitmap before: %ld, ret=%d", role_count, ret);
+	ret = cc33xx_count_role_set_bits(role_count);
+	cc33xx_debug(DEBUG_CMD, "cmd roles enabled: bitmap before: %ld, ret=%d",
+		     role_count, ret);
 
-	//do not enable more than 2 roles at once, exception is device role
-	if ((ret >= 2) && (CC33XX_ROLE_DEVICE != role_type))
-	{
-		cc33xx_debug(DEBUG_CMD, "cmd role enable: 2 roles already have beed allocated");
+	/* do not enable more than 2 roles at once, exception is device role */
+	if ((ret >= 2) && (CC33XX_ROLE_DEVICE != role_type)) {
+		cc33xx_debug(DEBUG_CMD,
+			     "cmd role enable: 2 roles already have beed allocated");
 		cc33xx_error("failed to initiate cmd role enable");
 		ret = -EBUSY;
 		goto out;
 	}
-	cc33xx_debug(DEBUG_CMD, "cmd role enable, role type %d, addr = %pM", role_type, addr);
+
+	cc33xx_debug(DEBUG_CMD, "cmd role enable, role type %d, addr = %pM",
+		     role_type, addr);
 
 	if (WARN_ON(*role_id != CC33XX_INVALID_ROLE_ID))
 		return -EBUSY;
@@ -289,7 +271,7 @@ int cc33xx_cmd_role_enable(struct cc33xx *wl, u8 *addr, u8 role_type,
 		goto out_free;
 	}
 	cc33xx_debug(DEBUG_CMD, "complete role_id = %d",
-						      command_complete->role_id);
+		     command_complete->role_id);
 	__set_bit(command_complete->role_id, wl->roles_map);
 	*role_id = command_complete->role_id;
 
@@ -405,7 +387,7 @@ void cc33xx_clear_link(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 *hlid)
 	WARN_ON_ONCE(wl->active_link_count < 0);
 }
 
-u8 wlcore_get_native_channel_type(u8 nl_channel_type)
+static u8 wlcore_get_native_channel_type(u8 nl_channel_type)
 {
 	switch (nl_channel_type) {
 	case NL80211_CHAN_NO_HT:
@@ -422,10 +404,8 @@ u8 wlcore_get_native_channel_type(u8 nl_channel_type)
 	}
 }
 
-int cc33xx_cmd_role_start_dev(struct cc33xx *wl,
-				     struct cc33xx_vif *wlvif,
-				     enum nl80211_band band,
-				     int channel)
+int cc33xx_cmd_role_start_dev(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+			      enum nl80211_band band, int channel)
 {
 	struct cc33xx_cmd_role_start *cmd;
 	int ret;
@@ -458,7 +438,8 @@ int cc33xx_cmd_role_start_dev(struct cc33xx *wl,
 	wl->links[wlvif->dev_hlid].allocated_pkts = 0;
 	wl->session_ids[wlvif->dev_hlid] = command_complete->sta.session;
 	cc33xx_debug(DEBUG_CMD, "role start: roleid=%d, hlid=%d, session=%d ",
-             wlvif->dev_role_id, command_complete->sta.hlid, command_complete->sta.session);
+		     wlvif->dev_role_id, command_complete->sta.hlid,
+		     command_complete->sta.session);
 	ret = cc33xx_set_link(wl, wlvif, wlvif->dev_hlid);
 	goto out_free;
 
@@ -535,7 +516,7 @@ int cc33xx_cmd_plt_disable(struct cc33xx *wl)
 }
 
 static int cc333xx_cmd_role_stop_dev(struct cc33xx *wl,
-				    struct cc33xx_vif *wlvif)
+				     struct cc33xx_vif *wlvif)
 {
 	struct cc33xx_cmd_role_stop *cmd;
 	int ret;
@@ -610,7 +591,7 @@ int cc33xx_cmd_role_start_transceiver(struct cc33xx *wl, u8 role_id)
 		goto out;
 	}
 
-    cmd->role_type = role_type;
+	cmd->role_type = role_type;
 	cmd->role_id = role_id;
 	cmd->channel = channel;
 	cmd->band = band;
@@ -620,7 +601,9 @@ int cc33xx_cmd_role_start_transceiver(struct cc33xx *wl, u8 role_id)
 		cc33xx_error("failed to initiate cmd role start PLT");
 		goto out_free;
 	}
-	cc33xx_debug(DEBUG_CMD, "cmd role start PLT. Role ID number: %u", role_id);
+
+	cc33xx_debug(DEBUG_CMD,
+		     "cmd role start PLT. Role ID number: %u", role_id);
 
 out_free:
 	kfree(cmd);
@@ -649,13 +632,14 @@ int cc33xx_cmd_role_start_sta(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 
 	cmd->role_id = wlvif->role_id;
 	cmd->role_type = CC33XX_ROLE_STA;
-	if (wlvif->band == NL80211_BAND_5GHZ)
-		cmd->band = WLCORE_BAND_5GHZ;
 	cmd->channel = wlvif->channel;
-	if (wlvif->band == NL80211_BAND_5GHZ)
-		cmd->sta.basic_rate_set = cpu_to_le32(wlvif->basic_rate_set & ~CONF_TX_CCK_RATES);
-	else
+	if (wlvif->band == NL80211_BAND_5GHZ) {
+		cmd->band = WLCORE_BAND_5GHZ;
+		cmd->sta.basic_rate_set = cpu_to_le32(wlvif->basic_rate_set
+							& ~CONF_TX_CCK_RATES);
+	} else {
 		cmd->sta.basic_rate_set = cpu_to_le32(wlvif->basic_rate_set);
+	}
 	cmd->sta.beacon_interval = cpu_to_le16(wlvif->beacon_int);
 	cmd->sta.ssid_type = CC33XX_SSID_TYPE_ANY;
 	cmd->sta.ssid_len = wlvif->ssid_len;
@@ -693,15 +677,14 @@ int cc33xx_cmd_role_start_sta(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	wl->links[wlvif->sta.hlid].allocated_pkts = 0;
 	wl->session_ids[wlvif->sta.hlid] = command_complete->sta.session;
 	cc33xx_debug(DEBUG_CMD, "role start: roleid=%d, hlid=%d, session=%d "
-             "basic_rate_set: 0x%x, remote_rates: 0x%x",
-             wlvif->role_id, command_complete->sta.hlid, command_complete->sta.session,
-             wlvif->basic_rate_set, wlvif->rate_set);
+		     "basic_rate_set: 0x%x, remote_rates: 0x%x", wlvif->role_id,
+		     command_complete->sta.hlid, command_complete->sta.session,
+		     wlvif->basic_rate_set, wlvif->rate_set);
 	ret = cc33xx_set_link(wl, wlvif, wlvif->sta.hlid);
 
 	goto out_free;
 
 err_hlid:
-
 	cc33xx_clear_link(wl, wlvif, &wlvif->sta.hlid);
 
 out_free:
@@ -757,7 +740,8 @@ int cc33xx_cmd_role_start_ap(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 
 
 	cc33xx_debug(DEBUG_CMD, "cmd role start ap %d", wlvif->role_id);
-	cc33xx_debug(DEBUG_CMD, "cmd role start ap basic rateset:  0x%x ", wlvif->basic_rate_set);
+	cc33xx_debug(DEBUG_CMD, "cmd role start ap basic rateset: 0x%x",
+		     wlvif->basic_rate_set);
 
 	/* If MESH --> ssid_len is always 0 */
 	if (!ieee80211_vif_is_mesh(vif)) {
@@ -818,11 +802,14 @@ int cc33xx_cmd_role_start_ap(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	wl->session_ids[wlvif->ap.bcast_hlid] = command_complete->ap.bcast_session_id;
 
 	cc33xx_debug(DEBUG_CMD, "role start: roleid=%d, global_hlid=%d, "
-	     "broadcast_hlid=%d global_session_id=%d, bcast_session_id=%d "
-             "basic_rate_set: 0x%x, remote_rates: 0x%x",
-             wlvif->role_id, command_complete->ap.global_hlid,
-	     command_complete->ap.broadcast_hlid, command_complete->ap.global_session_id,
-	     command_complete->ap.bcast_session_id, wlvif->basic_rate_set, wlvif->rate_set);
+		     "broadcast_hlid=%d, global_session_id=%d, "
+		     "bcast_session_id=%d, basic_rate_set: 0x%x, "
+		     "remote_rates: 0x%x", wlvif->role_id,
+		     command_complete->ap.global_hlid,
+		     command_complete->ap.broadcast_hlid,
+		     command_complete->ap.global_session_id,
+		     command_complete->ap.bcast_session_id,
+		     wlvif->basic_rate_set, wlvif->rate_set);
 
 	ret = cc33xx_set_link(wl, wlvif, wlvif->ap.global_hlid);
 	ret = cc33xx_set_link(wl, wlvif, wlvif->ap.bcast_hlid );
@@ -830,7 +817,6 @@ int cc33xx_cmd_role_start_ap(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	goto out_free;
 
 out_free_bcast:
-
 	cc33xx_clear_link(wl, wlvif, &wlvif->ap.bcast_hlid);
 	cc33xx_clear_link(wl, wlvif, &wlvif->ap.global_hlid);
 
@@ -862,7 +848,6 @@ int cc33xx_cmd_role_stop_ap(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 		goto out_free;
 	}
 
-
 	cc33xx_clear_link(wl, wlvif, &wlvif->ap.bcast_hlid);
 	cc33xx_clear_link(wl, wlvif, &wlvif->ap.global_hlid);
 
@@ -1145,232 +1130,6 @@ int cc33xx_cmd_ps_mode(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-int cc33xx_cmd_template_set(struct cc33xx *wl, u8 role_id,
-			    u16 template_id, void *buf, size_t buf_len,
-			    int index, u32 rates)
-{
-	struct cc33xx_cmd_template_set *cmd;
-	int ret = 0;
-
-	cc33xx_debug(DEBUG_CMD, "cmd template_set %d (role %d)",
-		     template_id, role_id);
-
-	WARN_ON(buf_len > CC33XX_CMD_TEMPL_MAX_SIZE);
-	buf_len = min_t(size_t, buf_len, CC33XX_CMD_TEMPL_MAX_SIZE);
-
-	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
-	if (!cmd) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	/* during initialization wlvif is NULL */
-	cmd->role_id = role_id;
-	cmd->len = cpu_to_le16(buf_len);
-	cmd->template_type = template_id;
-	cmd->enabled_rates = cpu_to_le32(rates);
-	cmd->short_retry_limit = wl->conf.host_conf.tx.tmpl_short_retry_limit;
-	cmd->long_retry_limit = wl->conf.host_conf.tx.tmpl_long_retry_limit;
-	cmd->index = index;
-
-	if (buf)
-		memcpy(cmd->template_data, buf, buf_len);
-
-	ret = cc33xx_cmd_send(wl, CMD_SET_TEMPLATE, cmd, sizeof(*cmd), 0);
-	if (ret < 0) {
-		cc33xx_warning("cmd set_template failed: %d", ret);
-		goto out_free;
-	}
-
-out_free:
-	kfree(cmd);
-
-out:
-	return ret;
-}
-
-int cc33xx_cmd_build_null_data(struct cc33xx *wl, struct cc33xx_vif *wlvif)
-{
-	struct sk_buff *skb = NULL;
-	int size;
-	void *ptr;
-	int ret = -ENOMEM;
-
-
-	if (wlvif->bss_type == BSS_TYPE_IBSS) {
-		size = sizeof(struct cc33xx_null_data_template);
-		ptr = NULL;
-	} else {
-		skb = ieee80211_nullfunc_get(wl->hw,
-					     cc33xx_wlvif_to_vif(wlvif),
-					     -1, false);
-		if (!skb)
-			goto out;
-		size = skb->len;
-		ptr = skb->data;
-	}
-
-	ret = cc33xx_cmd_template_set(wl, wlvif->role_id,
-				      CMD_TEMPL_NULL_DATA, ptr, size, 0,
-				      wlvif->basic_rate);
-
-out:
-	dev_kfree_skb(skb);
-	if (ret)
-		cc33xx_warning("cmd buld null data failed %d", ret);
-
-	return ret;
-
-}
-
-struct sk_buff *cc33xx_cmd_build_ap_probe_req(struct cc33xx *wl,
-					      struct cc33xx_vif *wlvif,
-					      struct sk_buff *skb)
-{
-	struct ieee80211_vif *vif = cc33xx_wlvif_to_vif(wlvif);
-	int ret;
-	u32 rate;
-
-	if (!skb)
-		skb = ieee80211_ap_probereq_get(wl->hw, vif);
-	if (!skb)
-		goto out;
-
-	cc33xx_debug(DEBUG_SCAN, "set ap probe request template");
-
-	rate = cc33xx_tx_min_rate_get(wl, wlvif->bitrate_masks[wlvif->band]);
-	if (wlvif->band == NL80211_BAND_2GHZ)
-		ret = cc33xx_cmd_template_set(wl, wlvif->role_id,
-					      CMD_TEMPL_CFG_PROBE_REQ_2_4,
-					      skb->data, skb->len, 0, rate);
-	else
-		ret = cc33xx_cmd_template_set(wl, wlvif->role_id,
-					      CMD_TEMPL_CFG_PROBE_REQ_5,
-					      skb->data, skb->len, 0, rate);
-
-	if (ret < 0)
-		cc33xx_error("Unable to set ap probe request template.");
-
-out:
-	return skb;
-}
-
-int cc33xx_cmd_build_arp_rsp(struct cc33xx *wl, struct cc33xx_vif *wlvif)
-{
-	int ret, extra = 0;
-	u16 fc;
-	struct ieee80211_vif *vif = cc33xx_wlvif_to_vif(wlvif);
-	struct sk_buff *skb;
-	struct cc33xx_arp_rsp_template *tmpl;
-	struct ieee80211_hdr_3addr *hdr;
-	struct arphdr *arp_hdr;
-
-	skb = dev_alloc_skb(sizeof(*hdr) + sizeof(__le16) + sizeof(*tmpl) +
-			    CC33XX_EXTRA_SPACE_MAX);
-	if (!skb) {
-		cc33xx_error("failed to allocate buffer for arp rsp template");
-		return -ENOMEM;
-	}
-
-	skb_reserve(skb, sizeof(*hdr) + CC33XX_EXTRA_SPACE_MAX);
-
-	tmpl = skb_put_zero(skb, sizeof(*tmpl));
-
-	/* llc layer */
-	memcpy(tmpl->llc_hdr, rfc1042_header, sizeof(rfc1042_header));
-	tmpl->llc_type = cpu_to_be16(ETH_P_ARP);
-
-	/* arp header */
-	arp_hdr = &tmpl->arp_hdr;
-	arp_hdr->ar_hrd = cpu_to_be16(ARPHRD_ETHER);
-	arp_hdr->ar_pro = cpu_to_be16(ETH_P_IP);
-	arp_hdr->ar_hln = ETH_ALEN;
-	arp_hdr->ar_pln = 4;
-	arp_hdr->ar_op = cpu_to_be16(ARPOP_REPLY);
-
-	/* arp payload */
-	memcpy(tmpl->sender_hw, vif->addr, ETH_ALEN);
-	tmpl->sender_ip = wlvif->ip_addr;
-
-	/* encryption space */
-	switch (wlvif->encryption_type) {
-	case KEY_TKIP:
-		if (wl->quirks & WLCORE_QUIRK_TKIP_HEADER_SPACE)
-			extra = CC33XX_EXTRA_SPACE_TKIP;
-		break;
-	case KEY_AES:
-	case KEY_GCMP_256:
-		extra = CC33XX_EXTRA_SPACE_AES;
-		break;
-	case KEY_NONE:
-	case KEY_WEP:
-	case KEY_GEM:
-		extra = 0;
-		break;
-	default:
-		cc33xx_warning("Unknown encryption type: %d",
-			       wlvif->encryption_type);
-		ret = -EINVAL;
-		goto out;
-	}
-
-	if (extra) {
-		u8 *space = skb_push(skb, extra);
-		memset(space, 0, extra);
-	}
-
-	/* QoS header - BE */
-	if (wlvif->sta.qos)
-		memset(skb_push(skb, sizeof(__le16)), 0, sizeof(__le16));
-
-	/* mac80211 header */
-	hdr = skb_push(skb, sizeof(*hdr));
-	memset(hdr, 0, sizeof(*hdr));
-	fc = IEEE80211_FTYPE_DATA | IEEE80211_FCTL_TODS;
-	if (wlvif->sta.qos)
-		fc |= IEEE80211_STYPE_QOS_DATA;
-	else
-		fc |= IEEE80211_STYPE_DATA;
-	if (wlvif->encryption_type != KEY_NONE)
-		fc |= IEEE80211_FCTL_PROTECTED;
-
-	hdr->frame_control = cpu_to_le16(fc);
-	memcpy(hdr->addr1, vif->bss_conf.bssid, ETH_ALEN);
-	memcpy(hdr->addr2, vif->addr, ETH_ALEN);
-	eth_broadcast_addr(hdr->addr3);
-
-	ret = cc33xx_cmd_template_set(wl, wlvif->role_id, CMD_TEMPL_ARP_RSP,
-				      skb->data, skb->len, 0,
-				      wlvif->basic_rate);
-out:
-	dev_kfree_skb(skb);
-	return ret;
-}
-
-int cc33xx_build_qos_null_data(struct cc33xx *wl, struct ieee80211_vif *vif)
-{
-	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
-	struct ieee80211_qos_hdr template;
-
-	memset(&template, 0, sizeof(template));
-
-	memcpy(template.addr1, vif->bss_conf.bssid, ETH_ALEN);
-	memcpy(template.addr2, vif->addr, ETH_ALEN);
-	memcpy(template.addr3, vif->bss_conf.bssid, ETH_ALEN);
-
-	template.frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
-					     IEEE80211_STYPE_QOS_NULLFUNC |
-					     IEEE80211_FCTL_TODS);
-
-	/* FIXME: not sure what priority to use here */
-	template.qos_ctrl = cpu_to_le16(0);
-
-	return cc33xx_cmd_template_set(wl, wlvif->role_id,
-				       CMD_TEMPL_QOS_NULL_DATA, &template,
-				       sizeof(template), 0,
-				       wlvif->basic_rate);
-}
-
 int cc33xx_cmd_set_default_wep_key(struct cc33xx *wl, u8 id, u8 hlid)
 {
 	struct cc33xx_cmd_set_keys *cmd;
@@ -1403,9 +1162,9 @@ int cc33xx_cmd_set_default_wep_key(struct cc33xx *wl, u8 id, u8 hlid)
 }
 
 int cc33xx_cmd_set_sta_key(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-		       u16 action, u8 id, u8 key_type,
-		       u8 key_size, const u8 *key, const u8 *addr,
-		       u32 tx_seq_32, u16 tx_seq_16)
+		           u16 action, u8 id, u8 key_type, u8 key_size,
+			   const u8 *key, const u8 *addr, u32 tx_seq_32,
+			   u16 tx_seq_16)
 {
 	struct cc33xx_cmd_set_keys *cmd;
 	int ret = 0;
@@ -1472,9 +1231,8 @@ int cc33xx_cmd_set_sta_key(struct cc33xx *wl, struct cc33xx_vif *wlvif,
  * note there are slight diffs
  */
 int cc33xx_cmd_set_ap_key(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			  u16 action, u8 id, u8 key_type,
-			  u8 key_size, const u8 *key, u8 hlid, u32 tx_seq_32,
-			  u16 tx_seq_16)
+			  u16 action, u8 id, u8 key_type, u8 key_size,
+			  const u8 *key, u8 hlid, u32 tx_seq_32, u16 tx_seq_16)
 {
 	struct cc33xx_cmd_set_keys *cmd;
 	int ret = 0;
@@ -1550,11 +1308,12 @@ int cc33xx_cmd_set_peer_state(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	cmd->hlid = hlid;
 	cmd->state = CC33XX_CMD_STA_STATE_CONNECTED;
 
-	ret = cc33xx_cmd_send(wl, CMD_SET_LINK_CONNECTION_STATE, cmd, sizeof(*cmd), 0);
-    if (ret < 0) {
-        cc33xx_error("failed to send set peer state command");
-        goto out_free;
-    }
+	ret = cc33xx_cmd_send(wl, CMD_SET_LINK_CONNECTION_STATE,
+			      cmd, sizeof(*cmd), 0);
+	if (ret < 0) {
+		cc33xx_error("failed to send set peer state command");
+		goto out_free;
+	}
 
 out_free:
 	kfree(cmd);
@@ -1571,19 +1330,15 @@ int cc33xx_cmd_add_peer(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	struct cc33xx_cmd_complete_add_peer *command_complete =
 	          (struct cc33xx_cmd_complete_add_peer *)&wl->command_result;
 
-
 	int i, ret;
 	u32 sta_rates;
 
-	//cc33xx_debug(DEBUG_CMD, "cmd add peer %d", (int)hlid);
-
 	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd) {
 		ret = -ENOMEM;
 		goto out;
 	}
 
-
 	cc33xx_debug(DEBUG_CMD, "cmd add peer is ap %d", is_connected);
 	cmd->is_connected = is_connected;
 	cmd->role_id = wlvif->role_id;
@@ -1596,20 +1351,22 @@ int cc33xx_cmd_add_peer(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	cmd->sp_len = sta->max_sp;
 	cmd->wmm = sta->wme ? 1 : 0;
 
-	for (i = 0; i < NUM_ACCESS_CATEGORIES_COPY; i++)
-		if (sta->wme && (sta->uapsd_queues & BIT(i)))
+	for (i = 0; i < NUM_ACCESS_CATEGORIES_COPY; i++) {
+		if (sta->wme && (sta->uapsd_queues & BIT(i))) {
 			cmd->psd_type[NUM_ACCESS_CATEGORIES_COPY-1-i] =
 					CC33XX_PSD_UPSD_TRIGGER;
-		else
+		} else {
 			cmd->psd_type[NUM_ACCESS_CATEGORIES_COPY-1-i] =
 					CC33XX_PSD_LEGACY;
-
+		}
+	}
 
 	sta_rates = sta->deflink.supp_rates[wlvif->band];
-	if (sta->deflink.ht_cap.ht_supported)
+	if (sta->deflink.ht_cap.ht_supported) {
 		sta_rates |=
 			(sta->deflink.ht_cap.mcs.rx_mask[0] << HW_HT_RATES_OFFSET) |
 			(sta->deflink.ht_cap.mcs.rx_mask[1] << HW_MIMO_RATES_OFFSET);
+	}
 
 	cmd->supported_rates =
 		cpu_to_le32(cc33xx_tx_enabled_rates_get(wl, sta_rates,
@@ -1628,12 +1385,12 @@ int cc33xx_cmd_add_peer(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	if(sta->deflink.ht_cap.ht_supported)
 	{
 		cmd->ht_capabilities = cpu_to_le32(sta->deflink.ht_cap.cap);
-		cmd->ht_capabilities|= cpu_to_le32(CC33XX_HT_CAP_HT_OPERATION);
+		cmd->ht_capabilities |= cpu_to_le32(CC33XX_HT_CAP_HT_OPERATION);
 		cmd->ampdu_params = sta->deflink.ht_cap.ampdu_factor | sta->deflink.ht_cap.ampdu_density;
-
 	}
+
 	cmd->has_he= sta->deflink.he_cap.has_he;
-	cmd->mfp= sta->mfp;
+	cmd->mfp = sta->mfp;
 	ret = cc33xx_cmd_send(wl, CMD_ADD_PEER, cmd, sizeof(*cmd), 0);
 	if (ret < 0) {
 		cc33xx_error("failed to initiate cmd add peer");
@@ -1660,8 +1417,8 @@ int cc33xx_cmd_add_peer(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-int cc33xx_cmd_remove_peer(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			   u8 hlid)
+int cc33xx_cmd_remove_peer(struct cc33xx *wl,
+			   struct cc33xx_vif *wlvif, u8 hlid)
 {
 	struct cc33xx_cmd_remove_peer *cmd;
 	int ret;
@@ -1685,9 +1442,8 @@ int cc33xx_cmd_remove_peer(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 		goto out_free;
 	}
 
-	ret = cc33xx_wait_for_event(wl,
-		WLCORE_EVENT_PEER_REMOVE_COMPLETE,
-		&timeout);
+	ret = cc33xx_wait_for_event(wl, WLCORE_EVENT_PEER_REMOVE_COMPLETE,
+				    &timeout);
 
 	/*
 	 * We are ok with a timeout here. The event is sometimes not sent
@@ -1822,9 +1578,8 @@ int wlcore_cmd_regdomain_config_locked(struct cc33xx *wl)
 		goto out;
 	}
 
-	ret = cc33xx_wait_for_event(wl,
-		WLCORE_EVENT_DFS_CONFIG_COMPLETE,
-		&timeout);
+	ret = cc33xx_wait_for_event(wl, WLCORE_EVENT_DFS_CONFIG_COMPLETE,
+				    &timeout);
 
 	if (ret < 0 || timeout) {
 		cc33xx_error("reg domain conf %serror",
@@ -1873,58 +1628,6 @@ int cc33xx_cmd_config_fwlog(struct cc33xx *wl)
 	return ret;
 }
 
-int cc33xx_cmd_start_fwlog(struct cc33xx *wl)
-{
-	struct cc33xx_cmd_start_fwlog *cmd;
-	int ret = 0;
-
-	cc33xx_debug(DEBUG_CMD, "cmd start firmware logger");
-
-	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
-	if (!cmd) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	ret = cc33xx_cmd_send(wl, CMD_START_FWLOGGER, cmd, sizeof(*cmd), 0);
-	if (ret < 0) {
-		cc33xx_error("failed to send start firmware logger command");
-		goto out_free;
-	}
-
-out_free:
-	kfree(cmd);
-
-out:
-	return ret;
-}
-
-int cc33xx_cmd_stop_fwlog(struct cc33xx *wl)
-{
-	struct cc33xx_cmd_stop_fwlog *cmd;
-	int ret = 0;
-
-	cc33xx_debug(DEBUG_CMD, "cmd stop firmware logger");
-
-	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
-	if (!cmd) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	ret = cc33xx_cmd_send(wl, CMD_STOP_FWLOGGER, cmd, sizeof(*cmd), 0);
-	if (ret < 0) {
-		cc33xx_error("failed to send stop firmware logger command");
-		goto out_free;
-	}
-
-out_free:
-	kfree(cmd);
-
-out:
-	return ret;
-}
-
 static int cc33xx_cmd_roc(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			  u8 role_id, enum nl80211_band band, u8 channel)
 {
@@ -1957,7 +1660,6 @@ static int cc33xx_cmd_roc(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 		goto out_free;
 	}
 
-
 	ret = cc33xx_cmd_send(wl, CMD_REMAIN_ON_CHANNEL, cmd, sizeof(*cmd), 0);
 	if (ret < 0) {
 		cc33xx_error("failed to send ROC command");
@@ -2055,7 +1757,8 @@ int cc33xx_cmd_stop_channel_switch(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 
 	cmd->role_id = wlvif->role_id;
 
-	ret = cc33xx_cmd_send(wl, CMD_STOP_CHANNEL_SWICTH, cmd, sizeof(*cmd), 0);
+	ret = cc33xx_cmd_send(wl, CMD_STOP_CHANNEL_SWITCH,
+			      cmd, sizeof(*cmd), 0);
 	if (ret < 0) {
 		cc33xx_error("failed to stop channel switch command");
 		goto out_free;
@@ -2173,16 +1876,17 @@ int wlcore_cmd_generic_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-int cmd_channel_switch(struct cc33xx *wl,
-			      struct cc33xx_vif *wlvif,
-			      struct ieee80211_channel_switch *ch_switch)
+int cmd_channel_switch(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+		       struct ieee80211_channel_switch *ch_switch)
 {
 	struct cmd_channel_switch *cmd;
 	u32 supported_rates;
 	int ret;
 
-	cc33xx_debug(DEBUG_ACX, "cmd channel switch (count=%d)",
-		     ch_switch->count);
+	cc33xx_debug(DEBUG_ACX, "cmd channel switch (role_id=%d, "
+		     "new channel=%d, count=%d, block tx=%d",
+		     wlvif->role_id, ch_switch->chandef.chan->hw_value,
+		     ch_switch->count, ch_switch->block_tx);
 
 	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd) {
@@ -2271,8 +1975,7 @@ int cmd_set_cac(struct cc33xx *wl, struct cc33xx_vif *wlvif, bool start)
 		cmd->band = WLCORE_BAND_5GHZ;
 	cmd->bandwidth = wlcore_get_native_channel_type(wlvif->channel_type);
 
-	ret = cc33xx_cmd_send(wl,
-			      start ? CMD_CAC_START : CMD_CAC_STOP,
+	ret = cc33xx_cmd_send(wl, start ? CMD_CAC_START : CMD_CAC_STOP,
 			      cmd, sizeof(*cmd), 0);
 	if (ret < 0) {
 		cc33xx_error("failed to send cac command");
@@ -2332,7 +2035,8 @@ int cmd_get_device_info(struct cc33xx *wl, u8 *info_buffer, size_t buffer_len)
 	return ret;
 }
 
-int cmd_download_container_chunk(struct cc33xx *wl, u8 *chunk, size_t chunk_len, bool is_last_chunk)
+int cmd_download_container_chunk(struct cc33xx *wl, u8 *chunk,
+				 size_t chunk_len, bool is_last_chunk)
 {
 	struct cc33xx_cmd_container_download *cmd;
 	const size_t command_size = sizeof(*cmd) + chunk_len;
diff --git a/drivers/net/wireless/ti/cc33xx/cmd.h b/drivers/net/wireless/ti/cc33xx/cmd.h
index 5800fb9c280e..a57d8cfc6ef3 100644
--- a/drivers/net/wireless/ti/cc33xx/cmd.h
+++ b/drivers/net/wireless/ti/cc33xx/cmd.h
@@ -13,6 +13,7 @@
 
 #include "wlcore.h"
 
+
 struct acx_header;
 
 typedef enum {
@@ -21,11 +22,10 @@ typedef enum {
 } BufferSize_e;
 
 int cc33xx_set_max_buffer_size(struct cc33xx *wl, BufferSize_e max_buffer_size);
-
-int cc33xx_cmd_send(struct cc33xx *wl, u16 id, void *buf, size_t len,
-		    size_t res_len);
-int cc33xx_cmd_role_enable(struct cc33xx *wl, u8 *addr, u8 role_type,
-			   u8 *role_id);
+int cc33xx_cmd_send(struct cc33xx *wl, u16 id, void *buf,
+		    size_t len, size_t res_len);
+int cc33xx_cmd_role_enable(struct cc33xx *wl, u8 *addr,
+			   u8 role_type, u8 *role_id);
 int cc33xx_cmd_role_disable(struct cc33xx *wl, u8 *role_id);
 int cc33xx_cmd_role_start_sta(struct cc33xx *wl, struct cc33xx_vif *wlvif);
 int cc33xx_cmd_role_stop_sta(struct cc33xx *wl, struct cc33xx_vif *wlvif);
@@ -39,72 +39,52 @@ int cc33xx_cmd_test(struct cc33xx *wl, void *buf, size_t buf_len, u8 answer);
 int cc33xx_cmd_interrogate(struct cc33xx *wl, u16 id, void *buf,
 			   size_t cmd_len, size_t res_len);
 int cc33xx_cmd_debug_inter(struct cc33xx *wl, u16 id, void *buf,
-						size_t cmd_len, size_t res_len);
+			   size_t cmd_len, size_t res_len);
 int cc33xx_cmd_configure(struct cc33xx *wl, u16 id, void *buf, size_t len);
 int cc33xx_cmd_debug(struct cc33xx *wl, u16 id, void *buf, size_t len);
 int wlcore_cmd_configure_failsafe(struct cc33xx *wl, u16 id, void *buf,
 				  size_t len, unsigned long valid_rets);
 int cc33xx_cmd_ps_mode(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 		       u8 ps_mode, u16 auto_ps_timeout);
-int cc33xx_cmd_template_set(struct cc33xx *wl, u8 role_id,
-			    u16 template_id, void *buf, size_t buf_len,
-			    int index, u32 rates);
-int cc33xx_cmd_build_null_data(struct cc33xx *wl, struct cc33xx_vif *wlvif);
-struct sk_buff *cc33xx_cmd_build_ap_probe_req(struct cc33xx *wl,
-					      struct cc33xx_vif *wlvif,
-					      struct sk_buff *skb);
-int cc33xx_cmd_build_arp_rsp(struct cc33xx *wl, struct cc33xx_vif *wlvif);
-int cc33xx_build_qos_null_data(struct cc33xx *wl, struct ieee80211_vif *vif);
 int cc33xx_cmd_set_default_wep_key(struct cc33xx *wl, u8 id, u8 hlid);
 int cc33xx_cmd_set_sta_key(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			   u16 action, u8 id, u8 key_type,
 			   u8 key_size, const u8 *key, const u8 *addr,
 			   u32 tx_seq_32, u16 tx_seq_16);
 int cc33xx_cmd_set_ap_key(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			  u16 action, u8 id, u8 key_type,
-			  u8 key_size, const u8 *key, u8 hlid, u32 tx_seq_32,
-			  u16 tx_seq_16);
-int cc33xx_cmd_set_peer_state(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			      u8 hlid);
+			  u16 action, u8 id, u8 key_type, u8 key_size,
+			  const u8 *key, u8 hlid, u32 tx_seq_32, u16 tx_seq_16);
+int cc33xx_cmd_set_peer_state(struct cc33xx *wl,
+			      struct cc33xx_vif *wlvif, u8 hlid);
 int cc33xx_roc(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 role_id,
 	       enum nl80211_band band, u8 channel);
 int cc33xx_croc(struct cc33xx *wl, u8 role_id);
-
 int cc33xx_cmd_add_peer(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			struct ieee80211_sta *sta, u8 *hlid, u8 is_connected);
-
-int cc33xx_cmd_remove_peer(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			   u8 hlid);
+int cc33xx_cmd_remove_peer(struct cc33xx *wl,
+			   struct cc33xx_vif *wlvif, u8 hlid);
 void wlcore_set_pending_regdomain_ch(struct cc33xx *wl, u16 channel,
 				     enum nl80211_band band);
 int wlcore_cmd_regdomain_config_locked(struct cc33xx *wl);
 int wlcore_cmd_generic_cfg(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			   u8 feature, u8 enable, u8 value);
 int cc33xx_cmd_config_fwlog(struct cc33xx *wl);
-int cc33xx_cmd_start_fwlog(struct cc33xx *wl);
-int cc33xx_cmd_stop_fwlog(struct cc33xx *wl);
-int cc33xx_cmd_stop_channel_switch(struct cc33xx *wl,
-				   struct cc33xx_vif *wlvif);
-
+int cc33xx_cmd_stop_channel_switch(struct cc33xx *wl, struct cc33xx_vif *wlvif);
 int cc33xx_set_link(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 link);
 void cc33xx_clear_link(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 *hlid);
-
-u8 wlcore_get_native_channel_type(u8 nl_channel_type);
 int cc33xx_cmd_role_start_transceiver(struct cc33xx *wl, u8 role_id);
 int cc33xx_cmd_role_stop_transceiver(struct cc33xx *wl);
 int cc33xx_cmd_plt_enable(struct cc33xx *wl, u8 role_id);
 int cc33xx_cmd_plt_disable(struct cc33xx *wl);
-
 int cmd_channel_switch(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			      struct ieee80211_channel_switch *ch_switch);
+		       struct ieee80211_channel_switch *ch_switch);
 int cmd_dfs_master_restart(struct cc33xx *wl, struct cc33xx_vif *wlvif);
 int cmd_set_cac(struct cc33xx *wl, struct cc33xx_vif *wlvif, bool start);
-
 int cmd_set_bd_addr(struct cc33xx *wl, u8 *bd_addr);
 int cmd_get_device_info(struct cc33xx *wl, u8 *info_buffer, size_t buffer_len);
-int cmd_download_container_chunk(struct cc33xx *wl, u8 *chunk, size_t chunk_len, bool is_last_chunk);
+int cmd_download_container_chunk(struct cc33xx *wl, u8 *chunk,
+				 size_t chunk_len, bool is_last_chunk);
 
-int cc33xx_count_role_set_bits(unsigned long role_map);
 
 enum cc33xx_cmd {
 	CMD_EMPTY,
@@ -112,7 +92,7 @@ enum cc33xx_cmd {
 	CMD_SET_LINK_CONNECTION_STATE = 2,
 
 	CMD_CHANNEL_SWITCH = 3,
-	CMD_STOP_CHANNEL_SWICTH = 4,
+	CMD_STOP_CHANNEL_SWITCH = 4,
 
 	CMD_REMAIN_ON_CHANNEL = 5,
 	CMD_CANCEL_REMAIN_ON_CHANNEL = 6,
@@ -141,7 +121,7 @@ enum cc33xx_cmd {
 
 	CMD_AP_SET_BEACON_INFO = 21, /* Set AP beacon template */
 
-	// Managed sequence of sending deauth / disassoc frame
+	/* Managed sequence of sending deauth / disassoc frame */
 	CMD_SEND_DEAUTH_DISASSOC = 22,
 
 	CMD_SCHED_STATE_EVENT = 23,
@@ -163,11 +143,13 @@ enum cc33xx_cmd {
 	CMD_CONTAINER_DOWNLOAD = 36,
 	CMD_DOWNLOAD_INI_PARAMS = 37,
 	CMD_SET_BD_ADDR = 38,
+	CMD_BLE_COMMANDS = 39,
+
+	CMD_LAST_SUPPORTED_COMMAND,
 
-	CMD_LAST_SUPPORTED_COMMAND, // The following commands are legacy and are not yet supported
+	/* The following commands are legacy and are not yet supported */
 
 	CMD_SET_PS_MODE,
-	CMD_SET_TEMPLATE,
 	CMD_DFS_CHANNEL_CONFIG,
 	CMD_CONFIG_FWLOGGER,
 	CMD_START_FWLOGGER,
@@ -183,36 +165,8 @@ enum cc33xx_cmd {
 
 #define MAX_CMD_PARAMS 572
 
-enum cmd_templ {
-	CMD_TEMPL_NULL_DATA = 0,
-	CMD_TEMPL_BEACON,
-	CMD_TEMPL_CFG_PROBE_REQ_2_4,
-	CMD_TEMPL_CFG_PROBE_REQ_5,
-	CMD_TEMPL_PROBE_RESPONSE,
-	CMD_TEMPL_QOS_NULL_DATA,
-	CMD_TEMPL_PS_POLL,
-	CMD_TEMPL_DISCONNECT,
-	CMD_TEMPL_APP_PROBE_REQ_2_4_LEGACY,
-	CMD_TEMPL_APP_PROBE_REQ_5_LEGACY,
-	CMD_TEMPL_BAR,           /* for firmware internal use only */
-	CMD_TEMPL_CTS,           /*
-				  * For CTS-to-self (FastCTS) mechanism
-				  * for BT/WLAN coexistence (SoftGemini). */
-	CMD_TEMPL_AP_BEACON,
-	CMD_TEMPL_AP_PROBE_RESPONSE,
-	CMD_TEMPL_ARP_RSP,
-	CMD_TEMPL_DEAUTH_AP,
-	CMD_TEMPL_TEMPORARY,
-	CMD_TEMPL_LINK_MEASUREMENT_REPORT,
-	CMD_TEMPL_PROBE_REQ_2_4_PERIODIC,
-	CMD_TEMPL_PROBE_REQ_5_PERIODIC,
-
-	CMD_TEMPL_MAX = 0xff
-};
-
 /* unit ms */
 #define CC33XX_COMMAND_TIMEOUT     2000
-#define CC33XX_CMD_TEMPL_DFLT_SIZE 252
 #define CC33XX_CMD_TEMPL_MAX_SIZE  512
 #define CC33XX_EVENT_TIMEOUT       5000
 
@@ -254,9 +208,6 @@ enum {
 	MAX_COMMAND_STATUS
 };
 
-#define CMDMBOX_HEADER_LEN 4
-#define CMDMBOX_INFO_ELEM_HEADER_LEN 4
-
 enum {
 	BSS_TYPE_IBSS = 0,
 	BSS_TYPE_STA_BSS = 2,
@@ -272,8 +223,6 @@ struct cc33xx_cmd_role_enable {
 	u8 padding;
 } __packed;
 
-
-
 struct command_complete_header {
 	__le16 id;
 	__le16 status;
@@ -282,15 +231,12 @@ struct command_complete_header {
 	u8 data[0];
 } __packed;
 
-
-
 struct cc33xx_cmd_complete_role_enable {
-    struct command_complete_header header;
-    u8 role_id;
-    u8 padding[3];
+	struct command_complete_header header;
+	u8 role_id;
+	u8 padding[3];
 } __packed;
 
-
 struct cc33xx_cmd_role_disable {
 	struct cc33xx_cmd_header header;
 
@@ -385,29 +331,29 @@ struct cc33xx_cmd_role_start {
 } __packed;
 
 struct cc33xx_cmd_complete_role_start {
-    struct command_complete_header header;
-    union {
-        struct {
-            u8 hlid;
-            u8 session;
+	struct command_complete_header header;
+	union {
+		struct {
+			u8 hlid;
+			u8 session;
 			u8 padding[2];
-        } __packed sta;
-        struct {
-            /* The host link id for the AP's global queue */
-            u8 global_hlid;
-            /* The host link id for the AP's broadcast queue */
-            u8 broadcast_hlid;
-            u8 bcast_session_id;
-            u8 global_session_id;
-        } __packed ap;
-    };
+		} __packed sta;
+		struct {
+			/* The host link id for the AP's global queue */
+			u8 global_hlid;
+			/* The host link id for the AP's broadcast queue */
+			u8 broadcast_hlid;
+			u8 bcast_session_id;
+			u8 global_session_id;
+		} __packed ap;
+	};
 } __packed;
+
 struct cc33xx_cmd_role_stop {
 	struct cc33xx_cmd_header header;
 
 	u8 role_id;
 	u8 padding[3];
-
 } __packed;
 
 struct cmd_enabledisable_path {
@@ -417,28 +363,7 @@ struct cmd_enabledisable_path {
 	u8 padding[3];
 } __packed;
 
-struct cc33xx_cmd_template_set {
-	struct cc33xx_cmd_header header;
-
-	u8 role_id;
-	u8 template_type;
-	__le16 len;
-	u8 index;  /* relevant only for KLV_TEMPLATE type */
-	u8 padding[3];
-
-	__le32 enabled_rates;
-	u8 short_retry_limit;
-	u8 long_retry_limit;
-	u8 aflags;
-	u8 reserved;
-
-	u8 template_data[CC33XX_CMD_TEMPL_MAX_SIZE];
-} __packed;
-
-#define TIM_ELE_ID    5
-#define PARTIAL_VBM_MAX    251
-
-enum cc33xx_cmd_ps_mode {
+enum cc33xx_cmd_ps_mode_e {
 	STATION_AUTO_PS_MODE,   /* Dynamic Power Save */
 	STATION_ACTIVE_MODE,
 	STATION_POWER_SAVE_MODE
@@ -576,10 +501,10 @@ struct cc33xx_cmd_set_beacon_info
 {
 	struct cc33xx_cmd_header header;
 
-    u8    	role_id;
-    __le16	beacon_len;
-    u8   	beacon[MAX_SIZE_BEACON_TEMP];
-	u8		padding[3];
+	u8 role_id;
+	__le16 beacon_len;
+	u8 beacon[MAX_SIZE_BEACON_TEMP];
+	u8 padding[3];
 } __packed;
 
 struct cc33xx_cmd_add_peer {
@@ -596,11 +521,11 @@ struct cc33xx_cmd_add_peer {
 	u8 bss_index;
 	u8 sp_len;
 	u8 wmm;
-    __le32 ht_capabilities;
-    u8  ampdu_params;
+	__le32 ht_capabilities;
+	u8  ampdu_params;
 
-    /* HE peer support */
-    bool has_he;
+	/* HE peer support */
+	bool has_he;
 	bool mfp;
 	u8 padding[2];
 } __packed;
@@ -616,7 +541,6 @@ struct cc33xx_cmd_remove_peer {
 	u8 hlid;
 	u8 role_id;
 	u8 padding[2];
-
 } __packed;
 
 /*
@@ -688,14 +612,6 @@ struct cc33xx_cmd_config_fwlog {
 	u8 padding[3];
 } __packed;
 
-struct cc33xx_cmd_start_fwlog {
-	struct cc33xx_cmd_header header;
-} __packed;
-
-struct cc33xx_cmd_stop_fwlog {
-	struct cc33xx_cmd_header header;
-} __packed;
-
 struct cc33xx_cmd_stop_channel_switch {
 	struct cc33xx_cmd_header header;
 
@@ -802,4 +718,5 @@ struct cc33xx_cmd_get_device_info {
 	u8 device_info[700];
 } __packed;
 
+
 #endif /* __CC33XX_CMD_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/conf.h b/drivers/net/wireless/ti/cc33xx/conf.h
index a603e7c5d93f..93e440a88d81 100644
--- a/drivers/net/wireless/ti/cc33xx/conf.h
+++ b/drivers/net/wireless/ti/cc33xx/conf.h
@@ -12,13 +12,13 @@
 
 
 struct cc33xx_conf_header {
-	u32 magic;
-	u32 version;
-	u32 checksum;
-} __packed;
+	uint32_t magic;
+	uint32_t version;
+	uint32_t checksum;
+} __attribute__((__packed__));
 
 #define CC33XX_CONF_MAGIC	0x10e100ca
-#define CC33XX_CONF_VERSION	0x01070050
+#define CC33XX_CONF_VERSION	0x01070070
 #define CC33XX_CONF_MASK	0x0000ffff
 #define CC33X_CONF_SIZE	(sizeof(struct cc33xx_conf_file))
 
@@ -70,6 +70,23 @@ enum {
 	CONF_HW_RATE_INDEX_MAX        = CONF_HW_RATE_INDEX_MCS7,
 };
 
+enum {
+	CONF_PREAMBLE_TYPE_SHORT          = 0,
+    CONF_PREAMBLE_TYPE_LONG           = 1,
+    CONF_PREAMBLE_TYPE_OFDM           = 2,
+    CONF_PREAMBLE_TYPE_N_MIXED_MODE   = 3,
+    CONF_PREAMBLE_TYPE_GREENFIELD     = 4,
+    CONF_PREAMBLE_TYPE_AX_SU          = 5,
+    CONF_PREAMBLE_TYPE_AX_MU          = 6,
+    CONF_PREAMBLE_TYPE_AX_SU_ER       = 7,
+    CONF_PREAMBLE_TYPE_AX_TB          = 8,
+    CONF_PREAMBLE_TYPE_AX_TB_NDP_FB   = 9,
+    CONF_PREAMBLE_TYPE_AC_VHT         = 10,
+    CONF_PREAMBLE_TYPE_BE_EHT_MU      = 13,
+    CONF_PREAMBLE_TYPE_BE_EHT_TB      = 14,
+    CONF_PREAMBLE_TYPE_INVALID        = 0xFF
+};
+
 #define CONF_HW_RXTX_RATE_UNSUPPORTED 0xff
 
 
@@ -79,11 +96,11 @@ enum conf_rx_queue_type {
 };
 
 struct cc33xx_clk_cfg {
-	u32 n;
-	u32 m;
-	u32 p;
-	u32 q;
-	u8 swallow;
+	uint32_t n;
+	uint32_t m;
+	uint32_t p;
+	uint32_t q;
+	uint8_t swallow;
 };
 
 struct conf_rx_settings {
@@ -93,14 +110,14 @@ struct conf_rx_settings {
 	 *
 	 * Range: 0 - 0xFFFFFFFF
 	 */
-	u32 rx_msdu_life_time;
+	uint32_t rx_msdu_life_time;
 
 	/*
 	 * Packet detection threshold in the PHY.
 	 *
 	 * FIXME: details unknown.
 	 */
-	u32 packet_detection_threshold;
+	uint32_t packet_detection_threshold;
 
 	/*
 	 * The longest time the STA will wait to receive traffic from the AP
@@ -108,14 +125,14 @@ struct conf_rx_settings {
 	 *
 	 * Range: 0 - 200000
 	 */
-	u16 ps_poll_timeout;
+	uint16_t ps_poll_timeout;
 	/*
 	 * The longest time the STA will wait to receive traffic from the AP
 	 * after a frame has been sent from an UPSD enabled queue.
 	 *
 	 * Range: 0 - 200000
 	 */
-	u16 upsd_timeout;
+	uint16_t upsd_timeout;
 
 	/*
 	 * The number of octets in an MPDU, below which an RTS/CTS
@@ -123,7 +140,7 @@ struct conf_rx_settings {
 	 *
 	 * Range: 0 - 4096
 	 */
-	u16 rts_threshold;
+	uint16_t rts_threshold;
 
 	/*
 	 * The RX Clear Channel Assessment threshold in the PHY
@@ -132,38 +149,38 @@ struct conf_rx_settings {
 	 * Range: ENABLE_ENERGY_D  == 0x140A
 	 *        DISABLE_ENERGY_D == 0xFFEF
 	 */
-	u16 rx_cca_threshold;
+	uint16_t rx_cca_threshold;
 
 	/*
 	 * Occupied Rx mem-blocks number which requires interrupting the host
 	 * (0 = no buffering, 0xffff = disabled).
 	 *
-	 * Range: u16
+	 * Range: uint16_t
 	 */
-	u16 irq_blk_threshold;
+	uint16_t irq_blk_threshold;
 
 	/*
 	 * Rx packets number which requires interrupting the host
 	 * (0 = no buffering).
 	 *
-	 * Range: u16
+	 * Range: uint16_t
 	 */
-	u16 irq_pkt_threshold;
+	uint16_t irq_pkt_threshold;
 
 	/*
 	 * Max time in msec the FW may delay RX-Complete interrupt.
 	 *
 	 * Range: 1 - 100
 	 */
-	u16 irq_timeout;
+	uint16_t irq_timeout;
 
 	/*
 	 * The RX queue type.
 	 *
 	 * Range: RX_QUEUE_TYPE_RX_LOW_PRIORITY, RX_QUEUE_TYPE_RX_HIGH_PRIORITY,
 	 */
-	u8 queue_type;
-} __packed;
+	uint8_t queue_type;
+} __attribute__((__packed__));
 
 #define CONF_TX_MAX_RATE_CLASSES       10
 
@@ -223,21 +240,21 @@ struct conf_tx_rate_class {
 	 *
 	 * Range: CONF_HW_BIT_RATE_* bit mask
 	 */
-	u32 enabled_rates;
+	uint32_t enabled_rates;
 
 	/*
 	 * The dot11 short retry limit used for TX retries.
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u8 short_retry_limit;
+	uint8_t short_retry_limit;
 
 	/*
 	 * The dot11 long retry limit used for TX retries.
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u8 long_retry_limit;
+	uint8_t long_retry_limit;
 
 	/*
 	 * Flags controlling the attributes of TX transmission.
@@ -255,8 +272,8 @@ struct conf_tx_rate_class {
 	 *            2: Preamble Type - the type of the preamble to be used by
 	 *               the policy (0 - long preamble, 1 - short preamble.
 	 */
-	u8 aflags;
-} __packed;
+	uint8_t aflags;
+} __attribute__((__packed__));
 
 #define CONF_TX_MAX_AC_COUNT 4
 
@@ -281,31 +298,31 @@ struct conf_sig_weights {
 	/*
 	 * RSSI from beacons average weight.
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u8 rssi_bcn_avg_weight;
+	uint8_t rssi_bcn_avg_weight;
 
 	/*
 	 * RSSI from data average weight.
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u8 rssi_pkt_avg_weight;
+	uint8_t rssi_pkt_avg_weight;
 
 	/*
 	 * SNR from beacons average weight.
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u8 snr_bcn_avg_weight;
+	uint8_t snr_bcn_avg_weight;
 
 	/*
 	 * SNR from data average weight.
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u8 snr_pkt_avg_weight;
-} __packed;
+	uint8_t snr_pkt_avg_weight;
+} __attribute__((__packed__));
 
 
 struct conf_tx_ac_category {
@@ -314,68 +331,68 @@ struct conf_tx_ac_category {
 	 *
 	 * Range: enum conf_tx_ac
 	 */
-	u8 ac;
+	uint8_t ac;
 
 	/*
 	 * The contention window minimum size (in slots) for the access
 	 * class.
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u8 cw_min;
+	uint8_t cw_min;
 
 	/*
 	 * The contention window maximum size (in slots) for the access
 	 * class.
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u16 cw_max;
+	uint16_t cw_max;
 
 	/*
 	 * The AIF value (in slots) for the access class.
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u8 aifsn;
+	uint8_t aifsn;
 
 	/*
 	 * The TX Op Limit (in microseconds) for the access class.
 	 *
-	 * Range: u16
+	 * Range: uint16_t
 	 */
-	u16 tx_op_limit;
+	uint16_t tx_op_limit;
 
 	/*
 	* Is the MU EDCA configured
 	*
-	* Range: u8
+	* Range: uint8_t
 	*/
-	u8 is_mu_edca;
+	uint8_t is_mu_edca;
 
 	/*
 	*  The AIFSN value for the corresonding access class
 	*
-	* Range: u8
+	* Range: uint8_t
 	*/
-	u8 mu_edca_aifs;
+	uint8_t mu_edca_aifs;
 
 	/*
 	* The ECWmin and ECWmax value is indicating contention window maximum
 	* size (in slots) for the access
 	*
-	* Range: u8
+	* Range: uint8_t
 	*/
-	u8 mu_edca_ecw_min_max;
+	uint8_t mu_edca_ecw_min_max;
 
 	/*
 	* The MU EDCA timer (in microseconds) obtaining an EDCA TXOP
 	* for STA using MU EDCA parameters
 	*
-	* Range: u8
+	* Range: uint8_t
 	*/
-	u8 mu_edca_timer;
-} __packed;
+	uint8_t mu_edca_timer;
+} __attribute__((__packed__));
 
 #define CONF_TX_MAX_TID_COUNT 8
 
@@ -403,13 +420,13 @@ enum {
 
 
 struct conf_tx_tid {
-	u8 queue_id;
-	u8 channel_type;
-	u8 tsid;
-	u8 ps_scheme;
-	u8 ack_policy;
-	u32 apsd_conf[2];
-} __packed;
+	uint8_t queue_id;
+	uint8_t channel_type;
+	uint8_t tsid;
+	uint8_t ps_scheme;
+	uint8_t ack_policy;
+	uint32_t apsd_conf[2];
+} __attribute__((__packed__));
 
 struct conf_tx_settings {
 	/*
@@ -417,7 +434,7 @@ struct conf_tx_settings {
 	 *
 	 * Range: 0, 1
 	 */
-	u8 tx_energy_detection;
+	uint8_t tx_energy_detection;
 
 	/*
 	 * Configuration for rate classes for TX (currently only one
@@ -428,7 +445,7 @@ struct conf_tx_settings {
 	/*
 	 * Configuration for access categories for TX rate control.
 	 */
-	u8 ac_conf_count;
+	uint8_t ac_conf_count;
 	/*struct conf_tx_ac_category ac_conf[CONF_TX_MAX_AC_COUNT];*/
 	struct conf_tx_ac_category ac_conf0;
 	struct conf_tx_ac_category ac_conf1;
@@ -441,18 +458,18 @@ struct conf_tx_settings {
 	 * In AP-mode the hlids of unreachable stations are given in the
 	 * "sta_tx_retry_exceeded" member in the event mailbox.
 	 */
-	u8 max_tx_retries;
+	uint8_t max_tx_retries;
 
 	/*
 	 * AP-mode - after this number of seconds a connected station is
 	 * considered inactive.
 	 */
-	u16 ap_aging_period;
+	uint16_t ap_aging_period;
 
 	/*
 	 * Configuration for TID parameters.
 	 */
-	u8 tid_conf_count;
+	uint8_t tid_conf_count;
 	/* struct conf_tx_tid tid_conf[]; */
 	struct conf_tx_tid tid_conf0;
 	struct conf_tx_tid tid_conf1;
@@ -466,60 +483,60 @@ struct conf_tx_settings {
 	/*
 	 * The TX fragmentation threshold.
 	 *
-	 * Range: u16
+	 * Range: uint16_t
 	 */
-	u16 frag_threshold;
+	uint16_t frag_threshold;
 
 	/*
 	 * Max time in msec the FW may delay frame TX-Complete interrupt.
 	 *
-	 * Range: u16
+	 * Range: uint16_t
 	 */
-	u16 tx_compl_timeout;
+	uint16_t tx_compl_timeout;
 
 	/*
 	 * Completed TX packet count which requires to issue the TX-Complete
 	 * interrupt.
 	 *
-	 * Range: u16
+	 * Range: uint16_t
 	 */
-	u16 tx_compl_threshold;
+	uint16_t tx_compl_threshold;
 
 	/*
 	 * The rate used for control messages and scanning on the 2.4GHz band
 	 *
 	 * Range: CONF_HW_BIT_RATE_* bit mask
 	 */
-	u32 basic_rate;
+	uint32_t basic_rate;
 
 	/*
 	 * The rate used for control messages and scanning on the 5GHz band
 	 *
 	 * Range: CONF_HW_BIT_RATE_* bit mask
 	 */
-	u32 basic_rate_5;
+	uint32_t basic_rate_5;
 
 	/*
 	 * TX retry limits for templates
 	 */
-	u8 tmpl_short_retry_limit;
-	u8 tmpl_long_retry_limit;
+	uint8_t tmpl_short_retry_limit;
+	uint8_t tmpl_long_retry_limit;
 
 	/* Time in ms for Tx watchdog timer to expire */
-	u32 tx_watchdog_timeout;
+	uint32_t tx_watchdog_timeout;
 
 	/*
 	 * when a slow link has this much packets pending, it becomes a low
 	 * priority link, scheduling-wise
 	 */
-	u8 slow_link_thold;
+	uint8_t slow_link_thold;
 
 	/*
 	 * when a fast link has this much packets pending, it becomes a low
 	 * priority link, scheduling-wise
 	 */
-	u8 fast_link_thold;
-} __packed;
+	uint8_t fast_link_thold;
+} __attribute__((__packed__));
 
 enum {
 	CONF_WAKE_UP_EVENT_BEACON    = 0x00, /* Wake on every Beacon */
@@ -543,32 +560,32 @@ struct conf_bcn_filt_rule {
 	/*
 	 * IE number to which to associate a rule.
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u8 ie;
+	uint8_t ie;
 
 	/*
 	 * Rule to associate with the specific ie.
 	 *
 	 * Range: CONF_BCN_RULE_PASS_ON_*
 	 */
-	u8 rule;
+	uint8_t rule;
 
 	/*
 	 * OUI for the vendor specifie IE (221)
 	 */
-	u8 oui[3];
+	uint8_t oui[3];
 
 	/*
 	 * Type for the vendor specifie IE (221)
 	 */
-	u8 type;
+	uint8_t type;
 
 	/*
 	 * Version for the vendor specifie IE (221)
 	 */
-	u8 version[2];
-} __packed;
+	uint8_t version[2];
+} __attribute__((__packed__));
 
 
 enum conf_bcn_filt_mode {
@@ -587,12 +604,12 @@ struct conf_conn_settings {
 	 *
 	 * Range: CONF_BCN_FILT_MODE_*
 	 */
-	u8 bcn_filt_mode;
+	uint8_t bcn_filt_mode;
 
 	/*
 	 * Configure Beacon filter pass-thru rules.
 	 */
-	u8 bcn_filt_ie_count;
+	uint8_t bcn_filt_ie_count;
 	/*struct conf_bcn_filt_rule bcn_filt_ie[CONF_MAX_BCN_FILT_IE_COUNT];*/
 	/* struct conf_bcn_filt_rule bcn_filt_ie[32]; */
 	struct conf_bcn_filt_rule bcn_filt_ie0;
@@ -632,46 +649,46 @@ struct conf_conn_settings {
 	 * The number of consecutive beacons to lose, before the firmware
 	 * becomes out of synch.
 	 *
-	 * Range: u32
+	 * Range: uint32_t
 	 */
-	u32 synch_fail_thold;
+	uint32_t synch_fail_thold;
 
 	/*
 	 * After out-of-synch, the number of TU's to wait without a further
 	 * received beacon (or probe response) before issuing the BSS_EVENT_LOSE
 	 * event.
 	 *
-	 * Range: u32
+	 * Range: uint32_t
 	 */
-	u32 bss_lose_timeout;
+	uint32_t bss_lose_timeout;
 
 	/*
 	 * Beacon receive timeout.
 	 *
-	 * Range: u32
+	 * Range: uint32_t
 	 */
-	u32 beacon_rx_timeout;
+	uint32_t beacon_rx_timeout;
 
 	/*
 	 * Broadcast receive timeout.
 	 *
-	 * Range: u32
+	 * Range: uint32_t
 	 */
-	u32 broadcast_timeout;
+	uint32_t broadcast_timeout;
 
 	/*
 	 * Enable/disable reception of broadcast packets in power save mode
 	 *
 	 * Range: 1 - enable, 0 - disable
 	 */
-	u8 rx_broadcast_in_ps;
+	uint8_t rx_broadcast_in_ps;
 
 	/*
 	 * Consecutive PS Poll failures before sending event to driver
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u8 ps_poll_threshold;
+	uint8_t ps_poll_threshold;
 
 	/*
 	 * Configuration of signal average weights.
@@ -684,7 +701,7 @@ struct conf_conn_settings {
 	 *
 	 * Range: CONF_BET_MODE_*
 	 */
-	u8 bet_enable;
+	uint8_t bet_enable;
 
 	/*
 	 * Specifies the maximum number of consecutive beacons that may be
@@ -694,7 +711,7 @@ struct conf_conn_settings {
 	 *
 	 * Range 0 - 255
 	 */
-	u8 bet_max_consecutive;
+	uint8_t bet_max_consecutive;
 
 	/*
 	 * Specifies the maximum number of times to try PSM entry if it fails
@@ -702,7 +719,7 @@ struct conf_conn_settings {
 	 *
 	 * Range 0 - 255
 	 */
-	u8 psm_entry_retries;
+	uint8_t psm_entry_retries;
 
 	/*
 	 * Specifies the maximum number of times to try PSM exit if it fails
@@ -710,7 +727,7 @@ struct conf_conn_settings {
 	 *
 	 * Range 0 - 255
 	 */
-	u8 psm_exit_retries;
+	uint8_t psm_exit_retries;
 
 	/*
 	 * Specifies the maximum number of times to try transmit the PSM entry
@@ -718,19 +735,19 @@ struct conf_conn_settings {
 	 *
 	 * Range 0 - 255
 	 */
-	u8 psm_entry_nullfunc_retries;
+	uint8_t psm_entry_nullfunc_retries;
 
 	/*
 	 * Specifies the dynamic PS timeout in ms that will be used
 	 * by the FW when in AUTO_PS mode
 	 */
-	u16 dynamic_ps_timeout;
+	uint16_t dynamic_ps_timeout;
 
 	/*
 	 * Specifies whether dynamic PS should be disabled and PSM forced.
 	 * This is required for certain WiFi certification tests.
 	 */
-	u8 forced_ps;
+	uint8_t forced_ps;
 
 	/*
 	 *
@@ -739,35 +756,35 @@ struct conf_conn_settings {
 	 *
 	 * Range: 1000 - 3600000
 	 */
-	u32 keep_alive_interval;
+	uint32_t keep_alive_interval;
 
 	/*
 	 * Maximum listen interval supported by the driver in units of beacons.
 	 *
-	 * Range: u16
+	 * Range: uint16_t
 	 */
-	u8 max_listen_interval;
+	uint8_t max_listen_interval;
 
 	/*
 	 * Default sleep authorization for a new STA interface. This determines
 	 * whether we can go to ELP.
 	 */
-	u8 sta_sleep_auth;
+	uint8_t sta_sleep_auth;
 
 	/*
 	 * Default RX BA Activity filter configuration
 	 */
-	u8 suspend_rx_ba_activity;
-} __packed;
+	uint8_t suspend_rx_ba_activity;
+} __attribute__((__packed__));
 
 
 struct conf_itrim_settings {
 	/* enable dco itrim */
-	u8 enable;
+	uint8_t enable;
 
 	/* moderation timeout in microsecs from the last TX */
-	u32 timeout;
-} __packed;
+	uint32_t timeout;
+} __attribute__((__packed__));
 
 enum conf_fast_wakeup {
 	CONF_FAST_WAKEUP_ENABLE,
@@ -780,15 +797,15 @@ struct conf_pm_config_settings {
 	 *
 	 * Range: 0 - 30000 us
 	 */
-	u32 host_clk_settling_time;
+	uint32_t host_clk_settling_time;
 
 	/*
 	 * Host fast wakeup support
 	 *
 	 * Range: enum conf_fast_wakeup
 	 */
-	u8 host_fast_wakeup_support;
-} __packed;
+	uint8_t host_fast_wakeup_support;
+} __attribute__((__packed__));
 
 struct conf_roam_trigger_settings {
 	/*
@@ -796,45 +813,45 @@ struct conf_roam_trigger_settings {
 	 *
 	 * Range: 0 - 60000 ms
 	 */
-	u16 trigger_pacing;
+	uint16_t trigger_pacing;
 
 	/*
 	 * The weight for rssi/beacon average calculation
 	 *
 	 * Range: 0 - 255
 	 */
-	u8 avg_weight_rssi_beacon;
+	uint8_t avg_weight_rssi_beacon;
 
 	/*
 	 * The weight for rssi/data frame average calculation
 	 *
 	 * Range: 0 - 255
 	 */
-	u8 avg_weight_rssi_data;
+	uint8_t avg_weight_rssi_data;
 
 	/*
 	 * The weight for snr/beacon average calculation
 	 *
 	 * Range: 0 - 255
 	 */
-	u8 avg_weight_snr_beacon;
+	uint8_t avg_weight_snr_beacon;
 
 	/*
 	 * The weight for snr/data frame average calculation
 	 *
 	 * Range: 0 - 255
 	 */
-	u8 avg_weight_snr_data;
-} __packed;
+	uint8_t avg_weight_snr_data;
+} __attribute__((__packed__));
 
 struct conf_scan_settings {
 	/*
 	 * The minimum time to wait on each channel for active scans
 	 * This value will be used whenever there's a connected interface.
 	 *
-	 * Range: u32 tu/1000
+	 * Range: uint32_t tu/1000
 	 */
-	u32 min_dwell_time_active;
+	uint32_t min_dwell_time_active;
 
 	/*
 	 * The maximum time to wait on each channel for active scans
@@ -842,9 +859,9 @@ struct conf_scan_settings {
 	 * connected interface. It shouldn't exceed 30000 (~30ms) to avoid
 	 * possible interference of voip traffic going on while scanning.
 	 *
-	 * Range: u32 tu/1000
+	 * Range: uint32_t tu/1000
 	 */
-	u32 max_dwell_time_active;
+	uint32_t max_dwell_time_active;
 
 	/* The minimum time to wait on each channel for active scans
 	 * when it's possible to have longer scan dwell times.
@@ -852,40 +869,40 @@ struct conf_scan_settings {
 	 * Longer dwell times improve detection of networks within a
 	 * single scan.
 	 *
-	 * Range: u32 tu/1000
+	 * Range: uint32_t tu/1000
 	 */
-	u32 min_dwell_time_active_long;
+	uint32_t min_dwell_time_active_long;
 
 	/* The maximum time to wait on each channel for active scans
 	 * when it's possible to have longer scan dwell times.
 	 * See min_dwell_time_active_long
 	 *
-	 * Range: u32 tu/1000
+	 * Range: uint32_t tu/1000
 	 */
-	u32 max_dwell_time_active_long;
+	uint32_t max_dwell_time_active_long;
 
 	/* time to wait on the channel for passive scans (in TU/1000) */
-	u32 dwell_time_passive;
+	uint32_t dwell_time_passive;
 
 	/* time to wait on the channel for DFS scans (in TU/1000) */
-	u32 dwell_time_dfs;
+	uint32_t dwell_time_dfs;
 
 	/*
 	 * Number of probe requests to transmit on each active scan channel
 	 *
-	 * Range: u8
+	 * Range: uint8_t
 	 */
-	u16 num_probe_reqs;
+	uint16_t num_probe_reqs;
 
 	/*
 	 * Scan trigger (split scan) timeout. The FW will split the scan
 	 * operation into slices of the given time and allow the FW to schedule
 	 * other tasks in between.
 	 *
-	 * Range: u32 Microsecs
+	 * Range: uint32_t Microsecs
 	 */
-	u32 split_scan_timeout;
-} __packed;
+	uint32_t split_scan_timeout;
+} __attribute__((__packed__));
 
 struct conf_sched_scan_settings {
 	/*
@@ -895,72 +912,72 @@ struct conf_sched_scan_settings {
 	 * The maximum dwell time is calculated according to this:
 	 * max_dwell_time = min_dwell_time + max_dwell_time_delta
 	 */
-	u32 base_dwell_time;
+	uint32_t base_dwell_time;
 
 	/* The delta between the min dwell time and max dwell time for
 	 * active scans (in TU/1000s). The max dwell time is used by the FW once
 	 * traffic is detected on the channel.
 	 */
-	u32 max_dwell_time_delta;
+	uint32_t max_dwell_time_delta;
 
 	/* Delta added to min dwell time per each probe in 2.4 GHz (TU/1000) */
-	u32 dwell_time_delta_per_probe;
+	uint32_t dwell_time_delta_per_probe;
 
 	/* Delta added to min dwell time per each probe in 5 GHz (TU/1000) */
-	u32 dwell_time_delta_per_probe_5;
+	uint32_t dwell_time_delta_per_probe_5;
 
 	/* time to wait on the channel for passive scans (in TU/1000) */
-	u32 dwell_time_passive;
+	uint32_t dwell_time_passive;
 
 	/* time to wait on the channel for DFS scans (in TU/1000) */
-	u32 dwell_time_dfs;
+	uint32_t dwell_time_dfs;
 
 	/* number of probe requests to send on each channel in active scans */
-	u8 num_probe_reqs;
+	uint8_t num_probe_reqs;
 
 	/* RSSI threshold to be used for filtering */
-	s8 rssi_threshold;
+	int8_t rssi_threshold;
 
 	/* SNR threshold to be used for filtering */
-	s8 snr_threshold;
+	int8_t snr_threshold;
 
 	/*
 	 * number of short intervals scheduled scan cycles before
 	 * switching to long intervals
 	 */
-	u8 num_short_intervals;
+	uint8_t num_short_intervals;
 
 	/* interval between each long scheduled scan cycle (in ms) */
-	u16 long_interval;
-} __packed;
+	uint16_t long_interval;
+} __attribute__((__packed__));
 
 struct conf_ht_setting {
-	u8 rx_ba_win_size;
-	u8 tx_ba_win_size;
-	u16 inactivity_timeout;
+	uint8_t rx_ba_win_size;
+	uint8_t tx_ba_win_size;
+	uint16_t inactivity_timeout;
 
 	/* bitmap of enabled TIDs for TX BA sessions */
-	u8 tx_ba_tid_bitmap;
+	uint8_t tx_ba_tid_bitmap;
 
 	/* DEFAULT / WIDE / SISO20 */
-	u8 mode;
-} __packed;
+	uint8_t mode;
+} __attribute__((__packed__));
 
 struct conf_memory_settings {
 	/* Number of stations supported in IBSS mode */
-	u8 num_stations;
+	uint8_t num_stations;
 
 	/* Number of ssid profiles used in IBSS mode */
-	u8 ssid_profiles;
+	uint8_t ssid_profiles;
 
 	/* Number of memory buffers allocated to rx pool */
-	u8 rx_block_num;
+	uint8_t rx_block_num;
 
 	/* Minimum number of blocks allocated to tx pool */
-	u8 tx_min_block_num;
+	uint8_t tx_min_block_num;
 
 	/* Disable/Enable dynamic memory */
-	u8 dynamic_memory;
+	uint8_t dynamic_memory;
 
 	/*
 	 * Minimum required free tx memory blocks in order to assure optimum
@@ -968,7 +985,7 @@ struct conf_memory_settings {
 	 *
 	 * Range: 0-120
 	 */
-	u8 min_req_tx_blocks;
+	uint8_t min_req_tx_blocks;
 
 	/*
 	 * Minimum required free rx memory blocks in order to assure optimum
@@ -976,24 +993,24 @@ struct conf_memory_settings {
 	 *
 	 * Range: 0-120
 	 */
-	u8 min_req_rx_blocks;
+	uint8_t min_req_rx_blocks;
 
 	/*
 	 * Minimum number of mem blocks (free+used) guaranteed for TX
 	 *
 	 * Range: 0-120
 	 */
-	u8 tx_min;
-} __packed;
+	uint8_t tx_min;
+} __attribute__((__packed__));
 
 
 struct conf_rx_streaming_settings {
 	/*
 	 * RX Streaming duration (in msec) from last tx/rx
 	 *
-	 * Range: u32
+	 * Range: uint32_t
 	 */
-	u32 duration;
+	uint32_t duration;
 
 	/*
 	 * Bitmap of tids to be polled during RX streaming.
@@ -1001,77 +1018,77 @@ struct conf_rx_streaming_settings {
 	 *
 	 * Range: 0x1-0xff
 	 */
-	u8 queues;
+	uint8_t queues;
 
 	/*
 	 * RX Streaming interval.
 	 * (Note:this value is also used as the rx streaming timeout)
 	 * Range: 0 (disabled), 10 - 100
 	 */
-	u8 interval;
+	uint8_t interval;
 
 	/*
 	 * enable rx streaming also when there is no coex activity
 	 */
-	u8 always;
-} __packed;
+	uint8_t always;
+} __attribute__((__packed__));
 
 struct conf_fwlog {
 	/* Continuous or on-demand */
-	u8 mode;
+	uint8_t mode;
 
 	/*
 	 * Number of memory blocks dedicated for the FW logger
 	 *
 	 * Range: 2-16, or 0 to disable the FW logger
 	 */
-	u8 mem_blocks;
+	uint8_t mem_blocks;
 
 	/* Minimum log level threshold */
-	u8 severity;
+	uint8_t severity;
 
 	/* Include/exclude timestamps from the log messages */
-	u8 timestamp;
+	uint8_t timestamp;
 
 	/* See enum cc33xx_fwlogger_output */
-	u8 output;
+	uint8_t output;
 
 	/* Regulates the frequency of log messages */
-	u8 threshold;
-} __packed;
+	uint8_t threshold;
+} __attribute__((__packed__));
 
 #define ACX_RATE_MGMT_NUM_OF_RATES 13
 struct conf_rate_policy_settings {
-	u16 rate_retry_score;
-	u16 per_add;
-	u16 per_th1;
-	u16 per_th2;
-	u16 max_per;
-	u8 inverse_curiosity_factor;
-	u8 tx_fail_low_th;
-	u8 tx_fail_high_th;
-	u8 per_alpha_shift;
-	u8 per_add_shift;
-	u8 per_beta1_shift;
-	u8 per_beta2_shift;
-	u8 rate_check_up;
-	u8 rate_check_down;
-	u8 rate_retry_policy[13];
-} __packed;
+	uint16_t rate_retry_score;
+	uint16_t per_add;
+	uint16_t per_th1;
+	uint16_t per_th2;
+	uint16_t max_per;
+	uint8_t inverse_curiosity_factor;
+	uint8_t tx_fail_low_th;
+	uint8_t tx_fail_high_th;
+	uint8_t per_alpha_shift;
+	uint8_t per_add_shift;
+	uint8_t per_beta1_shift;
+	uint8_t per_beta2_shift;
+	uint8_t rate_check_up;
+	uint8_t rate_check_down;
+	uint8_t rate_retry_policy[13];
+} __attribute__((__packed__));
 
 struct conf_hangover_settings {
-	u32 recover_time;
-	u8 hangover_period;
-	u8 dynamic_mode;
-	u8 early_termination_mode;
-	u8 max_period;
-	u8 min_period;
-	u8 increase_delta;
-	u8 decrease_delta;
-	u8 quiet_time;
-	u8 increase_time;
-	u8 window_size;
-} __packed;
+	uint32_t recover_time;
+	uint8_t hangover_period;
+	uint8_t dynamic_mode;
+	uint8_t early_termination_mode;
+	uint8_t max_period;
+	uint8_t min_period;
+	uint8_t increase_delta;
+	uint8_t decrease_delta;
+	uint8_t quiet_time;
+	uint8_t increase_time;
+	uint8_t window_size;
+} __attribute__((__packed__));
 
 
 enum {
@@ -1104,34 +1121,34 @@ struct conf_ap_sleep_settings {
 	/* Duty Cycle (20-80% of staying Awake) for IDLE AP
 	 * (0: disable)
 	 */
-	u8 idle_duty_cycle;
+	uint8_t idle_duty_cycle;
 	/* Duty Cycle (20-80% of staying Awake) for Connected AP
 	 * (0: disable)
 	 */
-	u8 connected_duty_cycle;
+	uint8_t connected_duty_cycle;
 	/* Maximum stations that are allowed to be connected to AP
 	 *  (255: no limit)
 	 */
-	u8 max_stations_thresh;
+	uint8_t max_stations_thresh;
 	/* Timeout till enabling the Sleep Mechanism after data stops
 	 * [unit: 100 msec]
 	 */
-	u8 idle_conn_thresh;
-} __packed;
+	uint8_t idle_conn_thresh;
+} __attribute__((__packed__));
 
 
-#define CHANNELS_COUNT 14
+#define CHANNELS_COUNT 39 /* 14 2.4GHz channels, 25 5GHz channels*/
 #define PER_CHANNEL_REG_RULE_BYTES 13
-#define REG_RULES_COUNT (CHANNELS_COUNT * PER_CHANNEL_REG_RULE_BYTES) /* 182 */
+#define REG_RULES_COUNT (CHANNELS_COUNT * PER_CHANNEL_REG_RULE_BYTES) /* 507 */
 
 
 /* TX Power limitation for a channel, used for reg domain */
 struct conf_channel_power_limit {
-	u32 reg_lim_0;
-	u32 reg_lim_1;
-	u32 reg_lim_2;
-	u8  reg_lim_3;
-} __packed;
+	uint32_t reg_lim_0;
+	uint32_t reg_lim_1;
+	uint32_t reg_lim_2;
+	uint8_t  reg_lim_3;
+} __attribute__((__packed__));
 
 struct conf_coex_configuration {
 	/*
@@ -1139,13 +1156,13 @@ struct conf_coex_configuration {
 	 *
 	 * Range: 1 - YES, 0 - NO
 	 */
-	u8 Disable_coex;
+	uint8_t Disable_coex;
 	/*
 	 * Yes/No Choose if External SoC entity is connected
 	 *
 	 * Range: 1 - YES, 0 - NO
 	 */
-	u8 is_Ext_soc_enable;
+	uint8_t is_Ext_soc_enable;
 	/*
 	 * External SoC grant polarity
 	 *
@@ -1153,7 +1170,7 @@ struct conf_coex_configuration {
 	 *
 	 * 1 - Active High (Default)
 	 */
-	u8 ext_soc_grant_polarity;
+	uint8_t ext_soc_grant_polarity;
 	/*
 	 * External SoC priority polarity
 	 *
@@ -1161,7 +1178,7 @@ struct conf_coex_configuration {
 	 *
 	 * 1 - Active High
 	 */
-	u8 ext_soc_priority_polarity;
+	uint8_t ext_soc_priority_polarity;
 	/*
 	 * External SoC request polarity
 	 *
@@ -1169,59 +1186,151 @@ struct conf_coex_configuration {
 	 *
 	 * 1 - Active High
 	 */
-	u8 ext_soc_request_polarity;
-	u16 ext_soc_min_grant_time;
-	u16 ext_soc_max_grant_time;
+	uint8_t ext_soc_request_polarity;
+	uint16_t ext_soc_min_grant_time;
+	uint16_t ext_soc_max_grant_time;
 	/*
 	 * Range: 0 - 20 us
 	 */
-	u8 ext_soc_t2_time;
-
-	u8 ext_soc_to_wifi_grant_delay;
-	u8 ext_soc_to_ble_grant_delay;
-} __packed;
+	uint8_t ext_soc_t2_time;
+
+	uint8_t ext_soc_to_wifi_grant_delay;
+	uint8_t ext_soc_to_ble_grant_delay;
+} __attribute__((__packed__));
+
+struct conf_iomux_configuration {
+    /*
+     * For any iomux pull value:
+     * 1: Pull up
+     * 2: Pull down
+     * 3: Pull disable
+     * ff: Default value set by HW
+     * ANY other value is invalid
+     */
+    uint8_t slow_clock_in_pull_val;
+    uint8_t sdio_clk_pull_val;
+    uint8_t sdio_cmd_pull_val;
+    uint8_t sdio_d0_pull_val;
+    uint8_t sdio_d1_pull_val;
+    uint8_t sdio_d2_pull_val;
+    uint8_t sdio_d3_pull_val;
+    uint8_t host_irq_wl_pull_val;
+    uint8_t uart1_tx_pull_val;
+    uint8_t uart1_rx_pull_val;
+    uint8_t uart1_cts_pull_val;
+    uint8_t uart1_rts_pull_val;
+    uint8_t coex_priority_pull_val;
+    uint8_t coex_req_pull_val;
+    uint8_t coex_grant_pull_val;
+    uint8_t host_irq_ble_pull_val;
+    uint8_t fast_clk_req_pull_val;
+    uint8_t ant_sel_pull_val;
+} __attribute__((__packed__));
+
+struct conf_ant_diversity {
+    /*
+     * First beacons after antenna switch.
+     * In this window we asses our satisfaction from the new antenna.
+     */
+    uint8_t fast_switching_window;
+    /*
+     * Deltas above this threshold between the curiosity score and
+     * the average RSSI will lead to antenna switch.
+     */
+    uint8_t rssi_delta_for_switching;
+    /*
+     * Used in the first beacons after antenna switch:
+     * Deltas above this threshold between the average RSSI and
+     * the curiosity score will make us switch back the antennas.
+     */
+    uint8_t rssi_delta_for_fast_switching;
+    /*
+     * Curiosity punishment in beacon timeout after an antenna switch.
+     */
+    uint8_t curiosity_punish;
+	/*
+     * Curiosity raise in beacon timeout not after an antenna switch.
+     */
+    uint8_t curiosity_raise;
+    /*
+     * Used for the average RSSI punishment in beacon timeout
+     * not after antenna switch.
+     */
+    uint8_t consecutive_missed_beacons_threshold;
+    /*
+     * Used in the curiosity metric.
+     */
+    uint8_t compensation_log;
+    /*
+     * Used in the average RSSI metric.
+     */
+    uint8_t log_alpha;
+	/*
+     * Curiosity initialization score.
+     */
+    int8_t initial_curiosity;
+	/*
+     * MR configuration: should the AP follow the STA antenna or use the default antenna.
+     */
+    uint8_t ap_follows_sta;
+	/*
+     * MR configuration: should the BLE follow the STA antenna or use the default antenna.
+     */
+    uint8_t ble_follows_sta;
+	/*
+     * The antenna to use when the diversity mechanism is not in charge.
+     */
+    uint8_t default_antenna;
+} __attribute__((__packed__));
 
 struct cc33xx_core_conf {
-	u8 enable_5ghz;
-	u8 enable_ble;
-	u8 enable_at_test_debug; //only for at-test chips, debug mode (ignoring disable efuses)
-	u8 disable_beamforming_fftp; // for PG version 2.0
-	u32 BleUartBaudrate;
-	u8 enable_FlowCtrl;
-	u8 listen_interval;
-	u8 wake_up_event;
-	u8 suspend_listen_interval;
-	u8 suspend_wake_up_event;
-	/*
-	 * Per channel power limitations, will be addressed per channel as
-	 * described in struct conf_channel_power_limit
-	 */
-	u8 per_channel_power_limit[182];
-	u32 internalSlowclk_wakeupEarlier;
-	u32 internalSlowclk_OpenWindowLonger;
-	u32 externalSlowclk_wakeupEarlier;
-	u32 externalSlowclk_OpenWindowLonger;
+	uint8_t enable_5ghz;
+	uint8_t enable_ble;
+	uint8_t enable_at_test_debug; //only for at-test chips, debug mode (ignoring disable efuses)
+	uint8_t disable_beamforming_fftp; // for PG version 2.0
+	uint32_t BleUartBaudrate;
+	uint8_t enable_FlowCtrl;
+	uint8_t listen_interval;
+	uint8_t wake_up_event;
+	uint8_t suspend_listen_interval;
+	uint8_t suspend_wake_up_event;
+	uint8_t per_channel_power_limit[507]; // per channel power limitations
+	uint32_t internalSlowclk_wakeupEarlier;
+	uint32_t internalSlowclk_OpenWindowLonger;
+	uint32_t externalSlowclk_wakeupEarlier;
+	uint32_t externalSlowclk_OpenWindowLonger;
 	struct conf_coex_configuration coex_configuration;
 	/* Prevent HW recovery. FW will remain stuck. */
-	u8 no_recovery;
-	u8 disable_logger;
-	u8 mixed_mode_support;
-	u8 sramLdo_voltageTrimming;
-} __packed;
+	uint8_t no_recovery;
+	uint8_t disable_logger;
+	uint8_t mixed_mode_support;
+	uint8_t sramLdo_voltageTrimming;
+	uint32_t xtal_SettlingTime_usec;
+	struct conf_ant_diversity ant_diversity;
+	struct conf_iomux_configuration iomux_configuration;
+} __attribute__((__packed__));
 
 struct cc33xx_mac_conf {
-	u8 ps_scheme;
-	u8 he_enable;
-	u8 ApMaxNumStations;
-} __packed;
+	uint8_t ps_scheme;
+	uint8_t he_enable;
+	uint8_t ApMaxNumStations;
+} __attribute__((__packed__));
 
 struct cc33xx_phy_conf {
-	u8 insertion_loss[2];
-	u8 ant_gain[2];
-	u8 ble_ch_lim_1M[40];
-	u8 ble_ch_lim_2M[40];
-	u8 one_time_calibration_only;
-} __packed;
+	uint8_t insertion_loss_2_4GHz[2];
+	uint8_t insertion_loss_5GHz[2];
+	uint8_t reserved_0[2];
+	uint8_t ant_gain_2_4GHz[2];
+	uint8_t ant_gain_5GHz[2];
+	uint8_t reserved_1[2];
+	uint8_t ble_ch_lim_1M[40];
+	uint8_t ble_ch_lim_2M[40];
+	uint8_t one_time_calibration_only;
+	uint8_t is_diplexer_present;
+	uint8_t num_of_antennas;
+	uint8_t reg_domain;
+	uint16_t calib_period;
+} __attribute__((__packed__));
 
 struct cc33xx_host_conf {
 	struct conf_rx_settings rx;
@@ -1240,7 +1349,7 @@ struct cc33xx_host_conf {
 	struct conf_hangover_settings hangover;
 	struct conf_ap_sleep_settings ap_sleep;
 
-} __packed;
+} __attribute__((__packed__));
 
 
 struct cc33xx_conf_file {
@@ -1249,6 +1358,6 @@ struct cc33xx_conf_file {
 	struct cc33xx_mac_conf mac;
 	struct cc33xx_core_conf core;
 	struct cc33xx_host_conf host_conf;
-} __packed;
+} __attribute__((__packed__));
 
 #endif
diff --git a/drivers/net/wireless/ti/cc33xx/debug.h b/drivers/net/wireless/ti/cc33xx/debug.h
index a84bb8063579..5346c6d9e7a0 100644
--- a/drivers/net/wireless/ti/cc33xx/debug.h
+++ b/drivers/net/wireless/ti/cc33xx/debug.h
@@ -11,8 +11,7 @@
 #ifndef __DEBUG_H__
 #define __DEBUG_H__
 
-#include <linux/bitops.h>
-#include <linux/printk.h>
+
 
 #define DRIVER_NAME "wlcore"
 #define DRIVER_PREFIX DRIVER_NAME ": "
@@ -75,7 +74,7 @@ extern u32 cc33xx_debug_level;
 			printk(KERN_DEBUG pr_fmt(DRIVER_PREFIX fmt "\n"), \
 			       ##arg); \
 	} while (0)
-#endif
+#endif /* CONFIG_DYNAMIC_DEBUG */
 
 #define cc33xx_dump(level, prefix, buf, len)				      \
 	do {								      \
@@ -97,4 +96,5 @@ extern u32 cc33xx_debug_level;
 					true);				      \
 	} while (0)
 
+
 #endif /* __DEBUG_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/debugfs.c b/drivers/net/wireless/ti/cc33xx/debugfs.c
index f83767ec6ff7..d4395d8557eb 100644
--- a/drivers/net/wireless/ti/cc33xx/debugfs.c
+++ b/drivers/net/wireless/ti/cc33xx/debugfs.c
@@ -8,13 +8,6 @@
  */
 
 #include "debugfs.h"
-
-#include <linux/skbuff.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-
-#include "wlcore.h"
-#include "debug.h"
 #include "acx.h"
 #include "ps.h"
 #include "io.h"
@@ -23,9 +16,9 @@
 
 
 #define CC33XX_DEBUGFS_FWSTATS_FILE(a, b, c) \
-	DEBUGFS_FWSTATS_FILE(a, b, c, cc33xx_acx_statistics)
+	DEBUGFS_FWSTATS_FILE(a, b, c, cc33xx_acx_statistics_t)
 #define CC33XX_DEBUGFS_FWSTATS_FILE_ARRAY(a, b, c) \
-	DEBUGFS_FWSTATS_FILE_ARRAY(a, b, c, cc33xx_acx_statistics)
+	DEBUGFS_FWSTATS_FILE_ARRAY(a, b, c, cc33xx_acx_statistics_t)
 
 
 CC33XX_DEBUGFS_FWSTATS_FILE(error, error_frame_non_ctrl, "%u");
@@ -186,18 +179,11 @@ struct cc33xx_cmd_dfs_radar_debug {
 	u8 padding[3];
 } __packed;
 
-
 /* ms */
 #define CC33XX_DEBUGFS_STATS_LIFETIME 1000
-
-#define WLCORE_MAX_BLOCK_SIZE ((size_t)(4*PAGE_SIZE))
-
 #define MAX_VERSIONS_LEN	59
-
 #define MAX_VERSIONS_EXTENDED_LEN	86
 
-
-
 int cc33xx_cmd_radar_detection_debug(struct cc33xx *wl, u8 channel)
 {
 	struct cc33xx_cmd_dfs_radar_debug *cmd;
@@ -264,8 +250,8 @@ static const struct file_operations conf_ops = {
 };
 
 static ssize_t clear_fw_stats_write(struct file *file,
-			      const char __user *user_buf,
-			      size_t count, loff_t *ppos)
+				    const char __user *user_buf,
+				    size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	int ret;
@@ -326,8 +312,8 @@ static const struct file_operations radar_detection_ops = {
 };
 
 static ssize_t dynamic_fw_traces_write(struct file *file,
-					const char __user *user_buf,
-					size_t count, loff_t *ppos)
+				       const char __user *user_buf,
+				       size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	unsigned long value;
@@ -353,9 +339,8 @@ static ssize_t dynamic_fw_traces_write(struct file *file,
 	return count;
 }
 
-static ssize_t dynamic_fw_traces_read(struct file *file,
-					char __user *userbuf,
-					size_t count, loff_t *ppos)
+static ssize_t dynamic_fw_traces_read(struct file *file, char __user *userbuf,
+				      size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	return cc33xx_format_buffer(userbuf, count, ppos,
@@ -425,6 +410,13 @@ static const struct file_operations radar_debug_mode_ops = {
 	.open = simple_open,
 	.llseek = default_llseek,
 };
+
+static inline void cc33xx_debugfs_add_files_helper(struct dentry *moddir)
+{
+	DEBUGFS_ADD(radar_debug_mode, moddir);
+}
+#else
+static inline void cc33xx_debugfs_add_files_helper(struct dentry *moddir) {}
 #endif /* CFG80211_CERTIFICATION_ONUS */
 
 
@@ -451,9 +443,8 @@ void cc33xx_debugfs_update_stats(struct cc33xx *wl)
 		goto out;
 
 
-	if (!wl->plt &&
-	    time_after(jiffies, wl->stats.fw_stats_update +
-		       msecs_to_jiffies(CC33XX_DEBUGFS_STATS_LIFETIME))) {
+	if (!wl->plt && time_after(jiffies, wl->stats.fw_stats_update +
+		msecs_to_jiffies(CC33XX_DEBUGFS_STATS_LIFETIME))) {
 		cc33xx_acx_statistics(wl, wl->stats.fw_stats);
 		wl->stats.fw_stats_update = jiffies;
 	}
@@ -463,8 +454,7 @@ void cc33xx_debugfs_update_stats(struct cc33xx *wl)
 }
 
 DEBUGFS_READONLY_FILE(retry_count, "%u", wl->stats.retry_count);
-DEBUGFS_READONLY_FILE(excessive_retries, "%u",
-		      wl->stats.excessive_retries);
+DEBUGFS_READONLY_FILE(excessive_retries, "%u", wl->stats.excessive_retries);
 
 static ssize_t tx_queue_len_read(struct file *file, char __user *userbuf,
 				 size_t count, loff_t *ppos)
@@ -486,8 +476,7 @@ static const struct file_operations tx_queue_len_ops = {
 	.llseek = default_llseek,
 };
 
-static void chip_op_handler(struct cc33xx *wl, unsigned long value,
-			    void *arg)
+static void chip_op_handler(struct cc33xx *wl, unsigned long value, void *arg)
 {
 	int (*chip_op) (struct cc33xx *wl);
 
@@ -501,13 +490,6 @@ static void chip_op_handler(struct cc33xx *wl, unsigned long value,
 
 }
 
-
-static inline void no_write_handler(struct cc33xx *wl,
-				    unsigned long value,
-				    unsigned long param)
-{
-}
-
 #define CC33XX_CONF_DEBUGFS(param, conf_sub_struct,			\
 			    min_val, max_val, write_handler_locked,	\
 			    write_handler_arg)				\
@@ -541,7 +523,7 @@ static inline void no_write_handler(struct cc33xx *wl,
 	}								\
 									\
 	mutex_lock(&wl->mutex);						\
-	wl->conf.host_conf.conf_sub_struct.param = value;				\
+	wl->conf.host_conf.conf_sub_struct.param = value;		\
 									\
 	write_handler_locked(wl, value, write_handler_arg);		\
 									\
@@ -564,7 +546,7 @@ CC33XX_CONF_DEBUGFS(irq_timeout, rx, 0, 100,
 		    chip_op_handler, cc33xx_acx_init_rx_interrupt)
 
 static ssize_t gpio_power_read(struct file *file, char __user *user_buf,
-			  size_t count, loff_t *ppos)
+			       size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	bool state = test_bit(CC33XX_FLAG_GPIO_POWER, &wl->flags);
@@ -577,9 +559,8 @@ static ssize_t gpio_power_read(struct file *file, char __user *user_buf,
 	return simple_read_from_buffer(user_buf, count, ppos, buf, res);
 }
 
-static ssize_t gpio_power_write(struct file *file,
-			   const char __user *user_buf,
-			   size_t count, loff_t *ppos)
+static ssize_t gpio_power_write(struct file *file, const char __user *user_buf,
+				size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	unsigned long value;
@@ -628,19 +609,18 @@ static const struct file_operations start_recovery_ops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t dynamic_ps_timeout_read(struct file *file, char __user *user_buf,
-			  size_t count, loff_t *ppos)
+static inline ssize_t dynamic_ps_timeout_read(struct file *file,
+					      char __user *user_buf,
+					      size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
-
-	return cc33xx_format_buffer(user_buf, count,
-				    ppos, "%d\n",
+	return cc33xx_format_buffer(user_buf, count, ppos, "%d\n",
 				    wl->conf.host_conf.conn.dynamic_ps_timeout);
 }
 
 static ssize_t dynamic_ps_timeout_write(struct file *file,
-				    const char __user *user_buf,
-				    size_t count, loff_t *ppos)
+					const char __user *user_buf,
+					size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	struct cc33xx_vif *wlvif;
@@ -686,19 +666,16 @@ static const struct file_operations dynamic_ps_timeout_ops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t forced_ps_read(struct file *file, char __user *user_buf,
-			  size_t count, loff_t *ppos)
+static inline ssize_t forced_ps_read(struct file *file, char __user *user_buf,
+				     size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
-
-	return cc33xx_format_buffer(user_buf, count,
-				    ppos, "%d\n",
+	return cc33xx_format_buffer(user_buf, count, ppos, "%d\n",
 				    wl->conf.host_conf.conn.forced_ps);
 }
 
-static ssize_t forced_ps_write(struct file *file,
-				    const char __user *user_buf,
-				    size_t count, loff_t *ppos)
+static ssize_t forced_ps_write(struct file *file, const char __user *user_buf,
+			       size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	struct cc33xx_vif *wlvif;
@@ -749,19 +726,18 @@ static const struct file_operations forced_ps_ops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t split_scan_timeout_read(struct file *file, char __user *user_buf,
-			  size_t count, loff_t *ppos)
+static inline ssize_t split_scan_timeout_read(struct file *file,
+					      char __user *user_buf,
+					      size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
-
-	return cc33xx_format_buffer(user_buf, count,
-				    ppos, "%d\n",
+	return cc33xx_format_buffer(user_buf, count, ppos, "%d\n",
 				    wl->conf.host_conf.scan.split_scan_timeout / 1000);
 }
 
 static ssize_t split_scan_timeout_write(struct file *file,
-				    const char __user *user_buf,
-				    size_t count, loff_t *ppos)
+					const char __user *user_buf,
+					size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	unsigned long value;
@@ -857,7 +833,6 @@ static ssize_t driver_state_read(struct file *file, char __user *user_buf,
 	DRIVER_STATE_PRINT_HEX(quirks);
 	/* TODO: ref_clock and tcxo_clock were moved to wl12xx priv */
 
-
 #undef DRIVER_STATE_PRINT_INT
 #undef DRIVER_STATE_PRINT_LONG
 #undef DRIVER_STATE_PRINT_HEX
@@ -880,7 +855,7 @@ static const struct file_operations driver_state_ops = {
 };
 
 static ssize_t vifs_state_read(struct file *file, char __user *user_buf,
-				 size_t count, loff_t *ppos)
+			       size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	struct cc33xx_vif *wlvif;
@@ -1065,8 +1040,6 @@ static const struct file_operations dtim_interval_ops = {
 	.llseek = default_llseek,
 };
 
-
-
 static ssize_t suspend_dtim_interval_read(struct file *file,
 					  char __user *user_buf,
 					  size_t count, loff_t *ppos)
@@ -1115,7 +1088,6 @@ static ssize_t suspend_dtim_interval_write(struct file *file,
 	return count;
 }
 
-
 static const struct file_operations suspend_dtim_interval_ops = {
 	.read = suspend_dtim_interval_read,
 	.write = suspend_dtim_interval_write,
@@ -1182,8 +1154,8 @@ static const struct file_operations beacon_interval_ops = {
 };
 
 static ssize_t rx_streaming_interval_write(struct file *file,
-			   const char __user *user_buf,
-			   size_t count, loff_t *ppos)
+					   const char __user *user_buf,
+					   size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	struct cc33xx_vif *wlvif;
@@ -1214,13 +1186,13 @@ static ssize_t rx_streaming_interval_write(struct file *file,
 	return count;
 }
 
-static ssize_t rx_streaming_interval_read(struct file *file,
-			    char __user *userbuf,
-			    size_t count, loff_t *ppos)
+static inline ssize_t rx_streaming_interval_read(struct file *file,
+						 char __user *userbuf,
+						 size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
-	return cc33xx_format_buffer(userbuf, count, ppos,
-				    "%d\n", wl->conf.host_conf.rx_streaming.interval);
+	return cc33xx_format_buffer(userbuf, count, ppos, "%d\n",
+				    wl->conf.host_conf.rx_streaming.interval);
 }
 
 static const struct file_operations rx_streaming_interval_ops = {
@@ -1231,8 +1203,8 @@ static const struct file_operations rx_streaming_interval_ops = {
 };
 
 static ssize_t rx_streaming_always_write(struct file *file,
-			   const char __user *user_buf,
-			   size_t count, loff_t *ppos)
+					 const char __user *user_buf,
+					 size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	struct cc33xx_vif *wlvif;
@@ -1263,13 +1235,13 @@ static ssize_t rx_streaming_always_write(struct file *file,
 	return count;
 }
 
-static ssize_t rx_streaming_always_read(struct file *file,
-			    char __user *userbuf,
-			    size_t count, loff_t *ppos)
+static inline ssize_t rx_streaming_always_read(struct file *file,
+					       char __user *userbuf,
+					       size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
-	return cc33xx_format_buffer(userbuf, count, ppos,
-				    "%d\n", wl->conf.host_conf.rx_streaming.always);
+	return cc33xx_format_buffer(userbuf, count, ppos, "%d\n",
+				    wl->conf.host_conf.rx_streaming.always);
 }
 
 static const struct file_operations rx_streaming_always_ops = {
@@ -1310,8 +1282,7 @@ static const struct file_operations beacon_filtering_ops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t fw_stats_raw_read(struct file *file,
-				 char __user *userbuf,
+static ssize_t fw_stats_raw_read(struct file *file, char __user *userbuf,
 				 size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
@@ -1320,7 +1291,7 @@ static ssize_t fw_stats_raw_read(struct file *file,
 
 	return simple_read_from_buffer(userbuf, count, ppos,
 				       wl->stats.fw_stats,
-				       wl->stats.fw_stats_len);
+				       sizeof(struct cc33xx_acx_statistics_t));
 }
 
 static const struct file_operations fw_stats_raw_ops = {
@@ -1329,18 +1300,15 @@ static const struct file_operations fw_stats_raw_ops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t sleep_auth_read(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
+static inline ssize_t sleep_auth_read(struct file *file, char __user *user_buf,
+				      size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
-
-	return cc33xx_format_buffer(user_buf, count,
-				    ppos, "%d\n",
+	return cc33xx_format_buffer(user_buf, count, ppos, "%d\n",
 				    wl->sleep_auth);
 }
 
-static ssize_t sleep_auth_write(struct file *file,
-				const char __user *user_buf,
+static ssize_t sleep_auth_write(struct file *file, const char __user *user_buf,
 				size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
@@ -1384,18 +1352,15 @@ static const struct file_operations sleep_auth_ops = {
 };
 
 //ble_enable
-static ssize_t ble_enable_read(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
+static inline ssize_t ble_enable_read(struct file *file, char __user *user_buf,
+				      size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
-
-	return cc33xx_format_buffer(user_buf, count,
-				    ppos, "%d\n",
+	return cc33xx_format_buffer(user_buf, count, ppos, "%d\n",
 				    wl->ble_enable);
 }
 
-static ssize_t ble_enable_write(struct file *file,
-				const char __user *user_buf,
+static ssize_t ble_enable_write(struct file *file, const char __user *user_buf,
 				size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
@@ -1416,7 +1381,6 @@ static ssize_t ble_enable_write(struct file *file,
 		return -EINVAL;
 	}
 
-
 	mutex_lock(&wl->mutex);
 
 	if (unlikely(wl->state != WLCORE_STATE_ON)) {
@@ -1431,11 +1395,8 @@ static ssize_t ble_enable_write(struct file *file,
 	return count;
 }
 
-
-
 //ble_enable
 
-
 static const struct file_operations ble_enable_ops = {
 	.read = ble_enable_read,
 	.write = ble_enable_write,
@@ -1443,16 +1404,14 @@ static const struct file_operations ble_enable_ops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t set_tsf_read(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
+static inline ssize_t set_tsf_read(struct file *file, char __user *user_buf,
+			           size_t count, loff_t *ppos)
 {
-	return cc33xx_format_buffer(user_buf, count,
-				    ppos, "%llx\n", 0LL);
+	return cc33xx_format_buffer(user_buf, count, ppos, "%llx\n", 0LL);
 }
 
-static ssize_t set_tsf_write(struct file *file,
-				const char __user *user_buf,
-				size_t count, loff_t *ppos)
+static ssize_t set_tsf_write(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	unsigned long long value;
@@ -1470,7 +1429,6 @@ static ssize_t set_tsf_write(struct file *file,
 		goto out;
 	}
 
-
 	cc33xx_acx_set_tsf(wl, value);
 
 out:
@@ -1485,15 +1443,175 @@ static const struct file_operations set_tsf_ops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t dev_mem_read(struct file *file,
-	     char __user *user_buf, size_t count,
-	     loff_t *ppos)
+
+static ssize_t twt_action_read(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	struct cc33xx *wl = file->private_data;
+
+	return cc33xx_format_buffer(user_buf, count, ppos, "%d %d %d %d %d\n",
+				wl->min_wake_duration_usec,
+				wl->min_wake_interval_mantissa, wl->min_wake_interval_exponent,
+				wl->max_wake_interval_mantissa, wl->max_wake_interval_exponent);
+}
+
+static ssize_t twt_action_write(struct file *file,
+				const char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct cc33xx *wl = file->private_data;
+
+	int min_wake_duration_usec = 0;
+	int min_wake_interval_mantissa = 0;
+	int min_wake_interval_exponent = 0;
+	int max_wake_interval_mantissa = 0;
+	int max_wake_interval_exponent = 0;
+	int twt_action_type;
+	u8 valid_params;
+	int ret;
+	int arg_count;
+	char* buffer;
+
+	buffer = kzalloc(count, GFP_KERNEL);
+	if (!buffer) {
+		ret = -ENOMEM;
+		cc33xx_warning("error in twt_action: %d", ret);
+		return ret;
+	}
+
+	ret = strncpy_from_user(buffer, user_buf, count);
+	if(-EFAULT == ret){
+		cc33xx_warning("error in twt_action: %d", ret);
+		kfree(buffer);
+		return ret;
+	}
+
+	arg_count = sscanf(buffer, "%d %d %d %d %d %d", &twt_action_type, &min_wake_duration_usec,
+					&min_wake_interval_mantissa, &min_wake_interval_exponent,
+					&max_wake_interval_mantissa, &max_wake_interval_exponent);
+
+	kfree(buffer);
+
+#define TWT_ACTION_SETUP 		(1)
+#define TWT_ACTION_SUSPEND 		(2)
+#define TWT_ACTION_RESUME 		(3)
+#define TWT_ACTION_TERMINATE 	(4)
+
+	valid_params = 0;
+	if( (twt_action_type == TWT_ACTION_SETUP) && (arg_count > 1) )
+	{
+		if( min_wake_duration_usec < 256)
+		{
+			cc33xx_warning("error in twt_action: duration cannot be under 256 ");
+			return count;
+		}
+
+		if(min_wake_interval_mantissa <= 0)
+		{
+			cc33xx_warning("error in twt_action: interval mantissa must be over 0 ");
+			return count;
+		}
+		if((min_wake_interval_exponent < 0) || (max_wake_interval_mantissa < 0 ) || (max_wake_interval_exponent < 0 ))
+		{
+			cc33xx_warning("error in twt_action: negative value not allowed ");
+			return count;
+		}
+	}
+
+	mutex_lock(&wl->mutex);
+
+	if (unlikely(wl->state != WLCORE_STATE_ON)) {
+		goto out;
+	}
+
+	// valid input is twt_action [min_wake_duration_usec min_wake_interval_mantissa
+	//			min_wake_interval_exponent [max_wake_interval_mantissa max_wake_interval_exponent]]
+	if(twt_action_type != TWT_ACTION_SETUP && arg_count != 1)
+	{
+		cc33xx_warning("illegal arguments in twt_action");
+		cc33xx_warning("twt_action_type: %d",twt_action_type);
+		goto out;
+	}
+	switch (twt_action_type)
+	{
+		case TWT_ACTION_SETUP:{
+			if(arg_count == 1)
+			{
+
+			}
+			else if(arg_count == 4)
+			{
+				valid_params |= (MIN_WAKE_DURATION_VALID | MIN_WAKE_INTERVAL_MANTISSA_VALID |
+						MIN_WAKE_INTERVAL_EXPONENT_VALID);
+			}
+
+			else if(arg_count == 6)
+			{
+				valid_params |= (MIN_WAKE_DURATION_VALID | MIN_WAKE_INTERVAL_MANTISSA_VALID |
+					MIN_WAKE_INTERVAL_EXPONENT_VALID | MAX_WAKE_INTERVAL_MANTISSA_VALID |
+					MAX_WAKE_INTERVAL_EXPONENT_VALID);
+			}
+			else
+			{
+				cc33xx_warning("illegal number of params for twt action setup");
+				goto out;
+			}
+
+			ret = cc33xx_acx_twt_setup(wl, min_wake_duration_usec,
+					min_wake_interval_mantissa, min_wake_interval_exponent,
+					max_wake_interval_mantissa, max_wake_interval_exponent,
+					valid_params);
+
+
+			break;
+		}
+		case TWT_ACTION_SUSPEND: {
+
+			ret = cc33xx_acx_twt_suspend(wl);
+			break;
+		}
+		case TWT_ACTION_RESUME: {
+
+			ret = cc33xx_acx_twt_resume(wl);
+
+			break;
+		}
+		case TWT_ACTION_TERMINATE: {
+
+			ret = cc33xx_acx_twt_terminate(wl);
+
+			break;
+		}
+
+		default : {
+			cc33xx_warning("illegal twt command");
+			goto out;
+		}
+	}
+
+
+out:
+	mutex_unlock(&wl->mutex);
+	return count;
+}
+
+static const struct file_operations twt_action_ops = {
+	.open = simple_open,
+	.read = twt_action_read,
+	.write = twt_action_write,
+	.llseek = default_llseek,
+};
+
+
+static inline ssize_t dev_mem_read(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
 {
 	return 0;
 }
 
-static ssize_t dev_mem_write(struct file *file, const char __user *user_buf,
-		size_t count, loff_t *ppos)
+static inline ssize_t dev_mem_write(struct file *file,
+				    const char __user *user_buf,
+				    size_t count, loff_t *ppos)
 {
 	return 0;
 }
@@ -1514,18 +1632,15 @@ static const struct file_operations dev_mem_ops = {
 	.llseek = dev_mem_seek,
 };
 
-static ssize_t fw_logger_read(struct file *file, char __user *user_buf,
-			      size_t count, loff_t *ppos)
+static inline ssize_t fw_logger_read(struct file *file, char __user *user_buf,
+				     size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
-
-	return cc33xx_format_buffer(user_buf, count,
-					ppos, "%d\n",
-					wl->conf.host_conf.fwlog.output);
+	return cc33xx_format_buffer(user_buf, count, ppos, "%d\n",
+				    wl->conf.host_conf.fwlog.output);
 }
 
-static ssize_t fw_logger_write(struct file *file,
-			       const char __user *user_buf,
+static ssize_t fw_logger_write(struct file *file, const char __user *user_buf,
 			       size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
@@ -1544,7 +1659,8 @@ static ssize_t fw_logger_write(struct file *file,
 	}
 
 	if (wl->conf.host_conf.fwlog.output == 0) {
-		cc33xx_warning("invalid operation - fw logger disabled by default, please change mode via wlconf");
+		cc33xx_warning("invalid operation - fw logger disabled by default, "
+			       "please change mode via wlconf");
 		return -EINVAL;
 	}
 
@@ -1565,17 +1681,18 @@ static const struct file_operations fw_logger_ops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t antenna_select_read(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
+static inline ssize_t antenna_select_read(struct file *file,
+					  char __user *user_buf,
+					  size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
-
-	return cc33xx_format_buffer(user_buf, count,
-					ppos, "%d\n", wl->antenna_selection);
+	return cc33xx_format_buffer(user_buf, count, ppos, "%d\n",
+				    wl->antenna_selection);
 }
 
 static ssize_t antenna_select_write(struct file *file,
-				const char __user *user_buf, size_t count, loff_t *ppos)
+				    const char __user *user_buf,
+				    size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	int ret;
@@ -1615,21 +1732,27 @@ static const struct file_operations antenna_select_ops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t get_versions_extended_read(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
+static ssize_t get_versions_extended_read(struct file *file,
+					  char __user *user_buf,
+					  size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
+	struct driver_versions *driver_ver = &wl->all_versions.driver_ver;
+	struct cc33xx_acx_fw_versions *fw_ver = wl->all_versions.fw_ver;
 
 	char all_versions_str [MAX_VERSIONS_EXTENDED_LEN];
 
-	sprintf(all_versions_str, "Driver Version: %u.%u.%u.%u\nFirmware Version: %u.%u.%u.%u\nPhy Version: %u.%u.%u.%u.%u.%u",
-		wl->all_versions.driver_ver.major_version, wl->all_versions.driver_ver.minor_version, wl->all_versions.driver_ver.api_version, wl->all_versions.driver_ver.build_version,
-		wl->all_versions.fw_ver->major_version, wl->all_versions.fw_ver->minor_version, wl->all_versions.fw_ver->api_version, wl->all_versions.fw_ver->build_version,
-		wl->all_versions.fw_ver->phy_version[5], wl->all_versions.fw_ver->phy_version[4], wl->all_versions.fw_ver->phy_version[3], wl->all_versions.fw_ver->phy_version[2],
-		wl->all_versions.fw_ver->phy_version[1], wl->all_versions.fw_ver->phy_version[0]);
-
-	return cc33xx_format_buffer(user_buf, count,
-				    ppos, "%s\n",
+	sprintf(all_versions_str, "Driver Version: %u.%u.%u.%u\n"
+		"Firmware Version: %u.%u.%u.%u\nPhy Version: %u.%u.%u.%u.%u.%u",
+		driver_ver->major_version, driver_ver->minor_version,
+		driver_ver->api_version, driver_ver->build_version,
+		fw_ver->major_version, fw_ver->minor_version,
+		fw_ver->api_version, fw_ver->build_version,
+		fw_ver->phy_version[5], fw_ver->phy_version[4],
+		fw_ver->phy_version[3], fw_ver->phy_version[2],
+		fw_ver->phy_version[1], fw_ver->phy_version[0]);
+
+	return cc33xx_format_buffer(user_buf, count, ppos, "%s\n",
 				    all_versions_str);
 }
 
@@ -1640,18 +1763,21 @@ static const struct file_operations get_versions_extended_ops = {
 };
 
 static ssize_t get_versions_read(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
+				 size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
+	struct driver_versions *driver_ver = &wl->all_versions.driver_ver;
+	struct cc33xx_acx_fw_versions *fw_ver = wl->all_versions.fw_ver;
 
 	char all_versions_str [MAX_VERSIONS_LEN];
 
-	sprintf(all_versions_str, "Driver Version: %u.%u.%u\nFirmware Version: %u.%u.%u",
-		wl->all_versions.driver_ver.major_version, wl->all_versions.driver_ver.minor_version, wl->all_versions.driver_ver.api_version,
-		wl->all_versions.fw_ver->major_version, wl->all_versions.fw_ver->minor_version, wl->all_versions.fw_ver->api_version);
+	sprintf(all_versions_str,
+		"Driver Version: %u.%u.%u\nFirmware Version: %u.%u.%u",
+		driver_ver->major_version, driver_ver->minor_version,
+		driver_ver->api_version, fw_ver->major_version,
+		fw_ver->minor_version, fw_ver->api_version);
 
-	return cc33xx_format_buffer(user_buf, count,
-				    ppos, "%s\n",
+	return cc33xx_format_buffer(user_buf, count, ppos, "%s\n",
 				    all_versions_str);
 }
 
@@ -1662,7 +1788,8 @@ static const struct file_operations get_versions_ops = {
 };
 
 static ssize_t trigger_fw_assert_write(struct file *file,
-				const char __user *user_buf, size_t count, loff_t *ppos)
+				       const char __user *user_buf,
+				       size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 
@@ -1685,17 +1812,17 @@ static const struct file_operations trigger_fw_assert_ops = {
 	.llseek = default_llseek,
 };
 
-static ssize_t burst_mode_read(struct file *file, char __user *user_buf,
-				size_t count, loff_t *ppos)
+static inline ssize_t burst_mode_read(struct file *file, char __user *user_buf,
+				      size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 
-	return cc33xx_format_buffer(user_buf, count,
-					ppos, "%d\n", wl->burst_disable);
+	return cc33xx_format_buffer(user_buf, count, ppos,
+				    "%d\n", wl->burst_disable);
 }
 
-static ssize_t burst_mode_write(struct file *file,
-				const char __user *user_buf, size_t count, loff_t *ppos)
+static ssize_t burst_mode_write(struct file *file, const char __user *user_buf,
+				size_t count, loff_t *ppos)
 {
 	struct cc33xx *wl = file->private_data;
 	int ret;
@@ -1735,6 +1862,317 @@ static const struct file_operations burst_mode_ops = {
 	.llseek = default_llseek,
 };
 
+/* coex entities bitmap */
+#define  COEX_WIFI_ENABLE        (0x1)
+#define  COEX_BLE_ENABLE         (0x2)
+#define  COEX_SOC_ENABLE         (0x4)
+
+#define  MAX_COEX_STATISTICS_LEN (850)
+
+static ssize_t coex_statistics_read(struct file *file, char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct cc33xx *wl = file->private_data;
+	struct cc33xx_acx_coex_statistics *coex_stats_cmd;
+	char coex_statistics_str[MAX_COEX_STATISTICS_LEN];
+	struct cc33xx_coex_stat_and_entities *coex_stat_ent;
+	struct cc33xx_coex_statistics *coex_stats;
+	int res, restot = 0, ret = 0;
+
+	cc33xx_debug(DEBUG_CMD, "coex_statistics_read");
+
+	coex_stats_cmd = kzalloc(sizeof(struct cc33xx_acx_coex_statistics),
+					GFP_KERNEL);
+	if (!coex_stats_cmd)
+		return -ENOMEM;
+
+	coex_stat_ent = &coex_stats_cmd->coex_stat;
+	coex_stats = &coex_stat_ent->coex_statistics;
+
+	ret = cc33xx_cmd_interrogate(wl, READ_COEX_STATISTICS, coex_stats_cmd,
+				     sizeof(struct cc33xx_acx_coex_statistics),
+				     sizeof(struct cc33xx_acx_coex_statistics));
+
+	if (ret < 0) {
+		cc33xx_error("failed to send interrogate command");
+		goto out_free;
+	}
+
+	if (coex_stats_cmd->header.cmd.status == CMD_STATUS_INVALID_PARAM) {
+		cc33xx_error("Coex statistics are disabled");
+		goto out_free;
+	}
+
+	res = 0;
+
+	if (coex_stat_ent->coex_entities_bitmap & COEX_WIFI_ENABLE) {
+		res = snprintf(coex_statistics_str, MAX_COEX_STATISTICS_LEN,
+			       "wifi:\nrequest assertion/deassertion: %d/%d\r\n"
+			       "grant assertion/deassertion: %d/%d\r\n"
+			       "prio reject: %d\r\n"
+			       "grant during dual ant assertion/deassertion: "
+			       "%d/%d\r\n\n",
+			       cpu_to_le32(coex_stats->wifi_request_assertion_log),
+			       cpu_to_le32(coex_stats->wifi_request_de_assertion_log),
+			       cpu_to_le32(coex_stats->wifi_grant_assertion_log),
+			       cpu_to_le32(coex_stats->wifi_grant_deassertion_log),
+			       cpu_to_le32(coex_stats->wifi_prio_reject_log),
+			       cpu_to_le32(coex_stats->wifi_grant_during_dual_ant_assertion_log),
+			       cpu_to_le32(coex_stats->wifi_grant_during_dual_ant_deassertion_log));
+		restot = res;
+	}
+
+	if (coex_stat_ent->coex_entities_bitmap & COEX_BLE_ENABLE) {
+		res = snprintf(coex_statistics_str + restot,
+			       MAX_COEX_STATISTICS_LEN - restot, "ble:\n"
+			       "request assertion/deassertion: %d/%d\r\n"
+			       "grant assertion/deassertion: %d/%d\r\n"
+			       "tx high/low prio reject: %d/%d\r\n"
+			       "rx high/low prio reject: %d/%d\r\n\n",
+			       cpu_to_le32(coex_stats->ble_request_assertion_log),
+			       cpu_to_le32(coex_stats->ble_request_deassertion_log),
+			       cpu_to_le32(coex_stats->ble_grant_assertion_log),
+			       cpu_to_le32(coex_stats->ble_grant_deassertion_log),
+			       cpu_to_le32(coex_stats->ble_tx_high_prio_reject_log),
+			       cpu_to_le32(coex_stats->ble_tx_low_prio_reject_log),
+			       cpu_to_le32(coex_stats->ble_rx_high_prio_reject_log),
+			       cpu_to_le32(coex_stats->ble_rx_low_prio_reject_log));
+		restot += res;
+	}
+
+	if (coex_stat_ent->coex_entities_bitmap & COEX_SOC_ENABLE) {
+		res = snprintf(coex_statistics_str + restot,
+			       MAX_COEX_STATISTICS_LEN - restot,
+			       "External SoC:\n"
+			       "request assertion/deassertion: %d/%d\r\n"
+			       "grant assertion/deassertion: %d/%d\r\n"
+			       "high/low prio reject: %d/%d\r\n\n",
+			       cpu_to_le32(coex_stats->soc_request_assertion_log),
+			       cpu_to_le32(coex_stats->soc_request_deassertion_log),
+			       cpu_to_le32(coex_stats->soc_grant_assertion_log),
+			       cpu_to_le32(coex_stats->soc_grant_deassertion_log),
+			       cpu_to_le32(coex_stats->soc_high_prio_reject_log),
+			       cpu_to_le32(coex_stats->soc_low_prio_reject_log));
+		restot += res;
+	}
+
+	ret = simple_read_from_buffer(user_buf, count, ppos,
+				      coex_statistics_str, restot);
+
+out_free:
+	kfree(coex_stats_cmd);
+
+	return ret;
+}
+
+static ssize_t coex_statistics_write(struct file *file,
+				     const char __user *user_buf,
+				     size_t count, loff_t *ppos)
+{
+	struct cc33xx *wl = file->private_data;
+	unsigned int value;
+	struct cc33xx_acx_coex_statistics_cfg *pCoexStatictics;
+	int ret;
+
+	ret = kstrtouint_from_user(user_buf, count, 0, &value);
+	if (value > 2) {
+		cc33xx_warning("Parameter value must be 0-Disable Coex counters, "
+			       "1-Enable Coex counters, 2-Reset Coex counters");
+		return -ERANGE;
+	}
+
+	cc33xx_debug(DEBUG_CMD, "coex statistics (%d)", value);
+
+	pCoexStatictics = kzalloc(sizeof(struct cc33xx_acx_coex_statistics_cfg),
+				  GFP_KERNEL);
+	if (!pCoexStatictics) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	pCoexStatictics->coex_statictics = value;
+
+	mutex_lock(&wl->mutex);
+
+	ret = cc33xx_cmd_configure(wl, START_COEX_STATISTICS_CFG,
+				   pCoexStatictics,
+				   sizeof(struct cc33xx_acx_coex_statistics_cfg));
+	if (ret < 0) {
+		cc33xx_error("failed to initiate coex statictics");
+		goto out_free;
+	}
+
+out_free:
+	kfree(pCoexStatictics);
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return count;
+}
+
+static const struct file_operations coex_statistics_ops = {
+	.open = simple_open,
+	.read = coex_statistics_read,
+	.write = coex_statistics_write,
+	.llseek = default_llseek,
+};
+
+static ssize_t antenna_diversity_enable_read(struct file *file,
+					char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct cc33xx *wl = file->private_data;
+
+	return cc33xx_format_buffer(user_buf, count,
+					ppos, "%d\n", wl->diversity.diversity_enable);
+}
+
+static ssize_t antenna_diversity_enable_write(struct file *file,
+				const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct cc33xx *wl = file->private_data;
+	int ret;
+	u8 diversity_enable;
+
+	ret = kstrtou8_from_user(user_buf, count, 0, &diversity_enable);
+	if (ret < 0) {
+		cc33xx_warning("illegal value in antenna_diversity_enable");
+		return -EINVAL;
+	}
+
+	if ((wl->conf.phy.num_of_antennas == 1) && (diversity_enable == 1)) {
+		cc33xx_warning("diversity cannot be enabled when only one antenna on board");
+		return -EINVAL;
+	}
+
+	if (diversity_enable > 1) {
+		cc33xx_warning("diversity_enable should be either 0 or 1");
+		return -ERANGE;
+	}
+
+	mutex_lock(&wl->mutex);
+
+	if (unlikely(wl->state != WLCORE_STATE_ON)) {
+		goto out;
+	}
+
+	ret = cc33xx_acx_antenna_diversity_enable(wl, diversity_enable);
+	if (ret == 0) {
+		wl->diversity.diversity_enable = diversity_enable;
+	}
+
+out:
+	mutex_unlock(&wl->mutex);
+	return count;
+}
+
+static const struct file_operations antenna_diversity_enable_ops = {
+	.open = simple_open,
+	.read = antenna_diversity_enable_read,
+	.write = antenna_diversity_enable_write,
+	.llseek = default_llseek,
+};
+
+static ssize_t antenna_diversity_set_rssi_threshold_read(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct cc33xx *wl = file->private_data;
+
+	return cc33xx_format_buffer(user_buf, count,
+					ppos, "%d\n", wl->diversity.rssi_threshold);
+}
+
+static ssize_t antenna_diversity_set_rssi_threshold_write(struct file *file,
+				const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct cc33xx *wl = file->private_data;
+	int ret;
+	s8 rssi_threshold;
+
+	ret = kstrtos8_from_user(user_buf, count, 0, &rssi_threshold);
+	if (ret < 0) {
+		cc33xx_warning("illegal value in antenna_diversity_set_rssi_threshold");
+		return -EINVAL;
+	}
+
+	mutex_lock(&wl->mutex);
+
+	if (unlikely(wl->state != WLCORE_STATE_ON)) {
+		goto out;
+	}
+
+	ret = cc33xx_acx_antenna_diversity_set_rssi_threshold(wl, rssi_threshold);
+	if (ret == 0) {
+		wl->diversity.rssi_threshold = rssi_threshold;
+	}
+
+out:
+	mutex_unlock(&wl->mutex);
+	return count;
+}
+
+static const struct file_operations antenna_diversity_set_rssi_threshold_ops = {
+	.open = simple_open,
+	.read = antenna_diversity_set_rssi_threshold_read,
+	.write = antenna_diversity_set_rssi_threshold_write,
+	.llseek = default_llseek,
+};
+
+static ssize_t antenna_diversity_select_default_antenna_read(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct cc33xx *wl = file->private_data;
+
+	return cc33xx_format_buffer(user_buf, count,
+					ppos, "%d\n", wl->diversity.default_antenna);
+}
+
+static ssize_t antenna_diversity_select_default_antenna_write(struct file *file,
+				const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct cc33xx *wl = file->private_data;
+	int ret;
+	u8 default_antenna;
+
+	ret = kstrtou8_from_user(user_buf, count, 0, &default_antenna);
+	if (ret < 0) {
+		cc33xx_warning("illegal value in antenna_diversity_select_default_antenna");
+		return -EINVAL;
+	}
+
+	if (wl->conf.phy.num_of_antennas == 1) {
+		cc33xx_warning("cannot change default antenna in board with only one antenna");
+		return -EINVAL;
+	}
+
+	if (default_antenna > 1) {
+		cc33xx_warning("default_antenna should be either 0 or 1");
+		return -ERANGE;
+	}
+
+	mutex_lock(&wl->mutex);
+
+	if (unlikely(wl->state != WLCORE_STATE_ON)) {
+		goto out;
+	}
+
+	ret = cc33xx_acx_antenna_diversity_select_default_antenna(wl, default_antenna);
+	if (ret == 0) {
+		wl->diversity.default_antenna = default_antenna;
+	}
+
+out:
+	mutex_unlock(&wl->mutex);
+	return count;
+}
+
+static const struct file_operations antenna_diversity_select_default_antenna_ops = {
+	.open = simple_open,
+	.read = antenna_diversity_select_default_antenna_read,
+	.write = antenna_diversity_select_default_antenna_write,
+	.llseek = default_llseek,
+};
+
 int cc33xx_debugfs_add_files(struct cc33xx *wl,
 			     struct dentry *rootdir)
 {
@@ -1746,7 +2184,6 @@ int cc33xx_debugfs_add_files(struct cc33xx *wl,
 	DEBUGFS_ADD(tx_queue_len, rootdir);
 	DEBUGFS_ADD(retry_count, rootdir);
 	DEBUGFS_ADD(excessive_retries, rootdir);
-
 	DEBUGFS_ADD(gpio_power, rootdir);
 	DEBUGFS_ADD(start_recovery, rootdir);
 	DEBUGFS_ADD(driver_state, rootdir);
@@ -1765,22 +2202,25 @@ int cc33xx_debugfs_add_files(struct cc33xx *wl,
 	DEBUGFS_ADD(sleep_auth, rootdir);
 	DEBUGFS_ADD(ble_enable, rootdir);
 	DEBUGFS_ADD(set_tsf, rootdir);
+	DEBUGFS_ADD(twt_action, rootdir);
 	DEBUGFS_ADD(fw_logger, rootdir);
 	DEBUGFS_ADD(antenna_select, rootdir);
 	DEBUGFS_ADD(get_versions, rootdir);
 	DEBUGFS_ADD(get_versions_extended, rootdir);
 	DEBUGFS_ADD(trigger_fw_assert, rootdir);
 	DEBUGFS_ADD(burst_mode, rootdir);
+	DEBUGFS_ADD(coex_statistics, rootdir);
+	DEBUGFS_ADD(clear_fw_stats, stats);
+	DEBUGFS_ADD(antenna_diversity_enable, rootdir);
+	DEBUGFS_ADD(antenna_diversity_set_rssi_threshold, rootdir);
+	DEBUGFS_ADD(antenna_diversity_select_default_antenna, rootdir);
 
 	streaming = debugfs_create_dir("rx_streaming", rootdir);
 
 	DEBUGFS_ADD_PREFIX(rx_streaming, interval, streaming);
 	DEBUGFS_ADD_PREFIX(rx_streaming, always, streaming);
-
 	DEBUGFS_ADD_PREFIX(dev, mem, rootdir);
 
-	DEBUGFS_ADD(clear_fw_stats, stats);
-
 	DEBUGFS_FWSTATS_ADD(error, error_frame_non_ctrl);
 	DEBUGFS_FWSTATS_ADD(error, error_frame_ctrl);
 	DEBUGFS_FWSTATS_ADD(error, error_frame_during_protection);
@@ -1798,7 +2238,6 @@ int cc33xx_debugfs_add_files(struct cc33xx *wl,
 	DEBUGFS_FWSTATS_ADD(error, rx_excessive_frame_len);
 	DEBUGFS_FWSTATS_ADD(error, burst_mismatch);
 	DEBUGFS_FWSTATS_ADD(error, tbc_exch_mismatch);
-
 	DEBUGFS_FWSTATS_ADD(tx, tx_prepared_descs);
 	DEBUGFS_FWSTATS_ADD(tx, tx_cmplt);
 	DEBUGFS_FWSTATS_ADD(tx, tx_template_prepared);
@@ -1835,7 +2274,6 @@ int cc33xx_debugfs_add_files(struct cc33xx *wl,
 	DEBUGFS_FWSTATS_ADD(tx, frag_failed);
 	DEBUGFS_FWSTATS_ADD(tx, frag_cache_hit);
 	DEBUGFS_FWSTATS_ADD(tx, frag_cache_miss);
-
 	DEBUGFS_FWSTATS_ADD(rx, rx_beacon_early_term);
 	DEBUGFS_FWSTATS_ADD(rx, rx_out_of_mpdu_nodes);
 	DEBUGFS_FWSTATS_ADD(rx, rx_hdr_overflow);
@@ -1860,9 +2298,7 @@ int cc33xx_debugfs_add_files(struct cc33xx *wl,
 	DEBUGFS_FWSTATS_ADD(rx, defrag_need_decrypt);
 	DEBUGFS_FWSTATS_ADD(rx, rx_tkip_replays);
 	DEBUGFS_FWSTATS_ADD(rx, rx_xfr);
-
 	DEBUGFS_FWSTATS_ADD(isr, irqs);
-
 	DEBUGFS_FWSTATS_ADD(pwr, missing_bcns_cnt);
 	DEBUGFS_FWSTATS_ADD(pwr, rcvd_bcns_cnt);
 	DEBUGFS_FWSTATS_ADD(pwr, connection_out_of_sync);
@@ -1875,7 +2311,6 @@ int cc33xx_debugfs_add_files(struct cc33xx *wl,
 	DEBUGFS_FWSTATS_ADD(pwr, ap_sleep_active_conf);
 	DEBUGFS_FWSTATS_ADD(pwr, ap_sleep_user_conf);
 	DEBUGFS_FWSTATS_ADD(pwr, ap_sleep_counter);
-
 	DEBUGFS_FWSTATS_ADD(rx_filter, beacon_filter);
 	DEBUGFS_FWSTATS_ADD(rx_filter, arp_filter);
 	DEBUGFS_FWSTATS_ADD(rx_filter, mc_filter);
@@ -1885,13 +2320,10 @@ int cc33xx_debugfs_add_files(struct cc33xx *wl,
 	DEBUGFS_FWSTATS_ADD(rx_filter, protection_filter);
 	DEBUGFS_FWSTATS_ADD(rx_filter, accum_arp_pend_requests);
 	DEBUGFS_FWSTATS_ADD(rx_filter, max_arp_queue_dep);
-
 	DEBUGFS_FWSTATS_ADD(rx_rate, rx_frames_per_rates);
-
 	DEBUGFS_FWSTATS_ADD(aggr_size, tx_agg_rate);
 	DEBUGFS_FWSTATS_ADD(aggr_size, tx_agg_len);
 	DEBUGFS_FWSTATS_ADD(aggr_size, rx_size);
-
 	DEBUGFS_FWSTATS_ADD(pipeline, hs_tx_stat_fifo_int);
 	DEBUGFS_FWSTATS_ADD(pipeline, enc_tx_stat_fifo_int);
 	DEBUGFS_FWSTATS_ADD(pipeline, enc_rx_stat_fifo_int);
@@ -1905,42 +2337,33 @@ int cc33xx_debugfs_add_files(struct cc33xx *wl,
 	DEBUGFS_FWSTATS_ADD(pipeline, dec_packet_in_fifo_full);
 	DEBUGFS_FWSTATS_ADD(pipeline, dec_packet_out);
 	DEBUGFS_FWSTATS_ADD(pipeline, pipeline_fifo_full);
-
 	DEBUGFS_FWSTATS_ADD(diversity, num_of_packets_per_ant);
 	DEBUGFS_FWSTATS_ADD(diversity, total_num_of_toggles);
-
 	DEBUGFS_FWSTATS_ADD(thermal, irq_thr_low);
 	DEBUGFS_FWSTATS_ADD(thermal, irq_thr_high);
 	DEBUGFS_FWSTATS_ADD(thermal, tx_stop);
 	DEBUGFS_FWSTATS_ADD(thermal, tx_resume);
 	DEBUGFS_FWSTATS_ADD(thermal, false_irq);
 	DEBUGFS_FWSTATS_ADD(thermal, adc_source_unexpected);
-
 	DEBUGFS_FWSTATS_ADD(calib, fail_count);
-
 	DEBUGFS_FWSTATS_ADD(calib, calib_count);
-
 	DEBUGFS_FWSTATS_ADD(roaming, rssi_level);
-
 	DEBUGFS_FWSTATS_ADD(dfs, num_of_radar_detections);
 
 	DEBUGFS_ADD(conf, moddir);
 	DEBUGFS_ADD(radar_detection, moddir);
-#ifdef CONFIG_CFG80211_CERTIFICATION_ONUS
-	DEBUGFS_ADD(radar_debug_mode, moddir);
-#endif
+	cc33xx_debugfs_add_files_helper(moddir);
 	DEBUGFS_ADD(dynamic_fw_traces, moddir);
 
 	return 0;
 }
 
-
 void cc33xx_debugfs_reset(struct cc33xx *wl)
 {
 	if (!wl->stats.fw_stats)
 		return;
 
-	memset(wl->stats.fw_stats, 0, wl->stats.fw_stats_len);
+	memset(wl->stats.fw_stats, 0, sizeof(struct cc33xx_acx_statistics_t));
 	wl->stats.retry_count = 0;
 	wl->stats.excessive_retries = 0;
 }
@@ -1950,10 +2373,10 @@ int cc33xx_debugfs_init(struct cc33xx *wl)
 	int ret;
 	struct dentry *rootdir;
 
-	rootdir = debugfs_create_dir(KBUILD_MODNAME,
-				     wl->hw->wiphy->debugfsdir);
+	rootdir = debugfs_create_dir(KBUILD_MODNAME, wl->hw->wiphy->debugfsdir);
 
-	wl->stats.fw_stats = kzalloc(wl->stats.fw_stats_len, GFP_KERNEL);
+	wl->stats.fw_stats = kzalloc(sizeof(struct cc33xx_acx_statistics_t),
+				     GFP_KERNEL);
 	if (!wl->stats.fw_stats) {
 		ret = -ENOMEM;
 		goto out_remove;
diff --git a/drivers/net/wireless/ti/cc33xx/event.c b/drivers/net/wireless/ti/cc33xx/event.c
index 0da9d6c072b4..b6b7fb9113fd 100644
--- a/drivers/net/wireless/ti/cc33xx/event.c
+++ b/drivers/net/wireless/ti/cc33xx/event.c
@@ -7,19 +7,13 @@
  * Contact: Luciano Coelho <luciano.coelho@nokia.com>
  */
 
-#include "wlcore.h"
-#include "debug.h"
-#include "io.h"
+#include "acx.h"
 #include "event.h"
 #include "ps.h"
+#include "io.h"
 #include "scan.h"
-#include "cc33xx_80211.h"
 
-#define CC33XX_LOGGER_SDIO_BUFF_MAX	(0x1020)
-#define CC33XX_DATA_RAM_BASE_ADDRESS	(0x20000000)
-#define CC33XX_LOGGER_SDIO_BUFF_ADDR	(0x40159c)
-#define CC33XX_LOGGER_BUFF_OFFSET	(sizeof(struct fw_logger_information))
-#define CC33XX_LOGGER_READ_POINT_OFFSET	(12)
+#define CC33XX_WAIT_EVENT_FAST_POLL_COUNT 20
 
 
 struct cc33xx_event_mailbox {
@@ -86,6 +80,8 @@ struct cc33xx_event_mailbox {
 	/* time sync low lsb*/
 	__le16 time_sync_tsf_low_lsb;
 
+	u8 ble_event[260];
+
 } __packed;
 
 struct event_node{
@@ -94,7 +90,7 @@ struct event_node{
 };
 
 void deffer_event(struct cc33xx *wl,
-			const void *event_payload, size_t event_length)
+		  const void *event_payload, size_t event_length)
 {
 	struct event_node* event_node;
 	bool ret;
@@ -126,64 +122,6 @@ inline static struct llist_node* get_event_list(struct cc33xx *wl)
 	return llist_reverse_order(node);
 }
 
-void process_deferred_events(struct cc33xx *wl)
-{
-	struct event_node *event_node, *tmp;
-	struct llist_node *event_list;
-	u32 vector;
-
-	event_list = get_event_list(wl);
-
-	llist_for_each_entry_safe(event_node, tmp, event_list, node){
-
-		struct cc33xx_event_mailbox *event_data;
-
-		event_data = &event_node->event_data;
-
-		print_hex_dump(KERN_DEBUG, "Deferred event dump:",
-			DUMP_PREFIX_OFFSET, 4, 4,
-			event_data, 64/*sizeof event_node->event_data*/,
-			false);
-
-		vector = le32_to_cpu(event_node->event_data.events_vector);
-		cc33xx_debug(DEBUG_EVENT, "MBOX vector: 0x%x", vector);
-
-		if (vector & SCAN_COMPLETE_EVENT_ID) {
-			cc33xx_debug(DEBUG_EVENT, "scan results: %d",
-				event_node->event_data.number_of_scan_results);
-
-			if (wl->scan_wlvif)
-				cc33xx_scan_completed(wl, wl->scan_wlvif);
-		}
-
-		if (vector & PERIODIC_SCAN_COMPLETE_EVENT_ID)
-		{
-			wlcore_event_sched_scan_completed(wl, 1);
-		}
-
-		if (vector & BSS_LOSS_EVENT_ID)
-			wlcore_event_beacon_loss(wl,
-				le16_to_cpu(event_data->bss_loss_bitmap));
-
-		if (vector & MAX_TX_FAILURE_EVENT_ID)
-			wlcore_event_max_tx_failure(wl,
-				le16_to_cpu(event_data->tx_retry_exceeded_bitmap));
-
-		if (vector & PERIODIC_SCAN_REPORT_EVENT_ID) {
-			cc33xx_debug(DEBUG_EVENT,
-				"PERIODIC_SCAN_REPORT_EVENT (results %d)",
-				event_data->number_of_sched_scan_results);
-
-			wlcore_scan_sched_scan_results(wl);
-		}
-
-		if (vector & REMAIN_ON_CHANNEL_COMPLETE_EVENT_ID)
-			wlcore_event_roc_complete(wl);
-		kfree(event_node);
-	}
-
-}
-
 void flush_deferred_event_list(struct cc33xx *wl)
 {
 	struct event_node *event_node, *tmp;
@@ -195,7 +133,7 @@ void flush_deferred_event_list(struct cc33xx *wl)
 		kfree(event_node);
 	}
 }
-#define CC33XX_WAIT_EVENT_FAST_POLL_COUNT 20
+
 int wait_for_event_or_timeout(struct cc33xx *wl, u32 mask, bool *timeout)
 {
 	u32 event;
@@ -226,7 +164,7 @@ int wait_for_event_or_timeout(struct cc33xx *wl, u32 mask, bool *timeout)
 
 		vector = 0;
 		event_list = get_event_list(wl);
-		llist_for_each_entry_safe(event_node, tmp, event_list, node){
+		llist_for_each_entry_safe(event_node, tmp, event_list, node) {
 			vector |= le32_to_cpu(event_node->event_data.events_vector);
 		}
 
@@ -238,8 +176,6 @@ int wait_for_event_or_timeout(struct cc33xx *wl, u32 mask, bool *timeout)
 	return ret;
 }
 
-
-
 int cc33xx_wait_for_event(struct cc33xx *wl, enum wlcore_wait_event event,
 			  bool *timeout)
 {
@@ -261,155 +197,14 @@ int cc33xx_wait_for_event(struct cc33xx *wl, enum wlcore_wait_event event,
 	return wait_for_event_or_timeout(wl, local_event, timeout);
 }
 
-
-int wlcore_event_fw_logger(struct cc33xx *wl)
-{
-	int ret;
-	struct fw_logger_information fw_log;
-	u8  *buffer;
-	u32 internal_fw_addrbase = CC33XX_DATA_RAM_BASE_ADDRESS;
-	u32 addr = CC33XX_LOGGER_SDIO_BUFF_ADDR;
-	u32 end_buff_addr = CC33XX_LOGGER_SDIO_BUFF_ADDR +
-				CC33XX_LOGGER_BUFF_OFFSET;
-	u32 available_len;
-	u32 actual_len;
-	u32 clear_addr;
-	size_t len;
-	u32 start_loc;
-
-	buffer = kzalloc(CC33XX_LOGGER_SDIO_BUFF_MAX, GFP_KERNEL);
-	if (!buffer) {
-		cc33xx_error("Fail to allocate fw logger memory");
-		fw_log.actual_buff_size = cpu_to_le32(0);
-		goto out;
-	}
-
-	ret = wlcore_read(wl, addr, buffer, CC33XX_LOGGER_SDIO_BUFF_MAX,
-			  false);
-	if (ret < 0) {
-		cc33xx_error("Fail to read logger buffer, error_id = %d",
-			     ret);
-		fw_log.actual_buff_size = cpu_to_le32(0);
-		goto free_out;
-	}
-
-	memcpy(&fw_log, buffer, sizeof(fw_log));
-
-	if (le32_to_cpu(fw_log.actual_buff_size) == 0)
-		goto free_out;
-
-	actual_len = le32_to_cpu(fw_log.actual_buff_size);
-	start_loc = (le32_to_cpu(fw_log.buff_read_ptr) -
-			internal_fw_addrbase) - addr;
-	end_buff_addr += le32_to_cpu(fw_log.max_buff_size);
-	available_len = end_buff_addr -
-			(le32_to_cpu(fw_log.buff_read_ptr) -
-				 internal_fw_addrbase);
-	actual_len = min(actual_len, available_len);
-	len = actual_len;
-
-	cc33xx_copy_fwlog(wl, &buffer[start_loc], len);
-	clear_addr = addr + start_loc + le32_to_cpu(fw_log.actual_buff_size) +
-			internal_fw_addrbase;
-
-	len = le32_to_cpu(fw_log.actual_buff_size) - len;
-	if (len) {
-		cc33xx_copy_fwlog(wl,
-				  &buffer[CC33XX_LOGGER_BUFF_OFFSET],
-				  len);
-		clear_addr = addr + CC33XX_LOGGER_BUFF_OFFSET + len +
-				internal_fw_addrbase;
-	}
-
-	/* double check that clear address and write pointer are the same */
-	if (clear_addr != le32_to_cpu(fw_log.buff_write_ptr)) {
-		cc33xx_error("Calculate of clear addr Clear = %x, write = %x",
-			     clear_addr, le32_to_cpu(fw_log.buff_write_ptr));
-	}
-
-	/* indicate FW about Clear buffer */
-	//ret = wlcore_write32(wl, addr + CC33XX_LOGGER_READ_POINT_OFFSET,
-	//			     fw_log.buff_write_ptr);
-free_out:
-	kfree(buffer);
-out:
-	return le32_to_cpu(fw_log.actual_buff_size);
-}
-
-void wlcore_event_rssi_trigger(struct cc33xx *wl, s8 *metric_arr)
-{
-	struct cc33xx_vif *wlvif;
-	struct ieee80211_vif *vif;
-	enum nl80211_cqm_rssi_threshold_event event;
-	s8 metric = metric_arr[0];
-
-	cc33xx_debug(DEBUG_EVENT, "RSSI trigger metric: %d", metric);
-
-	/* TODO: check actual multi-role support */
-	cc33xx_for_each_wlvif_sta(wl, wlvif) {
-		if (metric <= wlvif->rssi_thold)
-			event = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;
-		else
-			event = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;
-
-		vif = cc33xx_wlvif_to_vif(wlvif);
-		if (event != wlvif->last_rssi_event)
-			ieee80211_cqm_rssi_notify(vif, event, metric,
-						  GFP_KERNEL);
-		wlvif->last_rssi_event = event;
-	}
-}
-
-static void cc33xx_stop_ba_event(struct cc33xx *wl, struct cc33xx_vif *wlvif)
-{
-	struct ieee80211_vif *vif = cc33xx_wlvif_to_vif(wlvif);
-
-	if (wlvif->bss_type != BSS_TYPE_AP_BSS) {
-		u8 hlid = wlvif->sta.hlid;
-		if (!wl->links[hlid].ba_bitmap)
-			return;
-		ieee80211_stop_rx_ba_session(vif, wl->links[hlid].ba_bitmap,
-					     vif->bss_conf.bssid);
-	} else {
-		u8 hlid;
-		struct cc33xx_link *lnk;
-		for_each_set_bit(hlid, wlvif->ap.sta_hlid_map,
-				 wl->num_links) {
-			lnk = &wl->links[hlid];
-			if (!lnk->ba_bitmap)
-				continue;
-
-			ieee80211_stop_rx_ba_session(vif,
-						     lnk->ba_bitmap,
-						     lnk->addr);
-		}
-	}
-}
-
-void wlcore_event_soft_gemini_sense(struct cc33xx *wl, u8 enable)
+void wlcore_event_sched_scan_completed(struct cc33xx *wl, u8 status)
 {
-	struct cc33xx_vif *wlvif;
-
-	if (enable) {
-		set_bit(CC33XX_FLAG_SOFT_GEMINI, &wl->flags);
-	} else {
-		clear_bit(CC33XX_FLAG_SOFT_GEMINI, &wl->flags);
-		cc33xx_for_each_wlvif_sta(wl, wlvif) {
-			cc33xx_recalc_rx_streaming(wl, wlvif);
-		}
-	}
-}
+	cc33xx_debug(DEBUG_EVENT,
+		     "PERIODIC_SCAN_COMPLETE_EVENT (status 0x%0x)", status);
 
-void wlcore_event_sched_scan_completed(struct cc33xx *wl,
-				       u8 status)
-{
-	cc33xx_debug(DEBUG_EVENT, "PERIODIC_SCAN_COMPLETE_EVENT (status 0x%0x)",
-		     status);
-
-	if (wl->mac80211_scan_stopped){
+	if (wl->mac80211_scan_stopped) {
 		wl->mac80211_scan_stopped = false;
-	}
-	else{
+	} else {
 		if (wl->sched_vif) {
 			ieee80211_sched_scan_stopped(wl->hw);
 			wl->sched_vif = NULL;
@@ -418,28 +213,7 @@ void wlcore_event_sched_scan_completed(struct cc33xx *wl,
 
 }
 
-void wlcore_event_ba_rx_constraint(struct cc33xx *wl,
-				   unsigned long roles_bitmap,
-				   unsigned long allowed_bitmap)
-{
-	struct cc33xx_vif *wlvif;
-
-	cc33xx_debug(DEBUG_EVENT, "%s: roles=0x%lx allowed=0x%lx",
-		     __func__, roles_bitmap, allowed_bitmap);
-
-	cc33xx_for_each_wlvif(wl, wlvif) {
-		if (wlvif->role_id == CC33XX_INVALID_ROLE_ID ||
-		    !test_bit(wlvif->role_id , &roles_bitmap))
-			continue;
-
-		wlvif->ba_allowed = !!test_bit(wlvif->role_id,
-					       &allowed_bitmap);
-		if (!wlvif->ba_allowed)
-			cc33xx_stop_ba_event(wl, wlvif);
-	}
-}
-
-void wlcore_event_channel_switch(struct cc33xx *wl,
+void cc33xx_event_channel_switch(struct cc33xx *wl,
 				 unsigned long roles_bitmap,
 				 bool success)
 {
@@ -470,17 +244,6 @@ void wlcore_event_channel_switch(struct cc33xx *wl,
 	}
 }
 
-void wlcore_event_dummy_packet(struct cc33xx *wl)
-{
-	if (wl->plt) {
-		cc33xx_info("Got DUMMY_PACKET event in PLT mode.  FW bug, ignoring.");
-		return;
-	}
-
-	cc33xx_debug(DEBUG_EVENT, "DUMMY_PACKET_ID_EVENT_ID");
-	cc33xx_tx_dummy_packet(wl);
-}
-
 static void wlcore_disconnect_sta(struct cc33xx *wl, unsigned long sta_bitmap)
 {
 	u32 num_packets = wl->conf.host_conf.tx.max_tx_retries;
@@ -490,7 +253,7 @@ static void wlcore_disconnect_sta(struct cc33xx *wl, unsigned long sta_bitmap)
 	const u8 *addr;
 	int h;
 
-	for_each_set_bit(h, &sta_bitmap, wl->num_links) {
+	for_each_set_bit(h, &sta_bitmap, CC33XX_MAX_LINKS) {
 		bool found = false;
 		/* find the ap vif connected to this sta */
 		cc33xx_for_each_wlvif_ap(wl, wlvif) {
@@ -515,26 +278,22 @@ static void wlcore_disconnect_sta(struct cc33xx *wl, unsigned long sta_bitmap)
 	}
 }
 
-void wlcore_event_max_tx_failure(struct cc33xx *wl, unsigned long sta_bitmap)
+static void wlcore_event_max_tx_failure(struct cc33xx *wl,
+					unsigned long sta_bitmap)
 {
 	cc33xx_debug(DEBUG_EVENT, "MAX_TX_FAILURE_EVENT_ID");
 	wlcore_disconnect_sta(wl, sta_bitmap);
 }
 
-void wlcore_event_inactive_sta(struct cc33xx *wl, unsigned long sta_bitmap)
-{
-	cc33xx_debug(DEBUG_EVENT, "INACTIVE_STA_EVENT_ID");
-	wlcore_disconnect_sta(wl, sta_bitmap);
-}
-
-void wlcore_event_roc_complete(struct cc33xx *wl)
+static void wlcore_event_roc_complete(struct cc33xx *wl)
 {
 	cc33xx_debug(DEBUG_EVENT, "REMAIN_ON_CHANNEL_COMPLETE_EVENT_ID");
 	if (wl->roc_vif)
 		ieee80211_ready_on_channel(wl->hw);
 }
 
-void wlcore_event_beacon_loss(struct cc33xx *wl, unsigned long roles_bitmap)
+static void wlcore_event_beacon_loss(struct cc33xx *wl,
+				     unsigned long roles_bitmap)
 {
 	/*
 	 * We are HW_MONITOR device. On beacon loss - queue
@@ -542,14 +301,14 @@ void wlcore_event_beacon_loss(struct cc33xx *wl, unsigned long roles_bitmap)
 	 */
 	struct cc33xx_vif *wlvif;
 	struct ieee80211_vif *vif;
-	int delay = wl->conf.host_conf.conn.synch_fail_thold *
-				wl->conf.host_conf.conn.bss_lose_timeout;
+	int delay = wl->conf.host_conf.conn.synch_fail_thold;
+	delay *= wl->conf.host_conf.conn.bss_lose_timeout;
 
 	cc33xx_info("Beacon loss detected. roles:0x%lx", roles_bitmap);
 
 	cc33xx_for_each_wlvif_sta(wl, wlvif) {
 		if (wlvif->role_id == CC33XX_INVALID_ROLE_ID ||
-		    !test_bit(wlvif->role_id , &roles_bitmap))
+		    !test_bit(wlvif->role_id, &roles_bitmap))
 			continue;
 
 		vif = cc33xx_wlvif_to_vif(wlvif);
@@ -573,14 +332,67 @@ void wlcore_event_beacon_loss(struct cc33xx *wl, unsigned long roles_bitmap)
 	}
 }
 
-int cc33xx_event_unmask(struct cc33xx *wl)
+void process_deferred_events(struct cc33xx *wl)
 {
-	int ret;
+	struct event_node *event_node, *tmp;
+	struct llist_node *event_list;
+	u32 vector;
 
-	cc33xx_debug(DEBUG_EVENT, "unmasking event_mask 0x%x", wl->event_mask);
-	ret = cc33xx_acx_event_mbox_mask(wl, ~(wl->event_mask));
-	if (ret < 0)
-		return ret;
+	event_list = get_event_list(wl);
+
+	llist_for_each_entry_safe(event_node, tmp, event_list, node) {
+
+		struct cc33xx_event_mailbox *event_data;
+
+		event_data = &event_node->event_data;
+
+		print_hex_dump(KERN_DEBUG, "Deferred event dump:",
+			       DUMP_PREFIX_OFFSET, 4, 4, event_data, 64, false);
+
+		vector = le32_to_cpu(event_node->event_data.events_vector);
+		cc33xx_debug(DEBUG_EVENT, "MBOX vector: 0x%x", vector);
 
-	return 0;
+		if (vector & SCAN_COMPLETE_EVENT_ID) {
+			cc33xx_debug(DEBUG_EVENT, "scan results: %d",
+				event_node->event_data.number_of_scan_results);
+
+			if (wl->scan_wlvif)
+				cc33xx_scan_completed(wl, wl->scan_wlvif);
+		}
+
+		if (vector & PERIODIC_SCAN_COMPLETE_EVENT_ID)
+			wlcore_event_sched_scan_completed(wl, 1);
+
+		if (vector & BSS_LOSS_EVENT_ID) {
+			wlcore_event_beacon_loss(wl, le16_to_cpu(
+						event_data->bss_loss_bitmap));
+		}
+
+		if (vector & MAX_TX_FAILURE_EVENT_ID) {
+			wlcore_event_max_tx_failure(wl, le16_to_cpu(
+					event_data->tx_retry_exceeded_bitmap));
+		}
+
+		if (vector & PERIODIC_SCAN_REPORT_EVENT_ID) {
+			cc33xx_debug(DEBUG_EVENT,
+				     "PERIODIC_SCAN_REPORT_EVENT (results %d)",
+				     event_data->number_of_sched_scan_results);
+
+			wlcore_scan_sched_scan_results(wl);
+		}
+
+		if (vector & CHANNEL_SWITCH_COMPLETE_EVENT_ID)
+		{
+			cc33xx_debug(DEBUG_EVENT,
+				     "CHANNEL_SWITCH_COMPLETE_EVENT_ID");
+			cc33xx_event_channel_switch(wl,
+				le16_to_cpu(event_data->channel_switch_role_id_bitmap),
+						    true);
+		}
+
+		if (vector & REMAIN_ON_CHANNEL_COMPLETE_EVENT_ID)
+			wlcore_event_roc_complete(wl);
+
+		kfree(event_node);
+	}
 }
diff --git a/drivers/net/wireless/ti/cc33xx/event.h b/drivers/net/wireless/ti/cc33xx/event.h
index 5b22cff49141..3c5df01fdb14 100644
--- a/drivers/net/wireless/ti/cc33xx/event.h
+++ b/drivers/net/wireless/ti/cc33xx/event.h
@@ -54,7 +54,7 @@ enum {
 	SMART_CONFIG_SYNC_EVENT_ID               = BIT(22),
 	SMART_CONFIG_DECODE_EVENT_ID             = BIT(23),
 	TIME_SYNC_EVENT_ID                       = BIT(24),
-	FW_LOGGER_INDICATION			= BIT(25),
+	FW_LOGGER_INDICATION                     = BIT(25),
 };
 
 /* events the driver might want to wait for */
@@ -64,47 +64,15 @@ enum wlcore_wait_event {
 	WLCORE_EVENT_DFS_CONFIG_COMPLETE
 };
 
-enum {
-	EVENT_ENTER_POWER_SAVE_FAIL = 0,
-	EVENT_ENTER_POWER_SAVE_SUCCESS,
-};
-
-
 #define NUM_OF_RSSI_SNR_TRIGGERS 8
 
-struct fw_logger_information {
-	__le32 max_buff_size;
-	__le32 actual_buff_size;
-	__le32 num_trace_drop;
-	__le32 buff_read_ptr;
-	__le32 buff_write_ptr;
-} __packed;
-
 struct cc33xx;
 
-int cc33xx_event_unmask(struct cc33xx *wl);
-
-void wlcore_event_soft_gemini_sense(struct cc33xx *wl, u8 enable);
-void wlcore_event_sched_scan_completed(struct cc33xx *wl,
-				       u8 status);
-void wlcore_event_ba_rx_constraint(struct cc33xx *wl,
-				   unsigned long roles_bitmap,
-				   unsigned long allowed_bitmap);
-void wlcore_event_channel_switch(struct cc33xx *wl,
-				 unsigned long roles_bitmap,
-				 bool success);
-void wlcore_event_beacon_loss(struct cc33xx *wl, unsigned long roles_bitmap);
-void wlcore_event_dummy_packet(struct cc33xx *wl);
-void wlcore_event_max_tx_failure(struct cc33xx *wl, unsigned long sta_bitmap);
-void wlcore_event_inactive_sta(struct cc33xx *wl, unsigned long sta_bitmap);
-void wlcore_event_roc_complete(struct cc33xx *wl);
-void wlcore_event_rssi_trigger(struct cc33xx *wl, s8 *metric_arr);
-int  wlcore_event_fw_logger(struct cc33xx *wl);
-
 int cc33xx_wait_for_event(struct cc33xx *wl, enum wlcore_wait_event event,
 			  bool *timeout);
-
 void deffer_event(struct cc33xx *wl, const void *event_payload, size_t event_length);
 void process_deferred_events(struct cc33xx *wl);
 void flush_deferred_event_list(struct cc33xx *wl);
-#endif
+
+
+#endif /* __EVENT_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/ini.h b/drivers/net/wireless/ti/cc33xx/ini.h
deleted file mode 100644
index 4379aa25e0e0..000000000000
--- a/drivers/net/wireless/ti/cc33xx/ini.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * This file is part of wl1271
- *
- * Copyright (C) 2010 Nokia Corporation
- *
- * Contact: Luciano Coelho <luciano.coelho@nokia.com>
- */
-
-#ifndef __INI_H__
-#define __INI_H__
-
-#define GENERAL_SETTINGS_DRPW_LPD 0xc0
-#define SCRATCH_ENABLE_LPD        BIT(25)
-
-#define WL1271_INI_MAX_SMART_REFLEX_PARAM 16
-
-struct wl1271_ini_general_params {
-	u8 ref_clock;
-	u8 settling_time;
-	u8 clk_valid_on_wakeup;
-	u8 dc2dc_mode;
-	u8 dual_mode_select;
-	u8 tx_bip_fem_auto_detect;
-	u8 tx_bip_fem_manufacturer;
-	u8 general_settings;
-	u8 sr_state;
-	u8 srf1[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-	u8 srf2[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-	u8 srf3[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-} __packed;
-
-#define WL128X_INI_MAX_SETTINGS_PARAM 4
-
-struct wl128x_ini_general_params {
-	u8 ref_clock;
-	u8 settling_time;
-	u8 clk_valid_on_wakeup;
-	u8 tcxo_ref_clock;
-	u8 tcxo_settling_time;
-	u8 tcxo_valid_on_wakeup;
-	u8 tcxo_ldo_voltage;
-	u8 xtal_itrim_val;
-	u8 platform_conf;
-	u8 dual_mode_select;
-	u8 tx_bip_fem_auto_detect;
-	u8 tx_bip_fem_manufacturer;
-	u8 general_settings[WL128X_INI_MAX_SETTINGS_PARAM];
-	u8 sr_state;
-	u8 srf1[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-	u8 srf2[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-	u8 srf3[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-} __packed;
-
-#define WL1271_INI_RSSI_PROCESS_COMPENS_SIZE 15
-
-struct wl1271_ini_band_params_2 {
-	u8 rx_trace_insertion_loss;
-	u8 tx_trace_loss;
-	u8 rx_rssi_process_compens[WL1271_INI_RSSI_PROCESS_COMPENS_SIZE];
-} __packed;
-
-#define WL1271_INI_CHANNEL_COUNT_2 14
-
-struct wl128x_ini_band_params_2 {
-	u8 rx_trace_insertion_loss;
-	u8 tx_trace_loss[WL1271_INI_CHANNEL_COUNT_2];
-	u8 rx_rssi_process_compens[WL1271_INI_RSSI_PROCESS_COMPENS_SIZE];
-} __packed;
-
-#define WL1271_INI_RATE_GROUP_COUNT 6
-
-struct wl1271_ini_fem_params_2 {
-	__le16 tx_bip_ref_pd_voltage;
-	u8 tx_bip_ref_power;
-	u8 tx_bip_ref_offset;
-	u8 tx_per_rate_pwr_limits_normal[WL1271_INI_RATE_GROUP_COUNT];
-	u8 tx_per_rate_pwr_limits_degraded[WL1271_INI_RATE_GROUP_COUNT];
-	u8 tx_per_rate_pwr_limits_extreme[WL1271_INI_RATE_GROUP_COUNT];
-	u8 tx_per_chan_pwr_limits_11b[WL1271_INI_CHANNEL_COUNT_2];
-	u8 tx_per_chan_pwr_limits_ofdm[WL1271_INI_CHANNEL_COUNT_2];
-	u8 tx_pd_vs_rate_offsets[WL1271_INI_RATE_GROUP_COUNT];
-	u8 tx_ibias[WL1271_INI_RATE_GROUP_COUNT];
-	u8 rx_fem_insertion_loss;
-	u8 degraded_low_to_normal_thr;
-	u8 normal_to_degraded_high_thr;
-} __packed;
-
-#define WL128X_INI_RATE_GROUP_COUNT 7
-/* low and high temperatures */
-#define WL128X_INI_PD_VS_TEMPERATURE_RANGES 2
-
-struct wl128x_ini_fem_params_2 {
-	__le16 tx_bip_ref_pd_voltage;
-	u8 tx_bip_ref_power;
-	u8 tx_bip_ref_offset;
-	u8 tx_per_rate_pwr_limits_normal[WL128X_INI_RATE_GROUP_COUNT];
-	u8 tx_per_rate_pwr_limits_degraded[WL128X_INI_RATE_GROUP_COUNT];
-	u8 tx_per_rate_pwr_limits_extreme[WL128X_INI_RATE_GROUP_COUNT];
-	u8 tx_per_chan_pwr_limits_11b[WL1271_INI_CHANNEL_COUNT_2];
-	u8 tx_per_chan_pwr_limits_ofdm[WL1271_INI_CHANNEL_COUNT_2];
-	u8 tx_pd_vs_rate_offsets[WL128X_INI_RATE_GROUP_COUNT];
-	u8 tx_ibias[WL128X_INI_RATE_GROUP_COUNT + 1];
-	u8 tx_pd_vs_chan_offsets[WL1271_INI_CHANNEL_COUNT_2];
-	u8 tx_pd_vs_temperature[WL128X_INI_PD_VS_TEMPERATURE_RANGES];
-	u8 rx_fem_insertion_loss;
-	u8 degraded_low_to_normal_thr;
-	u8 normal_to_degraded_high_thr;
-} __packed;
-
-#define WL1271_INI_CHANNEL_COUNT_5 35
-#define WL1271_INI_SUB_BAND_COUNT_5 7
-
-struct wl1271_ini_band_params_5 {
-	u8 rx_trace_insertion_loss[WL1271_INI_SUB_BAND_COUNT_5];
-	u8 tx_trace_loss[WL1271_INI_SUB_BAND_COUNT_5];
-	u8 rx_rssi_process_compens[WL1271_INI_RSSI_PROCESS_COMPENS_SIZE];
-} __packed;
-
-struct wl128x_ini_band_params_5 {
-	u8 rx_trace_insertion_loss[WL1271_INI_SUB_BAND_COUNT_5];
-	u8 tx_trace_loss[WL1271_INI_CHANNEL_COUNT_5];
-	u8 rx_rssi_process_compens[WL1271_INI_RSSI_PROCESS_COMPENS_SIZE];
-} __packed;
-
-struct wl1271_ini_fem_params_5 {
-	__le16 tx_bip_ref_pd_voltage[WL1271_INI_SUB_BAND_COUNT_5];
-	u8 tx_bip_ref_power[WL1271_INI_SUB_BAND_COUNT_5];
-	u8 tx_bip_ref_offset[WL1271_INI_SUB_BAND_COUNT_5];
-	u8 tx_per_rate_pwr_limits_normal[WL1271_INI_RATE_GROUP_COUNT];
-	u8 tx_per_rate_pwr_limits_degraded[WL1271_INI_RATE_GROUP_COUNT];
-	u8 tx_per_rate_pwr_limits_extreme[WL1271_INI_RATE_GROUP_COUNT];
-	u8 tx_per_chan_pwr_limits_ofdm[WL1271_INI_CHANNEL_COUNT_5];
-	u8 tx_pd_vs_rate_offsets[WL1271_INI_RATE_GROUP_COUNT];
-	u8 tx_ibias[WL1271_INI_RATE_GROUP_COUNT];
-	u8 rx_fem_insertion_loss[WL1271_INI_SUB_BAND_COUNT_5];
-	u8 degraded_low_to_normal_thr;
-	u8 normal_to_degraded_high_thr;
-} __packed;
-
-struct wl128x_ini_fem_params_5 {
-	__le16 tx_bip_ref_pd_voltage[WL1271_INI_SUB_BAND_COUNT_5];
-	u8 tx_bip_ref_power[WL1271_INI_SUB_BAND_COUNT_5];
-	u8 tx_bip_ref_offset[WL1271_INI_SUB_BAND_COUNT_5];
-	u8 tx_per_rate_pwr_limits_normal[WL128X_INI_RATE_GROUP_COUNT];
-	u8 tx_per_rate_pwr_limits_degraded[WL128X_INI_RATE_GROUP_COUNT];
-	u8 tx_per_rate_pwr_limits_extreme[WL128X_INI_RATE_GROUP_COUNT];
-	u8 tx_per_chan_pwr_limits_ofdm[WL1271_INI_CHANNEL_COUNT_5];
-	u8 tx_pd_vs_rate_offsets[WL128X_INI_RATE_GROUP_COUNT];
-	u8 tx_ibias[WL128X_INI_RATE_GROUP_COUNT];
-	u8 tx_pd_vs_chan_offsets[WL1271_INI_CHANNEL_COUNT_5];
-	u8 tx_pd_vs_temperature[WL1271_INI_SUB_BAND_COUNT_5 *
-		WL128X_INI_PD_VS_TEMPERATURE_RANGES];
-	u8 rx_fem_insertion_loss[WL1271_INI_SUB_BAND_COUNT_5];
-	u8 degraded_low_to_normal_thr;
-	u8 normal_to_degraded_high_thr;
-} __packed;
-
-/* NVS data structure */
-#define WL1271_INI_NVS_SECTION_SIZE		     468
-
-/* We have four FEM module types: 0-RFMD, 1-TQS, 2-SKW, 3-TQS_HP */
-#define WL1271_INI_FEM_MODULE_COUNT                  4
-
-/*
- * In NVS we only store two FEM module entries -
- *	  FEM modules 0,2,3 are stored in entry 0
- *	  FEM module 1 is stored in entry 1
- */
-#define WL12XX_NVS_FEM_MODULE_COUNT                  2
-
-#define WL12XX_FEM_TO_NVS_ENTRY(ini_fem_module)      \
-	((ini_fem_module) == 1 ? 1 : 0)
-
-#define WL1271_INI_LEGACY_NVS_FILE_SIZE              800
-
-struct wl1271_nvs_file {
-	/* NVS section - must be first! */
-	u8 nvs[WL1271_INI_NVS_SECTION_SIZE];
-
-	/* INI section */
-	struct wl1271_ini_general_params general_params;
-	u8 padding1;
-	struct wl1271_ini_band_params_2 stat_radio_params_2;
-	u8 padding2;
-	struct {
-		struct wl1271_ini_fem_params_2 params;
-		u8 padding;
-	} dyn_radio_params_2[WL12XX_NVS_FEM_MODULE_COUNT];
-	struct wl1271_ini_band_params_5 stat_radio_params_5;
-	u8 padding3;
-	struct {
-		struct wl1271_ini_fem_params_5 params;
-		u8 padding;
-	} dyn_radio_params_5[WL12XX_NVS_FEM_MODULE_COUNT];
-} __packed;
-
-struct wl128x_nvs_file {
-	/* NVS section - must be first! */
-	u8 nvs[WL1271_INI_NVS_SECTION_SIZE];
-
-	/* INI section */
-	struct wl128x_ini_general_params general_params;
-	u8 fem_vendor_and_options;
-	struct wl128x_ini_band_params_2 stat_radio_params_2;
-	u8 padding2;
-	struct {
-		struct wl128x_ini_fem_params_2 params;
-		u8 padding;
-	} dyn_radio_params_2[WL12XX_NVS_FEM_MODULE_COUNT];
-	struct wl128x_ini_band_params_5 stat_radio_params_5;
-	u8 padding3;
-	struct {
-		struct wl128x_ini_fem_params_5 params;
-		u8 padding;
-	} dyn_radio_params_5[WL12XX_NVS_FEM_MODULE_COUNT];
-} __packed;
-#endif
diff --git a/drivers/net/wireless/ti/cc33xx/init.c b/drivers/net/wireless/ti/cc33xx/init.c
index 5fbd72f0d7d9..1b7f03b1e820 100644
--- a/drivers/net/wireless/ti/cc33xx/init.c
+++ b/drivers/net/wireless/ti/cc33xx/init.c
@@ -7,115 +7,19 @@
  * Contact: Luciano Coelho <luciano.coelho@nokia.com>
  */
 
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/slab.h>
 #include <linux/firmware.h>
-
-#include "debug.h"
-#include "init.h"
-#include "cc33xx_80211.h"
 #include "acx.h"
+#include "cc33xx_80211.h"
 #include "cmd.h"
+#include "conf.h"
+#include "event.h"
 #include "tx.h"
-#include "io.h"
 
 #define PG2_CHIP_VERSION    2
 
-static int cc33xx_ap_init_deauth_template(struct cc33xx *wl,
-					  struct cc33xx_vif *wlvif)
-{
-	struct cc33xx_disconn_template *tmpl;
-	int ret;
-	u32 rate;
-
-	tmpl = kzalloc(sizeof(*tmpl), GFP_KERNEL);
-	if (!tmpl) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	tmpl->header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT |
-					     IEEE80211_STYPE_DEAUTH);
-
-	rate = cc33xx_tx_min_rate_get(wl, wlvif->basic_rate_set);
-	ret = cc33xx_cmd_template_set(wl, wlvif->role_id,
-				      CMD_TEMPL_DEAUTH_AP,
-				      tmpl, sizeof(*tmpl), 0, rate);
-
-out:
-	kfree(tmpl);
-	return ret;
-}
-
-static int cc33xx_ap_init_null_template(struct cc33xx *wl,
-					struct ieee80211_vif *vif)
-{
-	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
-	struct ieee80211_hdr_3addr *nullfunc;
-	int ret;
-	u32 rate;
-
-	nullfunc = kzalloc(sizeof(*nullfunc), GFP_KERNEL);
-	if (!nullfunc) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	nullfunc->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
-					      IEEE80211_STYPE_NULLFUNC |
-					      IEEE80211_FCTL_FROMDS);
-
-	/* nullfunc->addr1 is filled by FW */
-
-	memcpy(nullfunc->addr2, vif->addr, ETH_ALEN);
-	memcpy(nullfunc->addr3, vif->addr, ETH_ALEN);
-
-	rate = cc33xx_tx_min_rate_get(wl, wlvif->basic_rate_set);
-	ret = cc33xx_cmd_template_set(wl, wlvif->role_id,
-				      CMD_TEMPL_NULL_DATA, nullfunc,
-				      sizeof(*nullfunc), 0, rate);
-
-out:
-	kfree(nullfunc);
-	return ret;
-}
-
-static int cc33xx_ap_init_qos_null_template(struct cc33xx *wl,
-					    struct ieee80211_vif *vif)
-{
-	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
-	struct ieee80211_qos_hdr *qosnull;
-	int ret;
-	u32 rate;
-
-	qosnull = kzalloc(sizeof(*qosnull), GFP_KERNEL);
-	if (!qosnull) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	qosnull->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
-					     IEEE80211_STYPE_QOS_NULLFUNC |
-					     IEEE80211_FCTL_FROMDS);
-
-	/* qosnull->addr1 is filled by FW */
-
-	memcpy(qosnull->addr2, vif->addr, ETH_ALEN);
-	memcpy(qosnull->addr3, vif->addr, ETH_ALEN);
-
-	rate = cc33xx_tx_min_rate_get(wl, wlvif->basic_rate_set);
-	ret = cc33xx_cmd_template_set(wl, wlvif->role_id,
-				      CMD_TEMPL_QOS_NULL_DATA, qosnull,
-				      sizeof(*qosnull), 0, rate);
-
-out:
-	kfree(qosnull);
-	return ret;
-}
 
 static int cc33xx_init_phy_vif_config(struct cc33xx *wl,
-					    struct cc33xx_vif *wlvif)
+				      struct cc33xx_vif *wlvif)
 {
 	int ret;
 
@@ -151,17 +55,6 @@ static int cc33xx_init_sta_beacon_filter(struct cc33xx *wl,
 	return 0;
 }
 
-int cc33xx_init_energy_detection(struct cc33xx *wl)
-{
-	int ret;
-
-	ret = cc33xx_acx_cca_threshold(wl);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
 static int cc33xx_init_beacon_broadcast(struct cc33xx *wl,
 					struct cc33xx_vif *wlvif)
 {
@@ -175,7 +68,7 @@ static int cc33xx_init_beacon_broadcast(struct cc33xx *wl,
 }
 
 /* generic sta initialization (non vif-specific) */
-int cc33xx_sta_hw_init(struct cc33xx *wl, struct cc33xx_vif *wlvif)
+static int cc33xx_sta_hw_init(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 {
 	int ret;
 
@@ -199,23 +92,12 @@ static int cc33xx_ap_hw_init(struct cc33xx *wl)
 	return 0;
 }
 
-int cc33xx_ap_init_templates(struct cc33xx *wl, struct ieee80211_vif *vif)
+static int cc33xx_ap_init_templates(struct cc33xx *wl,
+				    struct ieee80211_vif *vif)
 {
 	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
 	int ret;
 
-	ret = cc33xx_ap_init_deauth_template(wl, wlvif);
-	if (ret < 0)
-		return ret;
-
-	ret = cc33xx_ap_init_null_template(wl, vif);
-	if (ret < 0)
-		return ret;
-
-	ret = cc33xx_ap_init_qos_null_template(wl, vif);
-	if (ret < 0)
-		return ret;
-
 	/*
 	 * when operating as AP we want to receive external beacons for
 	 * configuring ERP protection.
@@ -227,14 +109,6 @@ int cc33xx_ap_init_templates(struct cc33xx *wl, struct ieee80211_vif *vif)
 	return 0;
 }
 
-static int cc33xx_ap_hw_init_post_mem(struct cc33xx *wl,
-				      struct ieee80211_vif *vif)
-{
-	return cc33xx_ap_init_templates(wl, vif);
-}
-
-
-
 static int cc33xx_set_ba_policies(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 {
 	/* Reset the BA RX indicators */
@@ -257,9 +131,7 @@ static int cc33xx_set_ba_policies(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 /* Applies when MAC address is other than 0x0.
  * Routine for actual search in file
  * data_ptr returned contains the pointer to entry. */
-static bool find_calibration_entry(u8 *id,
-				  u8 **data_ptr,
-				  u8 *stop_address)
+static bool find_calibration_entry(u8 *id, u8 **data_ptr, u8 *stop_address)
 {
 	u8 default_mac_address[ETH_ALEN] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
 	struct calibration_header *calibration_header;
@@ -271,17 +143,18 @@ static bool find_calibration_entry(u8 *id,
 
 	while (*data_ptr < stop_address)
 	{
-		// Cast to a struct for convenient fields reading
+		/* Cast to a struct for convenient fields reading */
 		calibration_header = (struct calibration_header *)(*data_ptr);
 		calibration_header_fw = &(calibration_header->cal_header_fw);
 
 		if (le16_to_cpu(calibration_header->static_pattern) != 0x7F7F) {
-		cc33xx_debug(DEBUG_BOOT, "Problem with sync pattern, read: %x",
-					 le16_to_cpu(calibration_header->static_pattern));
-		break;
+			cc33xx_debug(DEBUG_BOOT,
+				     "Problem with sync pattern, read: %x",
+				     le16_to_cpu(calibration_header->static_pattern));
+			break;
 		}
 
-		// Compare with actual mac address
+		/* Compare with actual mac address */
 		compare_result = memcmp(calibration_header_fw->chip_id, id,
 					ETH_ALEN);
 		if (0 == compare_result) {
@@ -290,15 +163,15 @@ static bool find_calibration_entry(u8 *id,
 			break;
 		}
 
-		// Compare with default mac address, if it's found save it for
-		// later if necessary (if no calibration for id is found)
+		/* Compare with default mac address, if it's found save it for
+		 * later if necessary (if no calibration for id is found) */
 		compare_result = memcmp(calibration_header_fw->chip_id,
 					default_mac_address,
 					ETH_ALEN);
 		if (0 == compare_result)
 			default_calibration = (u8 *)calibration_header;
 
-		// advance ptr by specified payload length to next entry in file
+		/* advance ptr by specified payload length to next entry in file */
 		*data_ptr = (u8 *)((u32)calibration_header
 				+ sizeof(struct calibration_header)
 				+ le16_to_cpu(calibration_header_fw->length));
@@ -307,9 +180,9 @@ static bool find_calibration_entry(u8 *id,
 	if (false == mac_match) {
 		if (NULL != default_calibration) {
 			cc33xx_warning("No calibration for device address, "
-			               "using default calibration"
+				       "using default calibration"
 				       "(labeled mac FF:FF:FF:FF:FF:FF)");
-			// Take default calibration
+			/* Take default calibration */
 			*data_ptr = default_calibration;
 			valid_data = true;
 		} else {
@@ -340,16 +213,16 @@ int download_static_calibration_data(struct cc33xx *wl)
 
 	if(wl->pg_version >= PG2_CHIP_VERSION)
 	{
-		cc33xx_debug(DEBUG_BOOT, "Chip is PG2, No static calibration needed");
+		cc33xx_debug(DEBUG_BOOT,
+			     "Chip is PG2, No static calibration needed");
 		return 1;
 	}
 
-
 	ret = request_firmware(&fw, calibration_file, wl->dev);
 	if (ret < 0) {
 		cc33xx_warning("Could not get firmware %s: %d,"
-				" proceeding with no calibration",
-				calibration_file, ret);
+			       " proceeding with no calibration",
+			       calibration_file, ret);
 		valid_calibration_data = false;
 		file_loaded = false;
 		ret = 0; /* Don't kill driver over this */
@@ -361,12 +234,10 @@ int download_static_calibration_data(struct cc33xx *wl)
 
 	file_header = (struct calibration_file_header *)file_ptr;
 	cc33xx_debug(DEBUG_BOOT, "Parsing static calibration file version: %d, "
-				 "payload struct ver: %d, entries count: %d, "
-				 "file size: %d",
-				 file_header->file_version,
-				 file_header->payload_struct_version,
-				 le16_to_cpu(file_header->entries_count),
-				 fw->size);
+		     "payload struct ver: %d, entries count: %d, file size: %d",
+		     file_header->file_version,
+		     file_header->payload_struct_version,
+		     le16_to_cpu(file_header->entries_count), fw->size);
 
 	/* Limit the search to the file's length and skip 4 file header bytes */
 	mac_address = (u8 *)wl->efuse_mac_address;
@@ -378,8 +249,7 @@ int download_static_calibration_data(struct cc33xx *wl)
 							stop_search_address);
 
 out:
-	ret = cc33xx_acx_static_calibration_configure(wl,
-						      file_header,
+	ret = cc33xx_acx_static_calibration_configure(wl, file_header,
 						      calibration_entry_ptr,
 						      valid_calibration_data);
 	if (file_loaded)
@@ -391,9 +261,7 @@ int download_static_calibration_data(struct cc33xx *wl)
 /* vif-specifc initialization */
 static int cc33xx_init_sta_role(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 {
-	int ret;
-
-	ret = cc33xx_acx_group_address_tbl(wl, wlvif, true, NULL, 0);
+	int ret = cc33xx_acx_group_address_tbl(wl, wlvif, true, NULL, 0);
 	if (ret < 0)
 		return ret;
 
@@ -450,8 +318,9 @@ int cc33xx_init_vif_specific(struct cc33xx *wl, struct ieee80211_vif *vif)
 	struct conf_tx_tid *conf_tid;
 	struct conf_tx_ac_category ac_conf[4];
 	struct conf_tx_tid tid_conf[8];
-	struct conf_tx_ac_category* p_wl_host_ac_conf = &wl->conf.host_conf.tx.ac_conf0;
-	struct conf_tx_tid* p_wl_host_tid_conf = &wl->conf.host_conf.tx.tid_conf0;
+	struct conf_tx_settings *tx_settings = &wl->conf.host_conf.tx;
+	struct conf_tx_ac_category* p_wl_host_ac_conf = &tx_settings->ac_conf0;
+	struct conf_tx_tid* p_wl_host_tid_conf = &tx_settings->tid_conf0;
 	bool is_ap = (wlvif->bss_type == BSS_TYPE_AP_BSS);
 	u8 ps_scheme = wl->conf.mac.ps_scheme;
 	int ret, i;
@@ -465,9 +334,7 @@ int cc33xx_init_vif_specific(struct cc33xx *wl, struct ieee80211_vif *vif)
 
 		/* unmask ap events */
 		wl->event_mask |= wl->ap_event_mask;
-		ret = cc33xx_event_unmask(wl);
-		if (ret < 0)
-			return ret;
+
 	/* first STA, no APs */
 	} else if (wl->sta_count == 0 && wl->ap_count == 0 && !is_ap) {
 		u8 sta_auth = wl->conf.host_conf.conn.sta_sleep_auth;
@@ -482,8 +349,6 @@ int cc33xx_init_vif_specific(struct cc33xx *wl, struct ieee80211_vif *vif)
 			return ret;
 	}
 
-
-
 	/* Mode specific init */
 	if (is_ap) {
 		ret = cc33xx_ap_hw_init(wl);
@@ -506,11 +371,11 @@ int cc33xx_init_vif_specific(struct cc33xx *wl, struct ieee80211_vif *vif)
 	cc33xx_init_phy_vif_config(wl, wlvif);
 
 	/* Default TID/AC configuration */
-	BUG_ON(wl->conf.host_conf.tx.tid_conf_count != wl->conf.host_conf.tx.ac_conf_count);
+	BUG_ON(tx_settings->tid_conf_count != tx_settings->ac_conf_count);
 	memcpy(ac_conf,p_wl_host_ac_conf,4*sizeof(struct conf_tx_ac_category));
 	memcpy(tid_conf,p_wl_host_tid_conf,8*sizeof(struct conf_tx_tid));
 
-	for (i = 0; i < wl->conf.host_conf.tx.tid_conf_count; i++) {
+	for (i = 0; i < tx_settings->tid_conf_count; i++) {
 		conf_ac =  &ac_conf[i];
 		conf_tid = &tid_conf[i];
 
@@ -520,14 +385,15 @@ int cc33xx_init_vif_specific(struct cc33xx *wl, struct ieee80211_vif *vif)
 
 		//TODO: RazB - need to configure MUEDCA
 		ret = cc33xx_tx_param_cfg(wl, wlvif, conf_ac->ac,
-		            conf_ac->cw_min, conf_ac->cw_max,
-		            conf_ac->aifsn, conf_ac->tx_op_limit, false,
-		            ps_scheme, conf_ac->is_mu_edca,
-			    conf_ac->mu_edca_aifs, conf_ac->mu_edca_ecw_min_max,
-			    conf_ac->mu_edca_timer);
+					  conf_ac->cw_min, conf_ac->cw_max,
+					  conf_ac->aifsn, conf_ac->tx_op_limit,
+					  false, ps_scheme, conf_ac->is_mu_edca,
+					  conf_ac->mu_edca_aifs,
+					  conf_ac->mu_edca_ecw_min_max,
+					  conf_ac->mu_edca_timer);
 
 		if (ret < 0)
-		        return ret;
+			return ret;
 	}
 
 	/* Configure HW encryption */
@@ -537,8 +403,7 @@ int cc33xx_init_vif_specific(struct cc33xx *wl, struct ieee80211_vif *vif)
 
 	/* Mode specific init - post mem init */
 	if (is_ap)
-		ret = cc33xx_ap_hw_init_post_mem(wl, vif);
-	else
+		ret = cc33xx_ap_init_templates(wl, vif);
 
 	if (ret < 0)
 		return ret;
@@ -569,38 +434,37 @@ int cc33xx_download_ini_params_and_wait(struct cc33xx *wl)
 	size_t command_size = ALIGN((sizeof(*cmd) + sizeof(wl->conf)),4);
 	int ret;
 
-	if (wl->conf.core.enable_FlowCtrl == 0){
+	if (wl->conf.core.enable_FlowCtrl == 0)
 		cc33xx_warning("flow control disable - BLE will not work");
-	}
 
 	cc33xx_set_max_buffer_size(wl,INI_MAX_BUFFER_SIZE);
 
-	cc33xx_debug(DEBUG_ACX, "Downloading INI Params and Configurations to FW, INI Bin File Payload Length: %d",sizeof(wl->conf));
+	cc33xx_debug(DEBUG_ACX,
+		     "Downloading INI Params and Configurations to FW, "
+		     "INI Bin File Payload Length: %d", sizeof(wl->conf));
 	cmd = kzalloc(command_size, GFP_KERNEL);
 	if (!cmd) {
 		cc33xx_error("INI Params Download: "
-				"process failed due to memory allocation "
-				"failure");
+			     "process failed due to memory allocation failure");
 		cc33xx_set_max_buffer_size(wl,CMD_MAX_BUFFER_SIZE);
 		return -ENOMEM;
 	}
 
-    cmd->length = cpu_to_le32(sizeof(wl->conf));
+	cmd->length = cpu_to_le32(sizeof(wl->conf));
 
 	/* copy INI file params payload */
-	memcpy((cmd->payload), &(wl->conf),
-	       sizeof(wl->conf));
+	memcpy((cmd->payload), &(wl->conf), sizeof(wl->conf));
 
-
-	ret = cc33xx_cmd_send(wl,CMD_DOWNLOAD_INI_PARAMS,cmd,command_size,0);
-	if (ret < 0)
-		cc33xx_warning("download INI params to FW command sending failed: %d", ret);
-	else
+	ret = cc33xx_cmd_send(wl, CMD_DOWNLOAD_INI_PARAMS,
+			      cmd, command_size, 0);
+	if (ret < 0) {
+		cc33xx_warning("download INI params to FW command "
+			       "sending failed: %d", ret);
+	} else {
 		cc33xx_debug(DEBUG_BOOT, "INI Params downloaded successfully");
+	}
 
-
-	cc33xx_set_max_buffer_size(wl,CMD_MAX_BUFFER_SIZE);
+	cc33xx_set_max_buffer_size(wl, CMD_MAX_BUFFER_SIZE);
 	kfree(cmd);
 	return ret;
-
 }
diff --git a/drivers/net/wireless/ti/cc33xx/init.h b/drivers/net/wireless/ti/cc33xx/init.h
index 4c5583e97f43..2ff113b84d42 100644
--- a/drivers/net/wireless/ti/cc33xx/init.h
+++ b/drivers/net/wireless/ti/cc33xx/init.h
@@ -12,12 +12,11 @@
 
 #include "wlcore.h"
 
-int cc33xx_init_energy_detection(struct cc33xx *wl);
+
 int cc33xx_hw_init(struct cc33xx *wl);
 int cc33xx_download_ini_params_and_wait(struct cc33xx *wl);
 int cc33xx_init_vif_specific(struct cc33xx *wl, struct ieee80211_vif *vif);
-int cc33xx_ap_init_templates(struct cc33xx *wl, struct ieee80211_vif *vif);
-int cc33xx_sta_hw_init(struct cc33xx *wl, struct cc33xx_vif *wlvif);
 int download_static_calibration_data(struct cc33xx *wl);
 
-#endif
+
+#endif /* __INIT_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/io.c b/drivers/net/wireless/ti/cc33xx/io.c
index fa067dd5ec9f..ec797e2eb3c9 100644
--- a/drivers/net/wireless/ti/cc33xx/io.c
+++ b/drivers/net/wireless/ti/cc33xx/io.c
@@ -7,17 +7,12 @@
  * Contact: Luciano Coelho <luciano.coelho@nokia.com>
  */
 
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/spi/spi.h>
-#include <linux/interrupt.h>
-
 #include "wlcore.h"
 #include "debug.h"
-#include "cc33xx_80211.h"
 #include "io.h"
 #include "tx.h"
 
+
 bool cc33xx_set_block_size(struct cc33xx *wl)
 {
 	if (wl->if_ops->set_block_size) {
@@ -26,8 +21,9 @@ bool cc33xx_set_block_size(struct cc33xx *wl)
 			"Set BLKsize to %d", CC33XX_BUS_BLOCK_SIZE);
 		return true;
 	}
-	else
+	else {
 		cc33xx_debug(DEBUG_CC33xx, "Could not set BLKsize");
+	}
 	return false;
 }
 
@@ -57,3 +53,83 @@ void cc33xx_io_init(struct cc33xx *wl)
 	if (wl->if_ops->init)
 		wl->if_ops->init(wl->dev);
 }
+
+/* Raw target IO, address is not translated */
+static int __must_check wlcore_raw_write(struct cc33xx *wl, int addr,
+					 void *buf, size_t len, bool fixed)
+{
+	int ret;
+
+	if (test_bit(CC33XX_FLAG_IO_FAILED, &wl->flags) ||
+	    WARN_ON((test_bit(CC33XX_FLAG_IN_ELP, &wl->flags) &&
+		     addr != HW_ACCESS_ELP_CTRL_REG)))
+		return -EIO;
+
+	ret = wl->if_ops->write(wl->dev, addr, buf, len, fixed);
+	if (ret && wl->state != WLCORE_STATE_OFF)
+		set_bit(CC33XX_FLAG_IO_FAILED, &wl->flags);
+
+	return ret;
+}
+
+int __must_check wlcore_raw_read(struct cc33xx *wl, int addr,
+				 void *buf, size_t len, bool fixed)
+{
+	int ret;
+
+	if (test_bit(CC33XX_FLAG_IO_FAILED, &wl->flags) ||
+	    WARN_ON((test_bit(CC33XX_FLAG_IN_ELP, &wl->flags) &&
+		     addr != HW_ACCESS_ELP_CTRL_REG)))
+		return -EIO;
+
+	ret = wl->if_ops->read(wl->dev, addr, buf, len, fixed);
+	if (ret && wl->state != WLCORE_STATE_OFF)
+		set_bit(CC33XX_FLAG_IO_FAILED, &wl->flags);
+
+	return ret;
+}
+
+int __must_check wlcore_write(struct cc33xx *wl, int addr,
+			      void *buf, size_t len, bool fixed)
+{
+	return wlcore_raw_write(wl, addr, buf, len, fixed);
+}
+
+void claim_core_status_lock(struct cc33xx *wl)
+{
+	/* When accessing core-status data (read or write) the transport lock
+	 * should be held. */
+	wl->if_ops->interface_claim(wl->dev);
+}
+
+void release_core_status_lock(struct cc33xx *wl)
+{
+	/* After accessing core-status data (read or write) the transport lock
+	 * should be released. */
+	wl->if_ops->interface_release(wl->dev);
+}
+
+void cc33xx_power_off(struct cc33xx *wl)
+{
+	int ret = 0;
+
+	if (!test_bit(CC33XX_FLAG_GPIO_POWER, &wl->flags))
+		return;
+
+	if (wl->if_ops->power)
+		ret = wl->if_ops->power(wl->dev, false);
+	if (!ret)
+		clear_bit(CC33XX_FLAG_GPIO_POWER, &wl->flags);
+}
+
+int cc33xx_power_on(struct cc33xx *wl)
+{
+	int ret = 0;
+
+	if (wl->if_ops->power)
+		ret = wl->if_ops->power(wl->dev, true);
+	if (ret == 0)
+		set_bit(CC33XX_FLAG_GPIO_POWER, &wl->flags);
+
+	return ret;
+}
diff --git a/drivers/net/wireless/ti/cc33xx/io.h b/drivers/net/wireless/ti/cc33xx/io.h
index 1d5f48d6deda..0ff75e562c66 100644
--- a/drivers/net/wireless/ti/cc33xx/io.h
+++ b/drivers/net/wireless/ti/cc33xx/io.h
@@ -11,134 +11,23 @@
 #ifndef __IO_H__
 #define __IO_H__
 
-#include <linux/irqreturn.h>
 
 struct cc33xx;
 
 void wlcore_disable_interrupts_nosync(struct cc33xx *wl);
 void wlcore_enable_interrupts(struct cc33xx *wl);
-
 void cc33xx_io_reset(struct cc33xx *wl);
 void cc33xx_io_init(struct cc33xx *wl);
+int __must_check wlcore_raw_read(struct cc33xx *wl, int addr,
+				 void *buf, size_t len, bool fixed);
+int __must_check wlcore_write(struct cc33xx *wl, int addr,
+			      void *buf, size_t len, bool fixed);
+void claim_core_status_lock(struct cc33xx *wl);
+void release_core_status_lock(struct cc33xx *wl);
+void cc33xx_power_off(struct cc33xx *wl);
+int cc33xx_power_on(struct cc33xx *wl);
 int wlcore_translate_addr(struct cc33xx *wl, int addr);
-
-/* Raw target IO, address is not translated */
-static inline int __must_check wlcore_raw_write(struct cc33xx *wl, int addr,
-						void *buf, size_t len,
-						bool fixed)
-{
-	int ret;
-
-	if (test_bit(CC33XX_FLAG_IO_FAILED, &wl->flags) ||
-	    WARN_ON((test_bit(CC33XX_FLAG_IN_ELP, &wl->flags) &&
-		     addr != HW_ACCESS_ELP_CTRL_REG)))
-		return -EIO;
-
-	ret = wl->if_ops->write(wl->dev, addr, buf, len, fixed);
-	if (ret && wl->state != WLCORE_STATE_OFF)
-		set_bit(CC33XX_FLAG_IO_FAILED, &wl->flags);
-
-	return ret;
-}
-
-static inline int __must_check wlcore_raw_read(struct cc33xx *wl, int addr,
-					       void *buf, size_t len,
-					       bool fixed)
-{
-	int ret;
-
-	if (test_bit(CC33XX_FLAG_IO_FAILED, &wl->flags) ||
-	    WARN_ON((test_bit(CC33XX_FLAG_IN_ELP, &wl->flags) &&
-		     addr != HW_ACCESS_ELP_CTRL_REG)))
-		return -EIO;
-
-	ret = wl->if_ops->read(wl->dev, addr, buf, len, fixed);
-	if (ret && wl->state != WLCORE_STATE_OFF)
-		set_bit(CC33XX_FLAG_IO_FAILED, &wl->flags);
-
-	return ret;
-}
-
-
-static inline int __must_check wlcore_raw_read32(struct cc33xx *wl, int addr,
-						 u32 *val)
-{
-	int ret;
-
-	ret = wlcore_raw_read(wl, addr, wl->buffer_32,
-			      sizeof(*wl->buffer_32), false);
-	if (ret < 0)
-		return ret;
-
-	if (val)
-		*val = le32_to_cpu(*wl->buffer_32);
-
-	return 0;
-}
-
-static inline int __must_check wlcore_raw_write32(struct cc33xx *wl, int addr,
-						  u32 val)
-{
-	*wl->buffer_32 = cpu_to_le32(val);
-	return wlcore_raw_write(wl, addr, wl->buffer_32,
-				sizeof(*wl->buffer_32), false);
-}
-
-static inline int __must_check wlcore_read(struct cc33xx *wl, int addr,
-					   void *buf, size_t len, bool fixed)
-{
-	return wlcore_raw_read(wl, addr, buf, len, fixed);
-}
-
-static inline int __must_check wlcore_write(struct cc33xx *wl, int addr,
-					    void *buf, size_t len, bool fixed)
-{
-	return wlcore_raw_write(wl, addr, buf, len, fixed);
-}
-
-static inline void claim_core_status_lock(struct cc33xx *wl)
-{
-	// When accessing core-status data (read or write) the transport lock
-	// should be held.
-	wl->if_ops->interface_claim(wl->dev);
-}
-
-static inline void release_core_status_lock(struct cc33xx *wl)
-{
-	// After accessing core-status data (read or write) the transport lock
-	// should be released.
-	wl->if_ops->interface_release(wl->dev);
-}
-
-static inline void cc33xx_power_off(struct cc33xx *wl)
-{
-	int ret = 0;
-
-	if (!test_bit(CC33XX_FLAG_GPIO_POWER, &wl->flags))
-		return;
-
-	if (wl->if_ops->power)
-		ret = wl->if_ops->power(wl->dev, false);
-	if (!ret)
-		clear_bit(CC33XX_FLAG_GPIO_POWER, &wl->flags);
-}
-
-static inline int cc33xx_power_on(struct cc33xx *wl)
-{
-	int ret = 0;
-
-	if (wl->if_ops->power)
-		ret = wl->if_ops->power(wl->dev, true);
-	if (ret == 0)
-		set_bit(CC33XX_FLAG_GPIO_POWER, &wl->flags);
-
-	return ret;
-}
-
 bool cc33xx_set_block_size(struct cc33xx *wl);
 
-/* Functions from main.c */
-
-int cc33xx_tx_dummy_packet(struct cc33xx *wl);
 
-#endif
+#endif /* __IO_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/main.c b/drivers/net/wireless/ti/cc33xx/main.c
index d2805a9fbf05..b8aef14f79f5 100644
--- a/drivers/net/wireless/ti/cc33xx/main.c
+++ b/drivers/net/wireless/ti/cc33xx/main.c
@@ -6,21 +6,16 @@
  * Copyright (C) 2011-2013 Texas Instruments Inc.
  */
 
-#include <linux/module.h>
 #include <linux/mod_devicetable.h>
 #include <linux/platform_device.h>
 #include <linux/firmware.h>
-#include <linux/etherdevice.h>
-#include <linux/ip.h>
-#include <linux/vmalloc.h>
-#include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/pm_wakeirq.h>
-#include <linux/gpio.h>
+
+#include "../net/mac80211/ieee80211_i.h"
 
 #include "acx.h"
-#include "wlcore.h"
-#include "debug.h"
+#include "boot.h"
 #include "cc33xx_80211.h"
 #include "io.h"
 #include "tx.h"
@@ -30,23 +25,16 @@
 #include "testmode.h"
 #include "scan.h"
 #include "sysfs.h"
-#include "../net/mac80211/ieee80211_i.h"
+#include "event.h"
 
 
 #define CC33XX_WAKEUP_TIMEOUT 500
 #define CC33XX_FW_RX_PACKET_RAM (9 * 1024)
 static char *fwlog_param;
-static int fwlog_mem_blocks = -1;
 static int no_recovery     = -1;
 
 static char *ht_mode_param = NULL;
 
-static int num_rx_desc_param = -1;
-
-/* phy paramters */
-
-static int pwr_limit_reference_11_abg_param = -1;
-
 /* HT cap appropriate for wide channels in 2Ghz */
 static struct ieee80211_sta_ht_cap cc33xx_siso40_ht_cap_2ghz = {
 	.cap = IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_SGI_40 |
@@ -59,7 +47,7 @@ static struct ieee80211_sta_ht_cap cc33xx_siso40_ht_cap_2ghz = {
 		.rx_mask = { 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, },
 		.rx_highest = cpu_to_le16(150),
 		.tx_params = IEEE80211_HT_MCS_TX_DEFINED,
-		},
+	},
 };
 
 /* HT cap appropriate for wide channels in 5Ghz */
@@ -74,7 +62,7 @@ static struct ieee80211_sta_ht_cap cc33xx_siso40_ht_cap_5ghz = {
 		.rx_mask = { 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, },
 		.rx_highest = cpu_to_le16(150),
 		.tx_params = IEEE80211_HT_MCS_TX_DEFINED,
-		},
+	},
 };
 
 /* HT cap appropriate for SISO 20 */
@@ -88,42 +76,56 @@ static struct ieee80211_sta_ht_cap cc33xx_siso20_ht_cap = {
 		.rx_mask = { 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, },
 		.rx_highest = cpu_to_le16(72),
 		.tx_params = IEEE80211_HT_MCS_TX_DEFINED,
-		},
+	},
 };
 
-/* HT cap appropriate for MIMO rates in 20mhz channel */
-static struct ieee80211_sta_ht_cap cc33xx_mimo_ht_cap_2ghz = {
-	.cap = IEEE80211_HT_CAP_SGI_20 |
-	       IEEE80211_HT_CAP_GRN_FLD,
-	.ht_supported = true,
-	.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K,
-	.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16,
-	.mcs = {
-		.rx_mask = { 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, },
-		.rx_highest = cpu_to_le16(144),
-		.tx_params = IEEE80211_HT_MCS_TX_DEFINED,
-		},
+#ifdef CONFIG_MAC80211_MESH
+static const struct ieee80211_iface_limit cc33xx_iface_limits[] = {
+	{
+		.max = 2,
+		.types = BIT(NL80211_IFTYPE_STATION)
+		       | BIT(NL80211_IFTYPE_P2P_CLIENT),
+	},
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_P2P_GO)
+		       | BIT(NL80211_IFTYPE_MESH_POINT)
+	},
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_P2P_DEVICE),
+	},
 };
 
+static inline u16 cc33xx_wiphy_interface_modes(void)
+{
+	return BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_P2P_GO) |
+	       BIT(NL80211_IFTYPE_MESH_POINT) | BIT(NL80211_IFTYPE_AP) |
+	       BIT(NL80211_IFTYPE_P2P_CLIENT) | BIT(NL80211_IFTYPE_P2P_DEVICE);
+}
+#else
 static const struct ieee80211_iface_limit cc33xx_iface_limits[] = {
 	{
 		.max = 2,
-		.types =  BIT(NL80211_IFTYPE_STATION)
-			| BIT(NL80211_IFTYPE_P2P_CLIENT),
+		.types = BIT(NL80211_IFTYPE_STATION)
+		       | BIT(NL80211_IFTYPE_P2P_CLIENT),
 	},
 	{
 		.max = 1,
-		.types =   BIT(NL80211_IFTYPE_AP)
-			 | BIT(NL80211_IFTYPE_P2P_GO)
-#ifdef CONFIG_MAC80211_MESH
-			 | BIT(NL80211_IFTYPE_MESH_POINT)
-#endif
+		.types = BIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_P2P_GO)
 	},
 	{
 		.max = 1,
 		.types = BIT(NL80211_IFTYPE_P2P_DEVICE),
 	},
 };
+static inline u16 cc33xx_wiphy_interface_modes(void)
+{
+	return BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_P2P_GO) |
+	       BIT(NL80211_IFTYPE_P2P_CLIENT) | BIT(NL80211_IFTYPE_AP) |
+	       BIT(NL80211_IFTYPE_P2P_DEVICE);
+}
+#endif /* CONFIG_MAC80211_MESH */
 
 static const struct ieee80211_iface_combination
 cc33xx_iface_combinations[] = {
@@ -270,95 +272,90 @@ static struct ieee80211_channel cc33xx_channels[] = {
 	{ .hw_value = 11, .center_freq = 2462, .max_power = CC33XX_MAX_TXPWR },
 	{ .hw_value = 12, .center_freq = 2467, .max_power = CC33XX_MAX_TXPWR },
 	{ .hw_value = 13, .center_freq = 2472, .max_power = CC33XX_MAX_TXPWR },
-	{ .hw_value = 14, .center_freq = 2484, .max_power = CC33XX_MAX_TXPWR },
 };
 
-
-static struct ieee80211_sband_iftype_data iftype_data_2ghz[] = {
-	{
-		.types_mask = BIT(NL80211_IFTYPE_STATION),
-		.he_cap = {
-			.has_he = true,
-			.he_cap_elem = {
-				.mac_cap_info[0] =
-					IEEE80211_HE_MAC_CAP0_HTC_HE,
-				.mac_cap_info[1] =
-					IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
-					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
-				.mac_cap_info[2] =
-					IEEE80211_HE_MAC_CAP2_32BIT_BA_BITMAP |
-					IEEE80211_HE_MAC_CAP2_ALL_ACK |
-					IEEE80211_HE_MAC_CAP2_TRS |
-					IEEE80211_HE_MAC_CAP2_BSR |
-					IEEE80211_HE_MAC_CAP2_ACK_EN,
-				.mac_cap_info[3] =
-					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
-					IEEE80211_HE_MAC_CAP3_RX_CTRL_FRAME_TO_MULTIBSS,
-				.mac_cap_info[4] =
-					IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU |
-					IEEE80211_HE_MAC_CAP4_NDP_FB_REP |
-					IEEE80211_HE_MAC_CAP4_MULTI_TID_AGG_TX_QOS_B39,
-				.mac_cap_info[5] =
-					IEEE80211_HE_MAC_CAP5_HT_VHT_TRIG_FRAME_RX,
-				.phy_cap_info[0] = 0,
-				.phy_cap_info[1] =
-					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
-					IEEE80211_HE_PHY_CAP1_HE_LTF_AND_GI_FOR_HE_PPDUS_0_8US,
-				.phy_cap_info[2] =
-					IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US,
-				.phy_cap_info[3] =
-					IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_NO_DCM |
-					IEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_1 |
-					IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM |
-					IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1,
-				.phy_cap_info[4] =
-					IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE |
-					IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_4 ,
-				.phy_cap_info[5] =
-					IEEE80211_HE_PHY_CAP5_NG16_SU_FEEDBACK |
-					IEEE80211_HE_PHY_CAP5_NG16_MU_FEEDBACK,
-				.phy_cap_info[6] =
-					IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_42_SU  |
-					IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU  |
-					IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB  |
-					IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB |
-					IEEE80211_HE_PHY_CAP6_TRIG_CQI_FB |
-					IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE,
-				.phy_cap_info[7] =
-					IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI ,
-				.phy_cap_info[8] =
-					IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI |
-					IEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |
-					IEEE80211_HE_PHY_CAP8_HE_ER_SU_1XLTF_AND_08_US_GI,
-				.phy_cap_info[9] =
-					IEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK |
-					IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
-					IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB |
-					IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_16US,
-			},
-			/*
-			 * Set default Tx/Rx HE MCS NSS Support field.
-			 * Indicate support for up to 2 spatial streams and all
-			 * MCS, without any special cases
-			 */
-			.he_mcs_nss_supp = {
-				.rx_mcs_80 = cpu_to_le16(0xfffc),
-				.tx_mcs_80 = cpu_to_le16(0xfffc),
-				.rx_mcs_160 = cpu_to_le16(0xffff),
-				.tx_mcs_160 = cpu_to_le16(0xffff),
-				.rx_mcs_80p80 = cpu_to_le16(0xffff),
-				.tx_mcs_80p80 = cpu_to_le16(0xffff),
-			},
-			/*
-			 * Set default PPE thresholds, with PPET16 set to 0,
-			 * PPET8 set to 7
-			 */
-			.ppe_thres = {0xff, 0xff, 0xff, 0xff},
+static struct ieee80211_sband_iftype_data iftype_data_2ghz[] = {{
+	.types_mask = BIT(NL80211_IFTYPE_STATION),
+	.he_cap = {
+		.has_he = true,
+		.he_cap_elem = {
+		.mac_cap_info[0] =
+			IEEE80211_HE_MAC_CAP0_HTC_HE |
+			IEEE80211_HE_MAC_CAP0_TWT_REQ,
+		.mac_cap_info[1] =
+			IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+			IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+		.mac_cap_info[2] =
+			IEEE80211_HE_MAC_CAP2_32BIT_BA_BITMAP |
+			IEEE80211_HE_MAC_CAP2_ALL_ACK |
+			IEEE80211_HE_MAC_CAP2_TRS |
+			IEEE80211_HE_MAC_CAP2_BSR |
+			IEEE80211_HE_MAC_CAP2_ACK_EN,
+		.mac_cap_info[3] =
+			IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+			IEEE80211_HE_MAC_CAP3_RX_CTRL_FRAME_TO_MULTIBSS,
+		.mac_cap_info[4] =
+			IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU |
+			IEEE80211_HE_MAC_CAP4_NDP_FB_REP |
+			IEEE80211_HE_MAC_CAP4_MULTI_TID_AGG_TX_QOS_B39,
+		.mac_cap_info[5] =
+			IEEE80211_HE_MAC_CAP5_HT_VHT_TRIG_FRAME_RX,
+		.phy_cap_info[0] = 0,
+		.phy_cap_info[1] =
+			IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+			IEEE80211_HE_PHY_CAP1_HE_LTF_AND_GI_FOR_HE_PPDUS_0_8US,
+		.phy_cap_info[2] =
+			IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US,
+		.phy_cap_info[3] =
+			IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_NO_DCM |
+			IEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_1 |
+			IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM |
+			IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1,
+		.phy_cap_info[4] =
+			IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE |
+			IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_4 ,
+		.phy_cap_info[5] =
+			IEEE80211_HE_PHY_CAP5_NG16_SU_FEEDBACK |
+			IEEE80211_HE_PHY_CAP5_NG16_MU_FEEDBACK,
+		.phy_cap_info[6] =
+			IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_42_SU  |
+			IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU  |
+			IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB  |
+			IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB |
+			IEEE80211_HE_PHY_CAP6_TRIG_CQI_FB |
+			IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE,
+		.phy_cap_info[7] =
+			IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI ,
+		.phy_cap_info[8] =
+			IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI |
+			IEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |
+			IEEE80211_HE_PHY_CAP8_HE_ER_SU_1XLTF_AND_08_US_GI,
+		.phy_cap_info[9] =
+			IEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK |
+			IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
+			IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB |
+			IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_16US,
 		},
+		/*
+		* Set default Tx/Rx HE MCS NSS Support field.
+		* Indicate support for up to 2 spatial streams and all
+		* MCS, without any special cases
+		*/
+		.he_mcs_nss_supp = {
+			.rx_mcs_80 = cpu_to_le16(0xfffc),
+			.tx_mcs_80 = cpu_to_le16(0xfffc),
+			.rx_mcs_160 = cpu_to_le16(0xffff),
+			.tx_mcs_160 = cpu_to_le16(0xffff),
+			.rx_mcs_80p80 = cpu_to_le16(0xffff),
+			.tx_mcs_80p80 = cpu_to_le16(0xffff),
+		},
+		/*
+		* Set default PPE thresholds, with PPET16 set to 0,
+		* PPET8 set to 7
+		*/
+		.ppe_thres = {0xff, 0xff, 0xff, 0xff},
 	},
-};
-
-
+}};
 
 /* can't be const, mac80211 writes to this */
 static struct ieee80211_supported_band cc33xx_band_2ghz = {
@@ -370,6 +367,22 @@ static struct ieee80211_supported_band cc33xx_band_2ghz = {
 	.n_iftype_data = ARRAY_SIZE(iftype_data_2ghz),
 };
 
+static const u8 he_if_types_ext_capa_sta[] = {
+	 [0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,
+	 [2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,
+	 [7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,
+	 [9] = WLAN_EXT_CAPA10_TWT_REQUESTER_SUPPORT,
+};
+
+static const struct wiphy_iftype_ext_capab he_iftypes_ext_capa[] = {
+	{
+		.iftype = NL80211_IFTYPE_STATION,
+		.extended_capabilities = he_if_types_ext_capa_sta,
+		.extended_capabilities_mask = he_if_types_ext_capa_sta,
+		.extended_capabilities_len = sizeof(he_if_types_ext_capa_sta),
+	},
+};
+
 /* 5 GHz data rates for cc33xx */
 static struct ieee80211_rate cc33xx_rates_5ghz[] = {
 	{ .bitrate = 60,
@@ -400,16 +413,9 @@ static struct ieee80211_rate cc33xx_rates_5ghz[] = {
 
 /* 5 GHz band channels for cc33xx */
 static struct ieee80211_channel cc33xx_channels_5ghz[] = {
-	{ .hw_value = 8, .center_freq = 5040, .max_power = CC33XX_MAX_TXPWR },
-	{ .hw_value = 12, .center_freq = 5060, .max_power = CC33XX_MAX_TXPWR },
-	{ .hw_value = 16, .center_freq = 5080, .max_power = CC33XX_MAX_TXPWR },
-	{ .hw_value = 34, .center_freq = 5170, .max_power = CC33XX_MAX_TXPWR },
 	{ .hw_value = 36, .center_freq = 5180, .max_power = CC33XX_MAX_TXPWR },
-	{ .hw_value = 38, .center_freq = 5190, .max_power = CC33XX_MAX_TXPWR },
 	{ .hw_value = 40, .center_freq = 5200, .max_power = CC33XX_MAX_TXPWR },
-	{ .hw_value = 42, .center_freq = 5210, .max_power = CC33XX_MAX_TXPWR },
 	{ .hw_value = 44, .center_freq = 5220, .max_power = CC33XX_MAX_TXPWR },
-	{ .hw_value = 46, .center_freq = 5230, .max_power = CC33XX_MAX_TXPWR },
 	{ .hw_value = 48, .center_freq = 5240, .max_power = CC33XX_MAX_TXPWR },
 	{ .hw_value = 52, .center_freq = 5260, .max_power = CC33XX_MAX_TXPWR },
 	{ .hw_value = 56, .center_freq = 5280, .max_power = CC33XX_MAX_TXPWR },
@@ -432,89 +438,89 @@ static struct ieee80211_channel cc33xx_channels_5ghz[] = {
 	{ .hw_value = 161, .center_freq = 5805, .max_power = CC33XX_MAX_TXPWR },
 	{ .hw_value = 165, .center_freq = 5825, .max_power = CC33XX_MAX_TXPWR },
 };
-static struct ieee80211_sband_iftype_data iftype_data_5ghz[] = {
-	{
-		.types_mask = BIT(NL80211_IFTYPE_STATION),
-		.he_cap = {
-			.has_he = true,
-			.he_cap_elem = {
-				.mac_cap_info[0] =
-					IEEE80211_HE_MAC_CAP0_HTC_HE,
-				.mac_cap_info[1] =
-					IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
-					IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
-				.mac_cap_info[2] =
-					IEEE80211_HE_MAC_CAP2_32BIT_BA_BITMAP |
-					IEEE80211_HE_MAC_CAP2_ALL_ACK |
-					IEEE80211_HE_MAC_CAP2_TRS |
-					IEEE80211_HE_MAC_CAP2_BSR |
-					IEEE80211_HE_MAC_CAP2_ACK_EN,
-				.mac_cap_info[3] =
-					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
-					IEEE80211_HE_MAC_CAP3_RX_CTRL_FRAME_TO_MULTIBSS,
-				.mac_cap_info[4] =
-					IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU |
-					IEEE80211_HE_MAC_CAP4_NDP_FB_REP |
-					IEEE80211_HE_MAC_CAP4_MULTI_TID_AGG_TX_QOS_B39,
-				.mac_cap_info[5] =
-					IEEE80211_HE_MAC_CAP5_HT_VHT_TRIG_FRAME_RX,
-				.phy_cap_info[0] = 0,
-				.phy_cap_info[1] =
-					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
-					IEEE80211_HE_PHY_CAP1_HE_LTF_AND_GI_FOR_HE_PPDUS_0_8US,
-				.phy_cap_info[2] =
-					IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US,
-				.phy_cap_info[3] =
-					IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_NO_DCM |
-					IEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_1 |
-					IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM |
-					IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1,
-				.phy_cap_info[4] =
-					IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE |
-					IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_4 ,
-				.phy_cap_info[5] =
-					IEEE80211_HE_PHY_CAP5_NG16_SU_FEEDBACK |
-					IEEE80211_HE_PHY_CAP5_NG16_MU_FEEDBACK,
-				.phy_cap_info[6] =
-					IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_42_SU  |
-					IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU  |
-					IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB  |
-					IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB |
-					IEEE80211_HE_PHY_CAP6_TRIG_CQI_FB |
-					IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE,
-				.phy_cap_info[7] =
-					IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI ,
-				.phy_cap_info[8] =
-					IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI |
-					IEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |
-					IEEE80211_HE_PHY_CAP8_HE_ER_SU_1XLTF_AND_08_US_GI,
-				.phy_cap_info[9] =
-					IEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK |
-					IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
-					IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB |
-					IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_16US,
-			},
-			/*
-			 * Set default Tx/Rx HE MCS NSS Support field.
-			 * Indicate support for up to 2 spatial streams and all
-			 * MCS, without any special cases
-			 */
-			.he_mcs_nss_supp = {
-				.rx_mcs_80 = cpu_to_le16(0xfffc),
-				.tx_mcs_80 = cpu_to_le16(0xfffc),
-				.rx_mcs_160 = cpu_to_le16(0xffff),
-				.tx_mcs_160 = cpu_to_le16(0xffff),
-				.rx_mcs_80p80 = cpu_to_le16(0xffff),
-				.tx_mcs_80p80 = cpu_to_le16(0xffff),
-			},
-			/*
-			 * Set default PPE thresholds, with PPET16 set to 0,
-			 * PPET8 set to 7
-			 */
-			.ppe_thres = {0xff, 0xff, 0xff, 0xff},
+
+static struct ieee80211_sband_iftype_data iftype_data_5ghz[] = {{
+	.types_mask = BIT(NL80211_IFTYPE_STATION),
+	.he_cap = {
+		.has_he = true,
+		.he_cap_elem = {
+		.mac_cap_info[0] =
+			IEEE80211_HE_MAC_CAP0_HTC_HE |
+			IEEE80211_HE_MAC_CAP0_TWT_REQ,
+		.mac_cap_info[1] =
+			IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |
+			IEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,
+		.mac_cap_info[2] =
+			IEEE80211_HE_MAC_CAP2_32BIT_BA_BITMAP |
+			IEEE80211_HE_MAC_CAP2_ALL_ACK |
+			IEEE80211_HE_MAC_CAP2_TRS |
+			IEEE80211_HE_MAC_CAP2_BSR |
+			IEEE80211_HE_MAC_CAP2_ACK_EN,
+		.mac_cap_info[3] =
+			IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
+			IEEE80211_HE_MAC_CAP3_RX_CTRL_FRAME_TO_MULTIBSS,
+		.mac_cap_info[4] =
+			IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU |
+			IEEE80211_HE_MAC_CAP4_NDP_FB_REP |
+			IEEE80211_HE_MAC_CAP4_MULTI_TID_AGG_TX_QOS_B39,
+		.mac_cap_info[5] =
+			IEEE80211_HE_MAC_CAP5_HT_VHT_TRIG_FRAME_RX,
+		.phy_cap_info[0] = 0,
+		.phy_cap_info[1] =
+			IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
+			IEEE80211_HE_PHY_CAP1_HE_LTF_AND_GI_FOR_HE_PPDUS_0_8US,
+		.phy_cap_info[2] =
+			IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US,
+		.phy_cap_info[3] =
+			IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_NO_DCM |
+			IEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_1 |
+			IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM |
+			IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1,
+		.phy_cap_info[4] =
+			IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE |
+			IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_4 ,
+		.phy_cap_info[5] =
+			IEEE80211_HE_PHY_CAP5_NG16_SU_FEEDBACK |
+			IEEE80211_HE_PHY_CAP5_NG16_MU_FEEDBACK,
+		.phy_cap_info[6] =
+			IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_42_SU  |
+			IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU  |
+			IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB  |
+			IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB |
+			IEEE80211_HE_PHY_CAP6_TRIG_CQI_FB |
+			IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE,
+		.phy_cap_info[7] =
+			IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI ,
+		.phy_cap_info[8] =
+			IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI |
+			IEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |
+			IEEE80211_HE_PHY_CAP8_HE_ER_SU_1XLTF_AND_08_US_GI,
+		.phy_cap_info[9] =
+			IEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK |
+			IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
+			IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB |
+			IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_16US,
 		},
+		/*
+			* Set default Tx/Rx HE MCS NSS Support field.
+			* Indicate support for up to 2 spatial streams and all
+			* MCS, without any special cases
+			*/
+		.he_mcs_nss_supp = {
+			.rx_mcs_80 = cpu_to_le16(0xfffc),
+			.tx_mcs_80 = cpu_to_le16(0xfffc),
+			.rx_mcs_160 = cpu_to_le16(0xffff),
+			.tx_mcs_160 = cpu_to_le16(0xffff),
+			.rx_mcs_80p80 = cpu_to_le16(0xffff),
+			.tx_mcs_80p80 = cpu_to_le16(0xffff),
+		},
+		/*
+			* Set default PPE thresholds, with PPET16 set to 0,
+			* PPET8 set to 7
+			*/
+		.ppe_thres = {0xff, 0xff, 0xff, 0xff},
 	},
-};
+}};
 
 static struct ieee80211_supported_band cc33xx_band_5ghz = {
 	.channels = cc33xx_channels_5ghz,
@@ -523,8 +529,8 @@ static struct ieee80211_supported_band cc33xx_band_5ghz = {
 	.n_bitrates = ARRAY_SIZE(cc33xx_rates_5ghz),
 	.vht_cap = {
 		.vht_supported = true,
-		.cap = (IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 |
-			(1 << IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT)),
+		.cap = (IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 | (1 <<
+			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT)),
 		.vht_mcs = {
 			.rx_mcs_map = cpu_to_le16(0xfffc),
 			.rx_highest = 7,
@@ -537,14 +543,13 @@ static struct ieee80211_supported_band cc33xx_band_5ghz = {
 
 };
 
-
-
 static void __cc33xx_op_remove_interface(struct cc33xx *wl,
 					 struct ieee80211_vif *vif,
 					 bool reset_tx_queues);
 static void cc33xx_turn_off(struct cc33xx *wl);
 static void cc33xx_free_ap_keys(struct cc33xx *wl, struct cc33xx_vif *wlvif);
-static int process_core_status(struct cc33xx *wl, struct core_status *core_status);
+static int process_core_status(struct cc33xx *wl,
+			       struct core_status *core_status);
 static int cc33xx_setup(struct cc33xx *wl);
 
 static int cc33xx_set_authorized(struct cc33xx *wl, struct cc33xx_vif *wlvif)
@@ -581,8 +586,8 @@ static void cc33xx_reg_notify(struct wiphy *wiphy,
 	wlcore_regdomain_config(wl);
 }
 
-static int cc33xx_set_rx_streaming(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-				   bool enable)
+static int cc33xx_set_rx_streaming(struct cc33xx *wl,
+				   struct cc33xx_vif *wlvif, bool enable)
 {
 	int ret = 0;
 
@@ -613,12 +618,11 @@ int cc33xx_recalc_rx_streaming(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 		goto out;
 
 	/* reconfigure/disable according to new streaming_period */
-	if (period &&
-	    test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags) &&
+	if (period && test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags) &&
 	    (wl->conf.host_conf.rx_streaming.always ||
-	     test_bit(CC33XX_FLAG_SOFT_GEMINI, &wl->flags)))
+	    test_bit(CC33XX_FLAG_SOFT_GEMINI, &wl->flags))) {
 		ret = cc33xx_set_rx_streaming(wl, wlvif, true);
-	else {
+	} else {
 		ret = cc33xx_set_rx_streaming(wl, wlvif, false);
 		/* don't cancel_work_sync since we might deadlock */
 		del_timer_sync(&wlvif->rx_streaming_timer);
@@ -639,7 +643,7 @@ static void cc33xx_rx_streaming_enable_work(struct work_struct *work)
 	if (test_bit(WLVIF_FLAG_RX_STREAMING_STARTED, &wlvif->flags) ||
 	    !test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags) ||
 	    (!wl->conf.host_conf.rx_streaming.always &&
-	     !test_bit(CC33XX_FLAG_SOFT_GEMINI, &wl->flags)))
+	    !test_bit(CC33XX_FLAG_SOFT_GEMINI, &wl->flags)))
 		goto out;
 
 	if (!wl->conf.host_conf.rx_streaming.interval)
@@ -650,8 +654,8 @@ static void cc33xx_rx_streaming_enable_work(struct work_struct *work)
 		goto out;
 
 	/* stop it after some time of inactivity */
-	mod_timer(&wlvif->rx_streaming_timer,
-		  jiffies + msecs_to_jiffies(wl->conf.host_conf.rx_streaming.duration));
+	mod_timer(&wlvif->rx_streaming_timer, jiffies +
+		msecs_to_jiffies( wl->conf.host_conf.rx_streaming.duration));
 
 out:
 	mutex_unlock(&wl->mutex);
@@ -677,9 +681,9 @@ static void cc33xx_rx_streaming_disable_work(struct work_struct *work)
 	mutex_unlock(&wl->mutex);
 }
 
-static void cc33xx_rx_streaming_timer(struct timer_list *t)
+static void cc33xx_rx_streaming_timer(struct timer_list *timers)
 {
-	struct cc33xx_vif *wlvif = from_timer(wlvif, t, rx_streaming_timer);
+	struct cc33xx_vif *wlvif = from_timer(wlvif,timers, rx_streaming_timer);
 	struct cc33xx *wl = wlvif->wl;
 	ieee80211_queue_work(wl->hw, &wlvif->rx_streaming_disable_work);
 }
@@ -696,8 +700,7 @@ void cc33xx_rearm_tx_watchdog_locked(struct cc33xx *wl)
 		msecs_to_jiffies(wl->conf.host_conf.tx.tx_watchdog_timeout));
 }
 
-static void cc33xx_sta_rc_update(struct cc33xx *wl,
-				 struct cc33xx_vif *wlvif)
+static void cc33xx_sta_rc_update(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 {
 	bool wide = wlvif->rc_update_bw >= IEEE80211_STA_RX_BW_40;
 
@@ -748,85 +751,24 @@ static void wlcore_rc_update_work(struct work_struct *work)
 	mutex_unlock(&wl->mutex);
 }
 
-static void cc33xx_tx_watchdog_work(struct work_struct *work)
+static inline void cc33xx_tx_watchdog_work(struct work_struct *work)
 {
-	struct delayed_work *dwork;
-	struct cc33xx *wl;
-
-	dwork = to_delayed_work(work);
-	wl = container_of(dwork, struct cc33xx, tx_watchdog_work);
-
-
-	mutex_lock(&wl->mutex);
-
-	// michal temp - ignore watchdog
-	    goto out;
-
-	if (unlikely(wl->state != WLCORE_STATE_ON))
-		goto out;
-
-	/* Tx went out in the meantime - everything is ok */
-	if (unlikely(wl->tx_allocated_blocks == 0))
-		goto out;
-
-	/*
-	 * if a ROC is in progress, we might not have any Tx for a long
-	 * time (e.g. pending Tx on the non-ROC channels)
-	 */
-	if (find_first_bit(wl->roc_map, CC33XX_MAX_ROLES) < CC33XX_MAX_ROLES) {
-		cc33xx_debug(DEBUG_TX, "No Tx (in FW) for %d ms due to ROC",
-			     wl->conf.host_conf.tx.tx_watchdog_timeout);
-		cc33xx_rearm_tx_watchdog_locked(wl);
-		goto out;
-	}
-
-	/*
-	 * if a scan is in progress, we might not have any Tx for a long
-	 * time
-	 */
-	if (wl->scan.state != CC33XX_SCAN_STATE_IDLE) {
-		cc33xx_debug(DEBUG_TX, "No Tx (in FW) for %d ms due to scan",
-			     wl->conf.host_conf.tx.tx_watchdog_timeout);
-		cc33xx_rearm_tx_watchdog_locked(wl);
-		goto out;
-	}
-
-	/*
-	* AP might cache a frame for a long time for a sleeping station,
-	* so rearm the timer if there's an AP interface with stations. If
-	* Tx is genuinely stuck we will most hopefully discover it when all
-	* stations are removed due to inactivity.
-	*/
-	if (wl->active_sta_count) {
-		cc33xx_debug(DEBUG_TX, "No Tx (in FW) for %d ms. AP has "
-			     " %d stations",
-			      wl->conf.host_conf.tx.tx_watchdog_timeout,
-			      wl->active_sta_count);
-		cc33xx_rearm_tx_watchdog_locked(wl);
-		goto out;
-	}
-
-	cc33xx_error("Tx stuck (in FW) for %d ms. Starting recovery",
-		     wl->conf.host_conf.tx.tx_watchdog_timeout);
-	cc33xx_queue_recovery_work(wl);
-
-out:
-	mutex_unlock(&wl->mutex);
+	container_of(to_delayed_work(work), struct cc33xx, tx_watchdog_work);
 }
 
 static void wlcore_adjust_conf(struct cc33xx *wl)
 {
-
+	struct conf_fwlog *fw_log = &wl->conf.host_conf.fwlog;
 	if (fwlog_param) {
 		if (!strcmp(fwlog_param, "continuous")) {
-			wl->conf.host_conf.fwlog.mode = CC33XX_FWLOG_CONTINUOUS;
-			wl->conf.host_conf.fwlog.output = CC33XX_FWLOG_OUTPUT_HOST;
+			fw_log->mode = CC33XX_FWLOG_CONTINUOUS;
+			fw_log->output = CC33XX_FWLOG_OUTPUT_HOST;
 		} else if (!strcmp(fwlog_param, "dbgpins")) {
-			wl->conf.host_conf.fwlog.mode = CC33XX_FWLOG_CONTINUOUS;
-			wl->conf.host_conf.fwlog.output = CC33XX_FWLOG_OUTPUT_DBG_PINS;
+			fw_log->mode = CC33XX_FWLOG_CONTINUOUS;
+			fw_log->output = CC33XX_FWLOG_OUTPUT_DBG_PINS;
 		} else if (!strcmp(fwlog_param, "disable")) {
-			wl->conf.host_conf.fwlog.mem_blocks = 0;
-			wl->conf.host_conf.fwlog.output = CC33XX_FWLOG_OUTPUT_NONE;
+			fw_log->mem_blocks = 0;
+			fw_log->output = CC33XX_FWLOG_OUTPUT_NONE;
 		} else {
 			cc33xx_error("Unknown fwlog parameter %s", fwlog_param);
 		}
@@ -841,9 +783,9 @@ void cc33xx_flush_deferred_work(struct cc33xx *wl)
 	struct sk_buff *skb;
 
 	/* Pass all received frames to the network stack */
-	while ((skb = skb_dequeue(&wl->deferred_rx_queue)))
-	{
-	    cc33xx_debug(DEBUG_RX, "cc33xx_flush_deferred_work rx skb 0x%p", skb);
+	while ((skb = skb_dequeue(&wl->deferred_rx_queue))) {
+		cc33xx_debug(DEBUG_RX,
+			     "cc33xx_flush_deferred_work rx skb 0x%p", skb);
 		ieee80211_rx_ni(wl->hw, skb);
 	}
 
@@ -854,16 +796,13 @@ void cc33xx_flush_deferred_work(struct cc33xx *wl)
 
 static void cc33xx_netstack_work(struct work_struct *work)
 {
-	struct cc33xx *wl =
-		container_of(work, struct cc33xx, netstack_work);
+	struct cc33xx *wl = container_of(work, struct cc33xx, netstack_work);
 
 	do {
 		cc33xx_flush_deferred_work(wl);
 	} while (skb_queue_len(&wl->deferred_rx_queue));
 }
 
-
-
 static int wlcore_irq_locked(struct cc33xx *wl)
 {
 	int ret = 0;
@@ -891,65 +830,64 @@ static int wlcore_irq_locked(struct cc33xx *wl)
 		const int read_headers_len = sizeof(struct core_status)
 			+ sizeof(struct NAB_rx_header);
 
-		// Read aggressively as more data might be coming in
+		/* Read aggressively as more data might be coming in */
 		rx_byte_count *= 2;
 
 		read_data_len = rx_byte_count + read_headers_len;
 
-		if (wl->max_transaction_len) // Used in SPI interface
-		{
+		if (wl->max_transaction_len) { /* Used in SPI interface */
 			const int spi_alignment = sizeof (u32) - 1;
-			read_data_len = __ALIGN_MASK(read_data_len, spi_alignment);
-			read_data_len = min(read_data_len, wl->max_transaction_len);
-		}
-		else // SDIO
-		{
+			read_data_len = __ALIGN_MASK(read_data_len,
+						     spi_alignment);
+			read_data_len = min(read_data_len,
+					    wl->max_transaction_len);
+		} else { /* SDIO */
 			const int sdio_alignment = CC33XX_BUS_BLOCK_SIZE-1;
-			read_data_len = __ALIGN_MASK(read_data_len, sdio_alignment);
-			read_data_len = min(read_data_len, maximum_rx_packet_size);
+			read_data_len = __ALIGN_MASK(read_data_len,
+						     sdio_alignment);
+			read_data_len = min(read_data_len,
+					    maximum_rx_packet_size);
 		}
 
-		ret = wlcore_raw_read(wl, NAB_DATA_ADDR,
-					wl->aggr_buf, read_data_len, true);
-		if (ret < 0)
-		{
-			cc33xx_debug(DEBUG_IRQ, "rx read Error response 0x%x", ret);
+		ret = wlcore_raw_read(wl, NAB_DATA_ADDR, wl->aggr_buf,
+				      read_data_len, true);
+		if (ret < 0) {
+			cc33xx_debug(DEBUG_IRQ,
+				     "rx read Error response 0x%x", ret);
 			release_core_status_lock(wl);
 			return ret;
 		}
 
-		core_status_ptr = (struct core_status *)
-			((u8 *)wl->aggr_buf + read_data_len - sizeof(struct core_status));
+		core_status_ptr = (struct core_status *)((u8 *)wl->aggr_buf +
+				    read_data_len - sizeof(struct core_status));
 
 		memcpy(wl->core_status,
 			core_status_ptr, sizeof(struct core_status));
 
-		cc33xx_debug(DEBUG_IRQ, "IRQ locked work: call process_core_status");
+		cc33xx_debug(DEBUG_IRQ,
+			     "IRQ locked work: call process_core_status");
 		process_core_status(wl, wl->core_status);
 
-		cc33xx_debug(DEBUG_IRQ, "IRQ locked work: Releasing core-status lock");
+		cc33xx_debug(DEBUG_IRQ,
+			     "IRQ locked work: Releasing core-status lock");
 		release_core_status_lock(wl);
 
 		cc33xx_debug(DEBUG_IRQ, "read rx data 0x%x", ret);
 		NAB_rx_header = (struct NAB_rx_header *)wl->aggr_buf;
 		rx_buf_len = NAB_rx_header->len - 8; // michal fix
-		if (rx_buf_len != 0)
-		{
-			rx_buf_ptr = (u8 *)wl->aggr_buf + sizeof(struct NAB_rx_header);
+		if (rx_buf_len != 0) {
+			rx_buf_ptr = (u8 *)wl->aggr_buf +
+						sizeof(struct NAB_rx_header);
 			cc33xx_debug(DEBUG_IRQ,"calling rx code!");
 			wlcore_rx(wl, rx_buf_ptr, rx_buf_len);
 			cc33xx_debug(DEBUG_IRQ,"finished rx code!");
-		}
-		else
-		{
+		} else {
 			cc33xx_error("Rx buffer length is 0");
 			cc33xx_queue_recovery_work(wl);
 		}
-	}
-	else
-	{
-		cc33xx_debug(DEBUG_IRQ,
-			"IRQ locked work: No rx data, releasing core-status lock");
+	} else {
+		cc33xx_debug(DEBUG_IRQ, "IRQ locked work: No rx data, "
+			     "releasing core-status lock");
 		release_core_status_lock(wl);
 	}
 
@@ -963,11 +901,11 @@ static int read_core_status(struct cc33xx *wl, struct core_status *core_status)
 	cc33xx_debug(DEBUG_CORE_STATUS, "Reading core status");
 
 	return wlcore_raw_read(wl, NAB_STATUS_ADDR, core_status,
-				sizeof *core_status, false);
+			       sizeof *core_status, false);
 }
 
 static int parse_control_message(struct cc33xx *wl,
-				const u8 *buffer, size_t buffer_length)
+				 const u8 *buffer, size_t buffer_length)
 {
 	u8 *const end_of_payload = (u8 *const) buffer + buffer_length;
 	u8 *const start_of_payload = (u8 *const) buffer;
@@ -977,7 +915,7 @@ static int parse_control_message(struct cc33xx *wl,
 
 	while(buffer < end_of_payload){
 		control_info_descriptor =
-			(struct control_info_descriptor *) buffer;
+				(struct control_info_descriptor *) buffer;
 
 		ctrl_info_type = le16_to_cpu(control_info_descriptor->type);
 		ctrl_info_length = le16_to_cpu(control_info_descriptor->length);
@@ -994,14 +932,15 @@ static int parse_control_message(struct cc33xx *wl,
 			break;
 
 		case CTRL_MSG_COMMND_COMPLETE:
-			cmd_result_data =
-				buffer + sizeof *control_info_descriptor;
+			cmd_result_data = buffer;
+			cmd_result_data += sizeof *control_info_descriptor;
 
 			if (ctrl_info_length > sizeof wl->command_result){
 
 				print_hex_dump(KERN_DEBUG, "message dump:",
-					DUMP_PREFIX_OFFSET, 16, 1,
-					cmd_result_data, ctrl_info_length, false);
+					       DUMP_PREFIX_OFFSET, 16, 1,
+					       cmd_result_data,
+					       ctrl_info_length, false);
 
 				WARN(1, "Error device response exceeds result "
 					"buffer size");
@@ -1009,7 +948,8 @@ static int parse_control_message(struct cc33xx *wl,
 				goto message_parse_error;
 			}
 
-			memcpy(wl->command_result, cmd_result_data, ctrl_info_length);
+			memcpy(wl->command_result,
+			       cmd_result_data, ctrl_info_length);
 
 			wl->result_length = ctrl_info_length;
 
@@ -1047,10 +987,11 @@ static int read_control_message(struct cc33xx *wl, u8 *read_buffer,
 	cc33xx_debug(DEBUG_CMD, "Reading control info");
 
 	ret = wlcore_raw_read(wl, NAB_CONTROL_ADDR, read_buffer,
-				buffer_size, false);
+			      buffer_size, false);
 
 	if (ret < 0){
-		cc33xx_debug(DEBUG_CMD, "control read Error response 0x%x", ret);
+		cc33xx_debug(DEBUG_CMD,
+			     "control read Error response 0x%x", ret);
 		return ret;
 	}
 
@@ -1058,13 +999,12 @@ static int read_control_message(struct cc33xx *wl, u8 *read_buffer,
 
 	if (nab_header->sync_pattern != DEVICE_SYNC_PATTERN){
 		cc33xx_error("Wrong device sync pattern: 0x%x",
-			nab_header->sync_pattern);
+			     nab_header->sync_pattern);
 		return -EIO;
 	}
 
-	device_message_size = 	sizeof *nab_header +
-				NAB_EXTRA_BYTES +
-				nab_header->len;
+	device_message_size = sizeof *nab_header + NAB_EXTRA_BYTES
+							+ nab_header->len;
 
 	if (device_message_size > buffer_size){
 		cc33xx_error("Invalid NAB length field: %x", nab_header->len);
@@ -1120,10 +1060,9 @@ static int verify_padding(struct core_status *core_status)
 	for (i=0; i<ARRAY_SIZE(core_status->block_pad); i++){
 		if (core_status->block_pad[i] != valid_padding){
 			cc33xx_error("Error in core status padding:");
-			print_hex_dump(KERN_DEBUG, "",
-				DUMP_PREFIX_OFFSET, 16, 1,
-				core_status,
-				sizeof *core_status, false);
+			print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16,
+				       1, core_status, sizeof *core_status,
+				       false);
 			return -1;
 		}
 	}
@@ -1132,7 +1071,7 @@ static int verify_padding(struct core_status *core_status)
 }
 
 static int process_core_status(struct cc33xx *wl,
-				struct core_status *core_status)
+			       struct core_status *core_status)
 {
 	bool 	core_status_idle;
 	u32	shadow_host_interrupt_status;
@@ -1142,17 +1081,16 @@ static int process_core_status(struct cc33xx *wl,
 		core_status_idle = true;
 
 		shadow_host_interrupt_status =
-			core_status->host_interrupt_status;
+					core_status->host_interrupt_status;
 
 		/* Interrupts are aggregated (ORed) in this filed with each
 		   read operation from the device. */
-		core_status->host_interrupt_status=0;
+		core_status->host_interrupt_status = 0;
 
 		cc33xx_debug(DEBUG_IRQ,
-			"HINT_STATUS: 0x%x, TSF: 0x%x, rx status: 0x%x",
-			shadow_host_interrupt_status,
-			core_status->tsf,
-			core_status->rx_status);
+			     "HINT_STATUS: 0x%x, TSF: 0x%x, rx status: 0x%x",
+			     shadow_host_interrupt_status, core_status->tsf,
+			     core_status->rx_status);
 
 		if (shadow_host_interrupt_status & HINT_COMMAND_COMPLETE){
 			ret = process_event_and_cmd_result(wl, core_status);
@@ -1164,21 +1102,21 @@ static int process_core_status(struct cc33xx *wl,
 		}
 
 		if ((core_status->rx_status & RX_BYTE_COUNT_MASK) != 0){
-			cc33xx_debug(DEBUG_RX,
-				"Rx data pending, triggering deferred work");
+			cc33xx_debug(DEBUG_RX, "Rx data pending, "
+				     "triggering deferred work");
 			queue_work(wl->freezable_wq, &wl->irq_deferred_work);
 		}
 
 		if (core_status->fwInfo.txResultQueueIndex
 						!= wl->last_fw_rls_idx){
-			cc33xx_debug(DEBUG_TX,
-			"Tx new result, triggering deferred work");
+			cc33xx_debug(DEBUG_TX, "Tx new result, "
+				     "triggering deferred work");
 			queue_work(wl->freezable_wq, &wl->irq_deferred_work);
 		}
 
 		if (shadow_host_interrupt_status &  HINT_NEW_TX_RESULT){
-			cc33xx_debug(DEBUG_TX,
-			"Tx complete, triggering deferred work");
+			cc33xx_debug(DEBUG_TX, "Tx complete, "
+				     "triggering deferred work");
 			queue_work(wl->freezable_wq, &wl->irq_deferred_work);
 		}
 
@@ -1191,22 +1129,30 @@ static int process_core_status(struct cc33xx *wl,
 			cc33xx_error("FW is stuck, triggering recovery");
 			cc33xx_queue_recovery_work(wl);
 		}
-
-	}while (!core_status_idle);
+	} while (!core_status_idle);
 
 	return 0;
 }
 
-
 void wlcore_irq(void *cookie)
 {
 	struct cc33xx *wl = cookie;
+	unsigned long flags;
 	int ret;
 
 	cc33xx_debug(DEBUG_IRQ, "wlcore_irq invoked");
 	claim_core_status_lock(wl);
 	cc33xx_debug(DEBUG_IRQ, "wlcore_irq: Core-status locked");
 
+	if (test_bit(CC33XX_FLAG_SUSPENDED, &wl->flags)) {
+		/* don't enqueue a work right now. mark it as pending */
+		set_bit(CC33XX_FLAG_PENDING_WORK, &wl->flags);
+		spin_lock_irqsave(&wl->wl_lock, flags);
+		wlcore_disable_interrupts_nosync(wl);
+		pm_wakeup_hard_event(wl->dev);
+		spin_unlock_irqrestore(&wl->wl_lock, flags);
+		goto out;
+	}
 
 	ret = read_core_status(wl, wl->core_status);
 	if (unlikely(ret < 0)){
@@ -1247,8 +1193,8 @@ static void cc33xx_vif_count_iter(void *data, u8 *mac,
 
 /* caller must not hold wl->mutex, as it might deadlock */
 static void cc33xx_get_vif_count(struct ieee80211_hw *hw,
-			       struct ieee80211_vif *cur_vif,
-			       struct vif_counter_data *data)
+				 struct ieee80211_vif *cur_vif,
+				 struct vif_counter_data *data)
 {
 	memset(data, 0, sizeof(*data));
 	data->cur_vif = cur_vif;
@@ -1261,27 +1207,12 @@ void cc33xx_queue_recovery_work(struct cc33xx *wl)
 {
 	/* Avoid a recursive recovery */
 	if (wl->state == WLCORE_STATE_ON) {
-
 		wl->state = WLCORE_STATE_RESTARTING;
 		set_bit(CC33XX_FLAG_RECOVERY_IN_PROGRESS, &wl->flags);
 		ieee80211_queue_work(wl->hw, &wl->recovery_work);
 	}
 }
 
-size_t cc33xx_copy_fwlog(struct cc33xx *wl, u8 *memblock, size_t maxlen)
-{
-	size_t len;
-
-	/* Make sure we have enough room */
-	len = min_t(size_t, maxlen, PAGE_SIZE - wl->fwlog_size);
-
-	/* Fill the FW log file, consumed by the sysfs fwlog entry */
-	memcpy(wl->fwlog + wl->fwlog_size, memblock, len);
-	wl->fwlog_size += len;
-
-	return len;
-}
-
 static void wlcore_save_freed_pkts(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				   u8 hlid, struct ieee80211_sta *sta)
 {
@@ -1315,21 +1246,31 @@ static void wlcore_save_freed_pkts_addr(struct cc33xx *wl,
 
 	rcu_read_lock();
 	sta = ieee80211_find_sta(vif, addr);
+
 	if (sta)
 		wlcore_save_freed_pkts(wl, wlvif, hlid, sta);
+
 	rcu_read_unlock();
 }
 
+static void cc33xx_finalize_recovery(struct cc33xx *wl)
+{
+	wl->state = WLCORE_STATE_ON;
+	cc33xx_notice("Recovery complete");
+}
+
 static void cc33xx_recovery_work(struct work_struct *work)
 {
 	struct cc33xx *wl = container_of(work, struct cc33xx, recovery_work);
 	struct cc33xx_vif *wlvif;
 	struct ieee80211_vif *vif;
+	u8 active_interfaces = wl->ap_count + wl->sta_count;
 
 	cc33xx_notice("Recovery work");
 
 	if (wl->conf.core.no_recovery) {
-		cc33xx_info("Recovery disabled by configuration, driver will not restart.");
+		cc33xx_info("Recovery disabled by configuration, "
+			    "driver will not restart.");
 		return;
 	}
 
@@ -1338,9 +1279,6 @@ static void cc33xx_recovery_work(struct work_struct *work)
 		return;
 	}
 
-	wl->state = WLCORE_STATE_RESTARTING;
-	set_bit(CC33XX_FLAG_RECOVERY_IN_PROGRESS, &wl->flags);
-
 	mutex_lock(&wl->mutex);
 	while (!list_empty(&wl->wlvif_list)) {
 		wlvif = list_first_entry(&wl->wlvif_list,
@@ -1350,6 +1288,24 @@ static void cc33xx_recovery_work(struct work_struct *work)
 		if (test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))
 			ieee80211_connection_loss(vif);
 
+		if (test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags)) {
+			struct ieee80211_sta *sta;
+			const u8 *addr;
+			int link_index;
+
+			for_each_set_bit(link_index, wlvif->ap.sta_hlid_map, CC33XX_MAX_LINKS) {
+				addr = wl->links[link_index].addr;
+
+				rcu_read_lock();
+				sta = ieee80211_find_sta(vif, addr);
+				if (sta) {
+					cc33xx_info("remove sta %d", link_index);
+					ieee80211_report_low_ack(sta, 0);
+				}
+				rcu_read_unlock();
+			}
+		}
+
 		__cc33xx_op_remove_interface(wl, vif, false);
 	}
 	mutex_unlock(&wl->mutex);
@@ -1366,6 +1322,9 @@ static void cc33xx_recovery_work(struct work_struct *work)
 	mutex_lock(&wl->mutex);
 	clear_bit(CC33XX_FLAG_RECOVERY_IN_PROGRESS, &wl->flags);
 	mutex_unlock(&wl->mutex);
+
+	if(!active_interfaces)
+		cc33xx_finalize_recovery(wl);
 }
 
 static void irq_deferred_work(struct work_struct *work)
@@ -1393,7 +1352,8 @@ static void irq_deferred_work(struct work_struct *work)
 		ieee80211_queue_work(wl->hw, &wl->tx_work);
 	spin_unlock_irqrestore(&wl->wl_lock, flags);
 
-	cc33xx_debug(DEBUG_IRQ,"Finish IRQ deffered work. going to release semaphore");
+	cc33xx_debug(DEBUG_IRQ,
+		     "Finish IRQ deffered work. going to release semaphore");
 
 	mutex_unlock(&wl->mutex);
 }
@@ -1407,7 +1367,7 @@ static void irq_wrapper(struct platform_device *pdev)
 	wlcore_irq(wl);
 }
 
- int cc33xx_plt_init(struct cc33xx *wl)
+int cc33xx_plt_init(struct cc33xx *wl)
 {
 	/* PLT init: Role enable + Role start + plt Init  */
 	int ret=0;
@@ -1418,18 +1378,16 @@ static void irq_wrapper(struct platform_device *pdev)
 
 	ret = cc33xx_cmd_role_enable(wl, bcast_addr,
 					ROLE_TRANSCEIVER, &returned_role_id);
-	if(ret < 0)
-	{
+	if(ret < 0) {
 		cc33xx_info("PLT init Role Enable FAILED! , PLT roleID is: %u ",
-				returned_role_id);
+			    returned_role_id);
 		goto out;
 	}
 
 	ret = cc33xx_cmd_role_start_transceiver(wl, returned_role_id);
-	if(ret < 0)
-	{
+	if(ret < 0) {
 		cc33xx_info("PLT init Role Start FAILED! , PLT roleID is: %u ",
-				returned_role_id);
+			    returned_role_id);
 		cc33xx_cmd_role_disable(wl, &returned_role_id);
 		goto out;
 	}
@@ -1437,15 +1395,12 @@ static void irq_wrapper(struct platform_device *pdev)
 	wl->plt_role_id = returned_role_id;
 	ret = cc33xx_cmd_plt_enable(wl, returned_role_id);
 
-	if(ret >= 0)
-	{
+	if(ret >= 0) {
 		cc33xx_info("PLT init Role Start succeed!, PLT roleID is: %u ",
-				returned_role_id);
-	}
-	else
-	{
+			    returned_role_id);
+	} else {
 		cc33xx_info("PLT init Role Start FAILED! , PLT roleID is: %u ",
-				returned_role_id);
+			    returned_role_id);
 	}
 
 out:
@@ -1458,8 +1413,7 @@ int cc33xx_plt_start(struct cc33xx *wl, const enum plt_mode plt_mode)
 
 	mutex_lock(&wl->mutex);
 
-	if(plt_mode == PLT_ON && wl->plt_mode == PLT_ON)
-	{
+	if(plt_mode == PLT_ON && wl->plt_mode == PLT_ON) {
 		cc33xx_error("PLT already on");
 		ret = 0;
 		goto out;
@@ -1469,7 +1423,7 @@ int cc33xx_plt_start(struct cc33xx *wl, const enum plt_mode plt_mode)
 
 	if (plt_mode != PLT_CHIP_AWAKE) {
 		ret = cc33xx_plt_init(wl);
-		if (ret < 0){
+		if (ret < 0) {
 			cc33xx_error("PLT start failed");
 			goto out;
 		}
@@ -1523,6 +1477,7 @@ static void cc33xx_op_tx(struct ieee80211_hw *hw,
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_vif *vif = info->control.vif;
 	struct cc33xx_vif *wlvif = NULL;
+	enum queue_stop_reason stop_reason = WLCORE_QUEUE_STOP_REASON_WATERMARK;
 	unsigned long flags;
 	int q, mapping;
 	u8 hlid;
@@ -1547,11 +1502,11 @@ static void cc33xx_op_tx(struct ieee80211_hw *hw,
 	 * allow these packets through.
 	 */
 
-	if (hlid == CC33XX_INVALID_LINK_ID ||
+	if ((hlid == CC33XX_INVALID_LINK_ID) ||
 	    (!test_bit(hlid, wlvif->links_map)) ||
-	     (wlcore_is_queue_stopped_locked(wl, wlvif, q) &&
-	      !wlcore_is_queue_stopped_by_reason_locked(wl, wlvif, q,
-			WLCORE_QUEUE_STOP_REASON_WATERMARK))) {
+	    (wlcore_is_queue_stopped_locked(wl, wlvif, q) &&
+	    !wlcore_is_queue_stopped_by_reason_locked(wl, wlvif, q,
+						      stop_reason))) {
 		cc33xx_debug(DEBUG_TX, "DROP skb hlid %d q %d ", hlid, q);
 		ieee80211_free_txskb(hw, skb);
 		goto out;
@@ -1570,10 +1525,9 @@ static void cc33xx_op_tx(struct ieee80211_hw *hw,
 	 */
 	if (wlvif->tx_queue_count[q] >= CC33XX_TX_QUEUE_HIGH_WATERMARK &&
 	    !wlcore_is_queue_stopped_by_reason_locked(wl, wlvif, q,
-					WLCORE_QUEUE_STOP_REASON_WATERMARK)) {
+						      stop_reason)) {
 		cc33xx_debug(DEBUG_TX, "op_tx: stopping queues for q %d", q);
-		wlcore_stop_queue_locked(wl, wlvif, q,
-					 WLCORE_QUEUE_STOP_REASON_WATERMARK);
+		wlcore_stop_queue_locked(wl, wlvif, q, stop_reason);
 	}
 
 	/*
@@ -1582,47 +1536,18 @@ static void cc33xx_op_tx(struct ieee80211_hw *hw,
 	 */
 	cc33xx_debug(DEBUG_TX, "TX Call queue work");
 	if (!test_bit(CC33XX_FLAG_FW_TX_BUSY, &wl->flags) &&
-	    !test_bit(CC33XX_FLAG_TX_PENDING, &wl->flags))
-	{
-	    cc33xx_debug(DEBUG_TX, "trigger tx thread!");
+	    !test_bit(CC33XX_FLAG_TX_PENDING, &wl->flags)) {
+		cc33xx_debug(DEBUG_TX, "trigger tx thread!");
 		ieee80211_queue_work(wl->hw, &wl->tx_work);
-	}
-	else
-	{
-	    cc33xx_debug(DEBUG_TX, "dont trigger tx thread! wl->flags 0x%lx",wl->flags);
+	} else {
+		cc33xx_debug(DEBUG_TX,"dont trigger tx thread! wl->flags 0x%lx",
+			     wl->flags);
 	}
 
 out:
 	spin_unlock_irqrestore(&wl->wl_lock, flags);
 }
 
-int cc33xx_tx_dummy_packet(struct cc33xx *wl)
-{
-	unsigned long flags;
-	int q;
-
-	/* no need to queue a new dummy packet if one is already pending */
-	if (test_bit(CC33XX_FLAG_DUMMY_PACKET_PENDING, &wl->flags))
-		return 0;
-
-	q = cc33xx_tx_get_queue(skb_get_queue_mapping(wl->dummy_packet));
-
-	spin_lock_irqsave(&wl->wl_lock, flags);
-	set_bit(CC33XX_FLAG_DUMMY_PACKET_PENDING, &wl->flags);
-	wl->tx_queue_count[q]++;
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
-
-	/* The FW is low on RX memory blocks, so send the dummy packet asap */
-	if (!test_bit(CC33XX_FLAG_FW_TX_BUSY, &wl->flags))
-		return wlcore_tx_work_locked(wl);
-
-	/*
-	 * If the FW TX is busy, TX work will be scheduled by the threaded
-	 * interrupt handler function
-	 */
-	return 0;
-}
-
 /*
  * The size of the dummy packet should be at least 1400 bytes. However, in
  * order to minimize the number of bus transactions, aligning it to 512 bytes
@@ -1664,9 +1589,7 @@ static struct sk_buff *cc33xx_alloc_dummy_packet(struct cc33xx *wl)
 	return skb;
 }
 
-
-static int
-cc33xx_validate_wowlan_pattern(struct cfg80211_pkt_pattern *p)
+static int cc33xx_validate_wowlan_pattern(struct cfg80211_pkt_pattern *p)
 {
 	int num_fields = 0, in_field = 0, fields_size = 0;
 	int i, pattern_len = 0;
@@ -1690,22 +1613,18 @@ cc33xx_validate_wowlan_pattern(struct cfg80211_pkt_pattern *p)
 			if (!in_field) {
 				in_field = 1;
 				pattern_len = 1;
-			} else {
-				if (i == CC33XX_RX_FILTER_ETH_HEADER_SIZE) {
+			} else if (i == CC33XX_RX_FILTER_ETH_HEADER_SIZE) {
 					num_fields++;
 					fields_size += pattern_len +
 						RX_FILTER_FIELD_OVERHEAD;
 					pattern_len = 1;
-				} else
-					pattern_len++;
-			}
-		} else {
-			if (in_field) {
-				in_field = 0;
-				fields_size += pattern_len +
-					RX_FILTER_FIELD_OVERHEAD;
-				num_fields++;
+			} else {
+				pattern_len++;
 			}
+		} else if (in_field) {
+			in_field = 0;
+			fields_size += pattern_len + RX_FILTER_FIELD_OVERHEAD;
+			num_fields++;
 		}
 	}
 
@@ -1745,9 +1664,8 @@ void cc33xx_rx_filter_free(struct cc33xx_rx_filter *filter)
 	kfree(filter);
 }
 
-int cc33xx_rx_filter_alloc_field(struct cc33xx_rx_filter *filter,
-				 u16 offset, u8 flags,
-				 const u8 *pattern, u8 len)
+int cc33xx_rx_filter_alloc_field(struct cc33xx_rx_filter *filter, u16 offset,
+				 u8 flags, const u8 *pattern, u8 len)
 {
 	struct cc33xx_rx_filter_field *field;
 
@@ -1778,16 +1696,15 @@ int cc33xx_rx_filter_get_fields_size(struct cc33xx_rx_filter *filter)
 {
 	int i, fields_size = 0;
 
-	for (i = 0; i < filter->num_fields; i++)
-		fields_size += filter->fields[i].len +
-			sizeof(struct cc33xx_rx_filter_field) -
-			sizeof(u8 *);
+	for (i = 0; i < filter->num_fields; i++) {
+		fields_size += filter->fields[i].len - sizeof(u8*)
+					+ sizeof(struct cc33xx_rx_filter_field);
+	}
 
 	return fields_size;
 }
 
-void cc33xx_rx_filter_flatten_fields(struct cc33xx_rx_filter *filter,
-				    u8 *buf)
+void cc33xx_rx_filter_flatten_fields(struct cc33xx_rx_filter *filter, u8 *buf)
 {
 	int i;
 	struct cc33xx_rx_filter_field *field;
@@ -1800,8 +1717,8 @@ void cc33xx_rx_filter_flatten_fields(struct cc33xx_rx_filter *filter,
 		field->len = filter->fields[i].len;
 
 		memcpy(&field->pattern, filter->fields[i].pattern, field->len);
-		buf += sizeof(struct cc33xx_rx_filter_field) -
-			sizeof(u8 *) + field->len;
+		buf += sizeof(struct cc33xx_rx_filter_field) - sizeof(u8 *);
+		buf += field->len;
 	}
 }
 
@@ -1851,9 +1768,7 @@ cc33xx_convert_wowlan_pattern_to_rx_filter(struct cfg80211_pkt_pattern *p,
 
 		len = j - i;
 
-		ret = cc33xx_rx_filter_alloc_field(filter,
-						   offset,
-						   flags,
+		ret = cc33xx_rx_filter_alloc_field(filter, offset, flags,
 						   &p->pattern[i], len);
 		if (ret)
 			goto err;
@@ -1864,12 +1779,13 @@ cc33xx_convert_wowlan_pattern_to_rx_filter(struct cfg80211_pkt_pattern *p,
 	filter->action = FILTER_SIGNAL;
 
 	*f = filter;
-	return 0;
+	ret = 0;
+	goto out;
 
 err:
 	cc33xx_rx_filter_free(filter);
 	*f = NULL;
-
+out:
 	return ret;
 }
 
@@ -1878,7 +1794,11 @@ static int cc33xx_configure_wowlan(struct cc33xx *wl,
 {
 	int i, ret;
 
-	if (!wow || wow->any || !wow->n_patterns) {
+	if (!wow || (!wow->any && !wow->n_patterns)){
+		if (wow)
+			cc33xx_warning("invalid wow configuration -"
+			" set to pattern trigger without setting pattern");
+
 		ret = cc33xx_acx_default_rx_filter_enable(wl, 0,
 							  FILTER_SIGNAL);
 		if (ret)
@@ -1891,6 +1811,19 @@ static int cc33xx_configure_wowlan(struct cc33xx *wl,
 		return 0;
 	}
 
+	if (wow->any) {
+		ret = cc33xx_acx_default_rx_filter_enable(wl, 1,
+							  FILTER_SIGNAL);
+		if (ret)
+			goto out;
+
+		ret = cc33xx_rx_filter_clear_all(wl);
+		if (ret)
+			goto out;
+
+		return 0;
+	}
+
 	if (WARN_ON(wow->n_patterns > CC33XX_MAX_RX_FILTERS))
 		return -EINVAL;
 
@@ -1942,6 +1875,7 @@ static int cc33xx_configure_suspend_sta(struct cc33xx *wl,
 					struct cc33xx_vif *wlvif,
 					struct cfg80211_wowlan *wow)
 {
+	struct cc33xx_core_conf *core_conf = &wl->conf.core;
 	int ret = 0;
 
 	if (!test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))
@@ -1951,26 +1885,23 @@ static int cc33xx_configure_suspend_sta(struct cc33xx *wl,
 	if (ret < 0)
 		goto out;
 
-	if ((wl->conf.core.suspend_wake_up_event ==
-	     wl->conf.core.wake_up_event) &&
-	    (wl->conf.core.suspend_listen_interval ==
-	     wl->conf.core.listen_interval))
+	if ((core_conf->suspend_wake_up_event == core_conf->wake_up_event) &&
+	    (core_conf->suspend_listen_interval == core_conf->listen_interval))
 		goto out;
 
 	ret = cc33xx_acx_wake_up_conditions(wl, wlvif,
-				    wl->conf.core.suspend_wake_up_event,
-				    wl->conf.core.suspend_listen_interval);
+					    core_conf->suspend_wake_up_event,
+					    core_conf->suspend_listen_interval);
 
 	if (ret < 0)
 		cc33xx_error("suspend: set wake up conditions failed: %d", ret);
 out:
 	return ret;
-
 }
 
 static int cc33xx_configure_suspend_ap(struct cc33xx *wl,
-					struct cc33xx_vif *wlvif,
-					struct cfg80211_wowlan *wow)
+				       struct cc33xx_vif *wlvif,
+				       struct cfg80211_wowlan *wow)
 {
 	int ret = 0;
 
@@ -1987,17 +1918,17 @@ static int cc33xx_configure_suspend_ap(struct cc33xx *wl,
 
 out:
 	return ret;
-
 }
 
-static int cc33xx_configure_suspend(struct cc33xx *wl,
-				    struct cc33xx_vif *wlvif,
+static int cc33xx_configure_suspend(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				    struct cfg80211_wowlan *wow)
 {
 	if (wlvif->bss_type == BSS_TYPE_STA_BSS)
 		return cc33xx_configure_suspend_sta(wl, wlvif, wow);
+
 	if (wlvif->bss_type == BSS_TYPE_AP_BSS)
 		return cc33xx_configure_suspend_ap(wl, wlvif, wow);
+
 	return 0;
 }
 
@@ -2006,6 +1937,7 @@ static void cc33xx_configure_resume(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	int ret = 0;
 	bool is_ap = wlvif->bss_type == BSS_TYPE_AP_BSS;
 	bool is_sta = wlvif->bss_type == BSS_TYPE_STA_BSS;
+	struct cc33xx_core_conf *core_conf = &wl->conf.core;
 
 	if ((!is_ap) && (!is_sta))
 		return;
@@ -2017,15 +1949,15 @@ static void cc33xx_configure_resume(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	cc33xx_configure_wowlan(wl, NULL);
 
 	if (is_sta) {
-		if ((wl->conf.core.suspend_wake_up_event ==
-		     wl->conf.core.wake_up_event) &&
-		    (wl->conf.core.suspend_listen_interval ==
-		     wl->conf.core.listen_interval))
+		if ((core_conf->suspend_wake_up_event ==
+		    core_conf->wake_up_event) &&
+		    (core_conf->suspend_listen_interval ==
+		    core_conf->listen_interval))
 			return;
 
 		ret = cc33xx_acx_wake_up_conditions(wl, wlvif,
-				    wl->conf.core.wake_up_event,
-				    wl->conf.core.listen_interval);
+						    core_conf->wake_up_event,
+						    core_conf->listen_interval);
 
 		if (ret < 0)
 			cc33xx_error("resume: wake up conditions failed: %d",
@@ -2077,7 +2009,7 @@ static int __maybe_unused cc33xx_op_suspend(struct ieee80211_hw *hw,
 
 	/* if filtering is enabled, configure the FW to drop all RX BA frames */
 	ret = cc33xx_acx_rx_ba_filter(wl,
-				     !!wl->conf.host_conf.conn.suspend_rx_ba_activity);
+			      !!wl->conf.host_conf.conn.suspend_rx_ba_activity);
 	if (ret < 0)
 		goto out;
 
@@ -2129,8 +2061,7 @@ static int __maybe_unused cc33xx_op_resume(struct ieee80211_hw *hw)
 	 */
 	spin_lock_irqsave(&wl->wl_lock, flags);
 	clear_bit(CC33XX_FLAG_SUSPENDED, &wl->flags);
-	if (test_and_clear_bit(CC33XX_FLAG_PENDING_WORK, &wl->flags))
-		run_irq_work = true;
+	run_irq_work = test_and_clear_bit(CC33XX_FLAG_PENDING_WORK, &wl->flags);
 	spin_unlock_irqrestore(&wl->wl_lock, flags);
 
 	mutex_lock(&wl->mutex);
@@ -2140,8 +2071,7 @@ static int __maybe_unused cc33xx_op_resume(struct ieee80211_hw *hw)
 				    &wl->flags);
 
 	if (run_irq_work) {
-		cc33xx_debug(DEBUG_MAC80211,
-			     "run postponed irq_work directly");
+		cc33xx_debug(DEBUG_MAC80211, "run postponed irq_work directly");
 
 		/* don't talk to the HW if recovery is pending */
 		if (!pending_recovery) {
@@ -2213,7 +2143,7 @@ static void cc33xx_turn_off(struct cc33xx *wl)
 
 	if (wl->state == WLCORE_STATE_OFF) {
 		if (test_and_clear_bit(CC33XX_FLAG_RECOVERY_IN_PROGRESS,
-					&wl->flags))
+				       &wl->flags))
 			wlcore_enable_interrupts(wl);
 
 		return;
@@ -2227,7 +2157,8 @@ static void cc33xx_turn_off(struct cc33xx *wl)
 	 * this must be before the cancel_work calls below, so that the work
 	 * functions don't perform further work.
 	 */
-	wl->state = WLCORE_STATE_OFF;
+	if (wl->state == WLCORE_STATE_ON)
+		wl->state = WLCORE_STATE_OFF;
 
 	/*
 	 * Use the nosync variant to disable interrupts, so the mutex could be
@@ -2283,12 +2214,8 @@ static void cc33xx_turn_off(struct cc33xx *wl)
 	 */
 	wl->flags = 0;
 
-
-
-	for (i = 0; i < NUM_TX_QUEUES; i++) {
-
+	for (i = 0; i < NUM_TX_QUEUES; i++)
 		wl->tx_allocated_pkts[i] = 0;
-	}
 
 	cc33xx_debugfs_reset(wl);
 
@@ -2306,14 +2233,13 @@ static void cc33xx_turn_off(struct cc33xx *wl)
 	mutex_unlock(&wl->mutex);
 }
 
-static void cc33xx_op_stop(struct ieee80211_hw *hw)
+static inline void cc33xx_op_stop(struct ieee80211_hw *hw)
 {
-
 	cc33xx_debug(DEBUG_MAC80211, "mac80211 stop");
 	return;
 }
 
-static void wlcore_channel_switch_work(struct work_struct *work)
+static void cc33xx_channel_switch_work(struct work_struct *work)
 {
 	struct delayed_work *dwork;
 	struct cc33xx *wl;
@@ -2396,13 +2322,14 @@ static void wlcore_pending_auth_complete_work(struct work_struct *work)
 	 * Check for a little less than the timeout to protect from scheduler
 	 * irregularities.
 	 */
-	time_spare = jiffies +
-			msecs_to_jiffies(WLCORE_PEND_AUTH_ROC_TIMEOUT - 50);
+	time_spare = msecs_to_jiffies(WLCORE_PEND_AUTH_ROC_TIMEOUT - 50);
+	time_spare += jiffies;
 	if (!time_after(time_spare, wlvif->pending_auth_reply_time))
 		goto out;
 
 	/* cancel the ROC if active */
-	cc33xx_debug(DEBUG_CMD, "pending_auth t/o expired - cancel ROC if active");
+	cc33xx_debug(DEBUG_CMD,
+		     "pending_auth t/o expired - cancel ROC if active");
 
 	wlcore_update_inconn_sta(wl, wlvif, NULL, false);
 
@@ -2418,8 +2345,7 @@ static void cc33xx_roc_timeout_work(struct work_struct *work)
 	unsigned long time_spare;
 
 	dwork = to_delayed_work(work);
-	wlvif = container_of(dwork, struct cc33xx_vif,
-			     roc_timeout_work);
+	wlvif = container_of(dwork, struct cc33xx_vif, roc_timeout_work);
 	wl = wlvif->wl;
 
 	mutex_lock(&wl->mutex);
@@ -2428,18 +2354,19 @@ static void cc33xx_roc_timeout_work(struct work_struct *work)
 		goto out;
 
 	/*
-	 * Make sure that requested timeout really passed. Maybe
-	 * a association completed and croc arrived while we were stuck on the mutex.
+	 * Make sure that requested timeout really passed. Maybe an association
+	 * completed and croc arrived while we were stuck on the mutex.
 	 * Check for a little less than the timeout to protect from scheduler
 	 * irregularities.
 	 */
-	time_spare = jiffies +
-			msecs_to_jiffies(CC33xx_PEND_ROC_COMPLETE_TIMEOUT - 50);
+	time_spare = msecs_to_jiffies(CC33xx_PEND_ROC_COMPLETE_TIMEOUT - 50);
+	time_spare += jiffies;
 	if (!time_after(time_spare, wlvif->pending_auth_reply_time))
 		goto out;
 
 	/* cancel the ROC if active */
-	cc33xx_debug(DEBUG_CMD, "Waiting for CROC Timeout has expired -> cancel ROC if exist");
+	cc33xx_debug(DEBUG_CMD, "Waiting for CROC Timeout has expired -> "
+		     "cancel ROC if exist");
 
 	if (test_bit(wlvif->role_id, wl->roc_map))
 		cc33xx_croc(wl, wlvif->role_id);
@@ -2500,6 +2427,7 @@ static u8 cc33xx_get_role_type(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 static int cc33xx_init_vif_data(struct cc33xx *wl, struct ieee80211_vif *vif)
 {
 	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
+	struct conf_tx_settings *tx_settings = &wl->conf.host_conf.tx;
 	int i;
 
 	/* clear everything but the persistent data */
@@ -2508,7 +2436,7 @@ static int cc33xx_init_vif_data(struct cc33xx *wl, struct ieee80211_vif *vif)
 	switch (ieee80211_vif_type_p2p(vif)) {
 	case NL80211_IFTYPE_P2P_CLIENT:
 		wlvif->p2p = 1;
-		/* fall-through */
+		fallthrough;
 	case NL80211_IFTYPE_STATION:
 	case NL80211_IFTYPE_P2P_DEVICE:
 		wlvif->bss_type = BSS_TYPE_STA_BSS;
@@ -2518,7 +2446,7 @@ static int cc33xx_init_vif_data(struct cc33xx *wl, struct ieee80211_vif *vif)
 		break;
 	case NL80211_IFTYPE_P2P_GO:
 		wlvif->p2p = 1;
-		/* fall-through */
+		fallthrough;
 	case NL80211_IFTYPE_AP:
 	case NL80211_IFTYPE_MESH_POINT:
 		wlvif->bss_type = BSS_TYPE_AP_BSS;
@@ -2562,8 +2490,8 @@ static int cc33xx_init_vif_data(struct cc33xx *wl, struct ieee80211_vif *vif)
 		wlvif->rate_set = CONF_TX_ENABLED_RATES;
 	}
 
-	wlvif->bitrate_masks[NL80211_BAND_2GHZ] = wl->conf.host_conf.tx.basic_rate;
-	wlvif->bitrate_masks[NL80211_BAND_5GHZ] = wl->conf.host_conf.tx.basic_rate_5;
+	wlvif->bitrate_masks[NL80211_BAND_2GHZ] = tx_settings->basic_rate;
+	wlvif->bitrate_masks[NL80211_BAND_5GHZ] = tx_settings->basic_rate_5;
 	wlvif->beacon_int = CC33XX_DEFAULT_BEACON_INT;
 
 	/*
@@ -2579,7 +2507,7 @@ static int cc33xx_init_vif_data(struct cc33xx *wl, struct ieee80211_vif *vif)
 		  cc33xx_rx_streaming_disable_work);
 	INIT_WORK(&wlvif->rc_update_work, wlcore_rc_update_work);
 	INIT_DELAYED_WORK(&wlvif->channel_switch_work,
-			  wlcore_channel_switch_work);
+			  cc33xx_channel_switch_work);
 	INIT_DELAYED_WORK(&wlvif->connection_loss_work,
 			  wlcore_connection_loss_work);
 	INIT_DELAYED_WORK(&wlvif->pending_auth_complete_work,
@@ -2592,21 +2520,17 @@ static int cc33xx_init_vif_data(struct cc33xx *wl, struct ieee80211_vif *vif)
 	return 0;
 }
 
-static bool cc33xx_dev_role_started(struct cc33xx_vif *wlvif)
-{
-	return wlvif->dev_hlid != CC33XX_INVALID_LINK_ID;
-}
-
 struct wlcore_hw_queue_iter_data {
 	unsigned long hw_queue_map[BITS_TO_LONGS(WLCORE_NUM_MAC_ADDRESSES)];
+
 	/* current vif */
 	struct ieee80211_vif *vif;
+
 	/* is the current vif among those iterated */
 	bool cur_running;
 };
 
-static void wlcore_hw_queue_iter(void *data, u8 *mac,
-				 struct ieee80211_vif *vif)
+static void wlcore_hw_queue_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
 {
 	struct wlcore_hw_queue_iter_data *iter_data = data;
 
@@ -2669,11 +2593,12 @@ static int wlcore_allocate_hw_queue_base(struct cc33xx *wl,
 
 adjust_cab_queue:
 	/* the last places are reserved for cab queues per interface */
-	if (wlvif->bss_type == BSS_TYPE_AP_BSS)
+	if (wlvif->bss_type == BSS_TYPE_AP_BSS) {
 		vif->cab_queue = NUM_TX_QUEUES * WLCORE_NUM_MAC_ADDRESSES +
-				 wlvif->hw_queue_base / NUM_TX_QUEUES;
-	else
+					wlvif->hw_queue_base / NUM_TX_QUEUES;
+	} else {
 		vif->cab_queue = IEEE80211_INVAL_HW_QUEUE;
+	}
 
 	return 0;
 }
@@ -2714,7 +2639,6 @@ static int cc33xx_op_add_interface(struct ieee80211_hw *hw,
 		goto out;
 	}
 
-
 	ret = cc33xx_init_vif_data(wl, vif);
 	if (ret < 0)
 		goto out;
@@ -2739,7 +2663,6 @@ static int cc33xx_op_add_interface(struct ieee80211_hw *hw,
 		ret = cc33xx_init_vif_specific(wl, vif);
 		if (ret < 0)
 			goto out;
-
 	} else {
 		ret = cc33xx_cmd_role_enable(wl, vif->addr, CC33XX_ROLE_DEVICE,
 					     &wlvif->dev_role_id);
@@ -2747,7 +2670,7 @@ static int cc33xx_op_add_interface(struct ieee80211_hw *hw,
 			goto out;
 
 		/* needed mainly for configuring rate policies */
-		ret = cc33xx_sta_hw_init(wl, wlvif);
+		ret = cc33xx_acx_config_ps(wl, wlvif);
 		if (ret < 0)
 			goto out;
 	}
@@ -2760,6 +2683,11 @@ static int cc33xx_op_add_interface(struct ieee80211_hw *hw,
 	else
 		wl->sta_count++;
 
+	if ((wl->state == WLCORE_STATE_RESTARTING) &&
+	    (wl->ap_count + wl->sta_count) == vif_count.counter){
+		cc33xx_finalize_recovery(wl);
+	}
+
 out:
 	mutex_unlock(&wl->mutex);
 
@@ -2820,7 +2748,7 @@ static void __cc33xx_op_remove_interface(struct cc33xx *wl,
 
 		if (wlvif->bss_type == BSS_TYPE_STA_BSS ||
 		    wlvif->bss_type == BSS_TYPE_IBSS) {
-			if (cc33xx_dev_role_started(wlvif))
+			if (wlvif->dev_hlid != CC33XX_INVALID_LINK_ID)
 				cc33xx_stop_dev(wl, wlvif);
 		}
 
@@ -2878,11 +2806,9 @@ static void __cc33xx_op_remove_interface(struct cc33xx *wl,
 	if (test_bit(CC33XX_FLAG_RECOVERY_IN_PROGRESS, &wl->flags))
 		goto unlock;
 
-	if (wl->ap_count == 0 && is_ap) {
-		/* mask ap events */
+	/* mask ap events */
+	if (wl->ap_count == 0 && is_ap)
 		wl->event_mask &= ~wl->ap_event_mask;
-		cc33xx_event_unmask(wl);
-	}
 
 	if (wl->ap_count == 0 && is_ap && wl->sta_count) {
 		u8 sta_auth = wl->conf.host_conf.conn.sta_sleep_auth;
@@ -2979,9 +2905,9 @@ static int wlcore_join(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	/* clear encryption type */
 	wlvif->encryption_type = KEY_NONE;
 
-	if (is_ibss)
+	if (is_ibss) {
 		ret = cc33xx_cmd_role_start_ibss(wl, wlvif);
-	else {
+	} else {
 		if (wl->quirks & WLCORE_QUIRK_START_STA_FAILS) {
 			/*
 			 * TODO: this is an ugly workaround for wl12xx fw
@@ -3000,8 +2926,8 @@ static int wlcore_join(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	return ret;
 }
 
-static int cc33xx_ssid_set(struct cc33xx_vif *wlvif, struct sk_buff *skb,
-			    int offset)
+static int cc33xx_ssid_set(struct cc33xx_vif *wlvif,
+			   struct sk_buff *skb, int offset)
 {
 	u8 ssid_len;
 	const u8 *ptr = cfg80211_find_ie(WLAN_EID_SSID, skb->data + offset,
@@ -3037,8 +2963,7 @@ static int wlcore_set_ssid(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	if (!skb)
 		return -EINVAL;
 
-	ieoffset = offsetof(struct ieee80211_mgmt,
-			    u.probe_req.variable);
+	ieoffset = offsetof(struct ieee80211_mgmt, u.probe_req.variable);
 	cc33xx_ssid_set(wlvif, skb, ieoffset);
 	dev_kfree_skb(skb);
 
@@ -3046,7 +2971,8 @@ static int wlcore_set_ssid(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 }
 
 static int wlcore_set_assoc(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			    struct ieee80211_bss_conf *bss_conf,struct ieee80211_sta *sta,
+			    struct ieee80211_bss_conf *bss_conf,
+			    struct ieee80211_sta *sta,
 			    struct ieee80211_vif *vif, u32 sta_rate_set)
 {
 	int ret;
@@ -3057,30 +2983,26 @@ static int wlcore_set_assoc(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	wlvif->wmm_enabled = bss_conf->qos;
 
 	wlvif->nontransmitted = bss_conf->nontransmitted;
-	cc33xx_debug(DEBUG_MAC80211,
-	     "set_assoc mbssid params: nonTxbssid: %d, idx: %d, max_ind: %d, trans_bssid: %pM, ema_ap: %d",
-	     bss_conf->nontransmitted,
-	     bss_conf->bssid_index,
-	     bss_conf->bssid_indicator,
-	     bss_conf->transmitter_bssid,
-	     bss_conf->ema_ap);
+	cc33xx_debug(DEBUG_MAC80211, "set_assoc mbssid params: nonTxbssid: %d, "
+		     "idx: %d, max_ind: %d, trans_bssid: %pM, ema_ap: %d",
+		     bss_conf->nontransmitted, bss_conf->bssid_index,
+		     bss_conf->bssid_indicator, bss_conf->transmitter_bssid,
+		     bss_conf->ema_ap);
 	wlvif->bssid_index = bss_conf->bssid_index;
 	wlvif->bssid_indicator = bss_conf->bssid_indicator;
-	memcpy(wlvif->transmitter_bssid,
-		bss_conf->transmitter_bssid,
-		ETH_ALEN);
+	memcpy(wlvif->transmitter_bssid, bss_conf->transmitter_bssid, ETH_ALEN);
 
 	set_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags);
 
 	ret = cc33xx_assoc_info_cfg(wl, wlvif, sta,wlvif->aid);
 	if (ret < 0)
 		return ret;
+
 	if (sta_rate_set) {
-		wlvif->rate_set =
-			cc33xx_tx_enabled_rates_get(wl,
-						    sta_rate_set,
-						    wlvif->band);
+		wlvif->rate_set = cc33xx_tx_enabled_rates_get(wl, sta_rate_set,
+							      wlvif->band);
 	}
+
 	return ret;
 }
 
@@ -3090,13 +3012,12 @@ static int wlcore_unset_assoc(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	bool sta = wlvif->bss_type == BSS_TYPE_STA_BSS;
 
 	/* make sure we are connected (sta) joined */
-	if (sta &&
-	    !test_and_clear_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))
+	if (sta && !test_and_clear_bit(WLVIF_FLAG_STA_ASSOCIATED,
+				       &wlvif->flags))
 		return false;
 
 	/* make sure we are joined (ibss) */
-	if (!sta &&
-	    test_and_clear_bit(WLVIF_FLAG_IBSS_JOINED, &wlvif->flags))
+	if (!sta && test_and_clear_bit(WLVIF_FLAG_IBSS_JOINED, &wlvif->flags))
 		return false;
 
 	if (sta) {
@@ -3135,8 +3056,8 @@ static void cc33xx_set_band_rate(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	wlvif->rate_set = wlvif->basic_rate_set;
 }
 
-static void cc33xx_sta_handle_idle(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-				   bool idle)
+static void cc33xx_sta_handle_idle(struct cc33xx *wl,
+				   struct cc33xx_vif *wlvif, bool idle)
 {
 	bool cur_idle = !test_bit(WLVIF_FLAG_ACTIVE, &wlvif->flags);
 
@@ -3159,7 +3080,6 @@ static int cc33xx_config_vif(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 {
 	int ret;
 
-
 	if (wlcore_is_p2p_mgmt(wlvif))
 		return 0;
 
@@ -3180,12 +3100,12 @@ static int cc33xx_op_config(struct ieee80211_hw *hw, u32 changed)
 	struct ieee80211_conf *conf = &hw->conf;
 	int ret = 0;
 
-	cc33xx_debug(DEBUG_MAC80211, "mac80211 config psm %s power %d %s"
-		     " changed 0x%x",
+	cc33xx_debug(DEBUG_MAC80211,
+		     "mac80211 config psm %s power %d %s changed 0x%x",
 		     conf->flags & IEEE80211_CONF_PS ? "on" : "off",
 		     conf->power_level,
 		     conf->flags & IEEE80211_CONF_IDLE ? "idle" : "in use",
-			 changed);
+		     changed);
 
 	mutex_lock(&wl->mutex);
 
@@ -3227,12 +3147,13 @@ static u64 cc33xx_op_prepare_multicast(struct ieee80211_hw *hw,
 	fp->mc_list_length = 0;
 	if (netdev_hw_addr_list_count(mc_list) > ACX_MC_ADDRESS_GROUP_MAX) {
 		fp->enabled = false;
-		cc33xx_debug(DEBUG_MAC80211, "mac80211 prepare multicast: too many addresses received, disable multicast filtering");
+		cc33xx_debug(DEBUG_MAC80211, "mac80211 prepare multicast: "
+			     "too many addresses received, disable multicast filtering");
 	} else {
 		fp->enabled = true;
 		netdev_hw_addr_list_for_each(ha, mc_list) {
 			memcpy(fp->mc_list[fp->mc_list_length],
-					ha->addr, ETH_ALEN);
+			       ha->addr, ETH_ALEN);
 			fp->mc_list_length++;
 		}
 	}
@@ -3254,7 +3175,9 @@ static void cc33xx_op_configure_filter(struct ieee80211_hw *hw,
 	struct cc33xx *wl = hw->priv;
 	struct cc33xx_vif *wlvif;
 
-	cc33xx_debug(DEBUG_MAC80211, "mac80211 configure filter, FIF_ALLMULTI = %d", *total & FIF_ALLMULTI);
+	cc33xx_debug(DEBUG_MAC80211,
+		     "mac80211 configure filter, FIF_ALLMULTI = %d",
+		     *total & FIF_ALLMULTI);
 
 	mutex_lock(&wl->mutex);
 
@@ -3268,18 +3191,18 @@ static void cc33xx_op_configure_filter(struct ieee80211_hw *hw,
 	} else if (*total & FIF_ALLMULTI || fp->enabled == false) {
 		cc33xx_acx_group_address_tbl(wl, wlvif, false, NULL, 0);
 	} else {
-		cc33xx_acx_group_address_tbl(wl, wlvif, true, fp->mc_list, fp->mc_list_length);
+		cc33xx_acx_group_address_tbl(wl, wlvif, true,
+					     fp->mc_list, fp->mc_list_length);
 	}
 
 out:
-		mutex_unlock(&wl->mutex);
-		kfree(fp);
+	mutex_unlock(&wl->mutex);
+	kfree(fp);
 }
 
 static int cc33xx_record_ap_key(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-				u8 id, u8 key_type, u8 key_size,
-				const u8 *key, u8 hlid, u32 tx_seq_32,
-				u16 tx_seq_16)
+				u8 id, u8 key_type, u8 key_size, const u8 *key,
+				u8 hlid, u32 tx_seq_32,	u16 tx_seq_16)
 {
 	struct cc33xx_ap_key *ap_key;
 	int i;
@@ -3350,9 +3273,8 @@ static int cc33xx_ap_init_hwenc(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 
 		ret = cc33xx_cmd_set_ap_key(wl, wlvif, KEY_ADD_OR_REPLACE,
 					    key->id, key->key_type,
-					    key->key_size, key->key,
-					    hlid, key->tx_seq_32,
-					    key->tx_seq_16);
+					    key->key_size, key->key, hlid,
+					    key->tx_seq_32, key->tx_seq_16);
 		if (ret < 0)
 			goto out;
 
@@ -3373,9 +3295,9 @@ static int cc33xx_ap_init_hwenc(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 }
 
 static int cc33xx_config_key(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-		       u16 action, u8 id, u8 key_type,
-		       u8 key_size, const u8 *key, u32 tx_seq_32,
-		       u16 tx_seq_16, struct ieee80211_sta *sta)
+			     u16 action, u8 id, u8 key_type, u8 key_size,
+			     const u8 *key, u32 tx_seq_32,u16 tx_seq_16,
+			     struct ieee80211_sta *sta)
 {
 	int ret;
 	bool is_ap = (wlvif->bss_type == BSS_TYPE_AP_BSS);
@@ -3399,15 +3321,13 @@ static int cc33xx_config_key(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			if (action != KEY_ADD_OR_REPLACE)
 				return 0;
 
-			ret = cc33xx_record_ap_key(wl, wlvif, id,
-					     key_type, key_size,
-					     key, hlid, tx_seq_32,
-					     tx_seq_16);
+			ret = cc33xx_record_ap_key(wl, wlvif, id, key_type,
+						   key_size, key, hlid,
+						   tx_seq_32, tx_seq_16);
 		} else {
-			ret = cc33xx_cmd_set_ap_key(wl, wlvif, action,
-					     id, key_type, key_size,
-					     key, hlid, tx_seq_32,
-					     tx_seq_16);
+			ret = cc33xx_cmd_set_ap_key(wl, wlvif, action, id,
+						    key_type, key_size, key,
+						    hlid, tx_seq_32, tx_seq_16);
 		}
 
 		if (ret < 0)
@@ -3437,13 +3357,11 @@ static int cc33xx_config_key(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 		    wlvif->sta.hlid == CC33XX_INVALID_LINK_ID)
 			return 0;
 
-		ret = cc33xx_cmd_set_sta_key(wl, wlvif, action,
-					     id, key_type, key_size,
-					     key, addr, tx_seq_32,
+		ret = cc33xx_cmd_set_sta_key(wl, wlvif, action, id, key_type,
+					     key_size, key, addr, tx_seq_32,
 					     tx_seq_16);
 		if (ret < 0)
 			return ret;
-
 	}
 
 	return 0;
@@ -3454,7 +3372,7 @@ static int cc33xx_set_host_cfg_bitmap(struct cc33xx *wl, u32 extra_mem_blk)
 	int ret;
 	u32 sdio_align_size = 0;
 	u32 host_cfg_bitmap = HOST_IF_CFG_RX_FIFO_ENABLE |
-			      HOST_IF_CFG_ADD_RX_ALIGNMENT;
+						HOST_IF_CFG_ADD_RX_ALIGNMENT;
 
 	/* Enable Tx SDIO padding */
 	if (wl->quirks & WLCORE_QUIRK_TX_BLOCKSIZE_ALIGN) {
@@ -3478,8 +3396,7 @@ static int cc33xx_set_host_cfg_bitmap(struct cc33xx *wl, u32 extra_mem_blk)
 }
 
 static int cc33xx_set_key(struct cc33xx *wl, enum set_key_cmd cmd,
-			  struct ieee80211_vif *vif,
-			  struct ieee80211_sta *sta,
+			  struct ieee80211_vif *vif, struct ieee80211_sta *sta,
 			  struct ieee80211_key_conf *key_conf)
 {
 	bool change_spare = false, special_enc;
@@ -3520,10 +3437,9 @@ static int cc33xx_set_key(struct cc33xx *wl, enum set_key_cmd cmd,
 	/* key is now set, change the spare blocks */
 	if (wl->extra_spare_key_count)
 		ret = cc33xx_set_host_cfg_bitmap(wl,
-					CC33XX_TX_HW_EXTRA_BLOCK_SPARE);
+						CC33XX_TX_HW_EXTRA_BLOCK_SPARE);
 	else
-		ret = cc33xx_set_host_cfg_bitmap(wl,
-					CC33XX_TX_HW_BLOCK_SPARE);
+		ret = cc33xx_set_host_cfg_bitmap(wl, CC33XX_TX_HW_BLOCK_SPARE);
 
 out:
 	return ret;
@@ -3536,9 +3452,8 @@ static int cc33xx_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
 {
 	struct cc33xx *wl = hw->priv;
 	int ret;
-	bool might_change_spare =
-		key_conf->cipher == CC33XX_CIPHER_SUITE_GEM ||
-		key_conf->cipher == WLAN_CIPHER_SUITE_TKIP;
+	bool might_change_spare = key_conf->cipher == CC33XX_CIPHER_SUITE_GEM
+				|| key_conf->cipher == WLAN_CIPHER_SUITE_TKIP;
 
 	if (might_change_spare) {
 		/*
@@ -3568,8 +3483,7 @@ static int cc33xx_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
 }
 
 int wlcore_set_key(struct cc33xx *wl, enum set_key_cmd cmd,
-		   struct ieee80211_vif *vif,
-		   struct ieee80211_sta *sta,
+		   struct ieee80211_vif *vif, struct ieee80211_sta *sta,
 		   struct ieee80211_key_conf *key_conf)
 {
 	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
@@ -3607,7 +3521,6 @@ int wlcore_set_key(struct cc33xx *wl, enum set_key_cmd cmd,
 	case WLAN_CIPHER_SUITE_WEP40:
 	case WLAN_CIPHER_SUITE_WEP104:
 		key_type = KEY_WEP;
-
 		key_conf->hw_key_idx = key_conf->keyidx;
 		break;
 	case WLAN_CIPHER_SUITE_TKIP:
@@ -3654,9 +3567,8 @@ int wlcore_set_key(struct cc33xx *wl, enum set_key_cmd cmd,
 	switch (cmd) {
 	case SET_KEY:
 		ret = cc33xx_config_key(wl, wlvif, KEY_ADD_OR_REPLACE,
-				 key_conf->keyidx, key_type,
-				 key_conf->keylen, key_conf->key,
-				 tx_seq_32, tx_seq_16, sta);
+				 key_conf->keyidx, key_type, key_conf->keylen,
+				 key_conf->key, tx_seq_32, tx_seq_16, sta);
 		if (ret < 0) {
 			cc33xx_error("Could not add or replace key");
 			return ret;
@@ -3670,7 +3582,6 @@ int wlcore_set_key(struct cc33xx *wl, enum set_key_cmd cmd,
 		    (sta || key_type == KEY_WEP) &&
 		    wlvif->encryption_type != key_type) {
 			wlvif->encryption_type = key_type;
-			ret = cc33xx_cmd_build_arp_rsp(wl, wlvif);
 			if (ret < 0) {
 				cc33xx_warning("build arp rsp failed: %d", ret);
 				return ret;
@@ -3679,10 +3590,9 @@ int wlcore_set_key(struct cc33xx *wl, enum set_key_cmd cmd,
 		break;
 
 	case DISABLE_KEY:
-		ret = cc33xx_config_key(wl, wlvif, KEY_REMOVE,
-				     key_conf->keyidx, key_type,
-				     key_conf->keylen, key_conf->key,
-				     0, 0, sta);
+		ret = cc33xx_config_key(wl, wlvif, KEY_REMOVE, key_conf->keyidx,
+					key_type, key_conf->keylen,
+					key_conf->key, 0, 0, sta);
 		if (ret < 0) {
 			cc33xx_error("Could not remove key");
 			return ret;
@@ -3704,8 +3614,8 @@ static void cc33xx_op_set_default_key_idx(struct ieee80211_hw *hw,
 	struct cc33xx *wl = hw->priv;
 	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
 
-	cc33xx_debug(DEBUG_MAC80211, "mac80211 set default key idx %d",
-		     key_idx);
+	cc33xx_debug(DEBUG_MAC80211,
+		     "mac80211 set default key idx %d", key_idx);
 
 	/* we don't handle unsetting of default key */
 	if (key_idx == -1)
@@ -3713,18 +3623,14 @@ static void cc33xx_op_set_default_key_idx(struct ieee80211_hw *hw,
 
 	mutex_lock(&wl->mutex);
 
-	if (unlikely(wl->state != WLCORE_STATE_ON)) {
+	if (unlikely(wl->state != WLCORE_STATE_ON))
 		goto out_unlock;
-	}
 
 	wlvif->default_key = key_idx;
 
 	/* the default WEP key needs to be configured at least once */
-	if (wlvif->encryption_type == KEY_WEP) {
-		cc33xx_cmd_set_default_wep_key(wl,
-				key_idx,
-				wlvif->sta.hlid);
-	}
+	if (wlvif->encryption_type == KEY_WEP)
+		cc33xx_cmd_set_default_wep_key(wl, key_idx, wlvif->sta.hlid);
 
 out_unlock:
 	mutex_unlock(&wl->mutex);
@@ -3742,7 +3648,6 @@ void wlcore_regdomain_config(struct cc33xx *wl)
 	if (unlikely(wl->state != WLCORE_STATE_ON))
 		goto out;
 
-	//ret = wlcore_cmd_regdomain_config_locked(wl);
 	if (ret < 0) {
 		cc33xx_queue_recovery_work(wl);
 		goto out;
@@ -3752,8 +3657,7 @@ void wlcore_regdomain_config(struct cc33xx *wl)
 	mutex_unlock(&wl->mutex);
 }
 
-static int cc33xx_op_hw_scan(struct ieee80211_hw *hw,
-			     struct ieee80211_vif *vif,
+static int cc33xx_op_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			     struct ieee80211_scan_request *hw_req)
 {
 	struct cfg80211_scan_request *req = &hw_req->req;
@@ -3882,9 +3786,8 @@ static int cc33xx_op_sched_scan_stop(struct ieee80211_hw *hw,
 	if (unlikely(wl->state != WLCORE_STATE_ON))
 		goto out;
 
-	// command to stop periodic scan was sent from mac80211
-	// mark than stop command is from mac80211 and release
-	// sched_vif
+	/* command to stop periodic scan was sent from mac80211
+	   mark than stop command is from mac80211 and release sched_vif */
 	wl->mac80211_scan_stopped = true;
 	wl->sched_vif = NULL;
 	cc33xx_scan_sched_scan_stop(wl, wlvif);
@@ -3969,12 +3872,14 @@ static int cc33xx_bss_erp_info_changed(struct cc33xx *wl,
 	}
 
 	if (changed & BSS_CHANGED_ERP_CTS_PROT) {
-		if (bss_conf->use_cts_prot)
+		if (bss_conf->use_cts_prot) {
 			ret = cc33xx_acx_cts_protect(wl, wlvif,
 						     CTSPROTECT_ENABLE);
-		else
+		} else {
 			ret = cc33xx_acx_cts_protect(wl, wlvif,
 						     CTSPROTECT_DISABLE);
+		}
+
 		if (ret < 0) {
 			cc33xx_warning("Set ctsprotect failed %d", ret);
 			goto out;
@@ -3986,8 +3891,7 @@ static int cc33xx_bss_erp_info_changed(struct cc33xx *wl,
 }
 
 static int wlcore_set_beacon_template(struct cc33xx *wl,
-				      struct ieee80211_vif *vif,
-				      bool is_ap)
+				     struct ieee80211_vif *vif, bool is_ap)
 {
 	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
 	int ret;
@@ -3997,7 +3901,7 @@ static int wlcore_set_beacon_template(struct cc33xx *wl,
 	struct cc33xx_cmd_set_beacon_info *cmd;
 
 	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
-	 if (!cmd) {
+	if (!cmd) {
 		ret = -ENOMEM;
 		goto out;
 	}
@@ -4010,9 +3914,8 @@ static int wlcore_set_beacon_template(struct cc33xx *wl,
 	cc33xx_debug(DEBUG_MASTER, "beacon updated");
 
 	ret = cc33xx_ssid_set(wlvif, beacon, ieoffset);
-	if (ret < 0) {
+	if (ret < 0)
 		goto end_bcn;
-	}
 
 	cmd->role_id =  wlvif->role_id;
 	cmd->beacon_len = cpu_to_le16(beacon->len);
@@ -4020,9 +3923,8 @@ static int wlcore_set_beacon_template(struct cc33xx *wl,
 	memcpy(cmd->beacon, beacon->data, beacon->len);
 
 	ret = cc33xx_cmd_send(wl, CMD_AP_SET_BEACON_INFO, cmd, sizeof(*cmd), 0);
-	if (ret < 0) {
+	if (ret < 0)
 		goto end_bcn;
-	}
 
 end_bcn:
 	dev_kfree_skb(beacon);
@@ -4042,7 +3944,7 @@ static int cc33xx_bss_beacon_info_changed(struct cc33xx *wl,
 
 	if (changed & BSS_CHANGED_BEACON_INT) {
 		cc33xx_debug(DEBUG_MASTER, "beacon interval updated: %d",
-			bss_conf->beacon_int);
+			     bss_conf->beacon_int);
 
 		wlvif->beacon_int = bss_conf->beacon_int;
 	}
@@ -4062,6 +3964,7 @@ static int cc33xx_bss_beacon_info_changed(struct cc33xx *wl,
 out:
 	if (ret != 0)
 		cc33xx_error("beacon info change failed: %d", ret);
+
 	return ret;
 }
 
@@ -4080,10 +3983,12 @@ static void cc33xx_bss_info_changed_ap(struct cc33xx *wl,
 		wlvif->basic_rate_set = cc33xx_tx_enabled_rates_get(wl, rates,
 								 wlvif->band);
 		wlvif->basic_rate = cc33xx_tx_min_rate_get(wl,
-							wlvif->basic_rate_set);
+							 wlvif->basic_rate_set);
 
 		supported_rates = CONF_TX_ENABLED_RATES | CONF_TX_MCS_RATES ;
-		ret = cc33xx_update_ap_rates(wl,wlvif->role_id,wlvif->basic_rate_set,supported_rates);
+		ret = cc33xx_update_ap_rates(wl, wlvif->role_id,
+					     wlvif->basic_rate_set,
+					     supported_rates);
 
 		ret = wlcore_set_beacon_template(wl, vif, true);
 		if (ret < 0)
@@ -4138,43 +4043,36 @@ static void cc33xx_bss_info_changed_ap(struct cc33xx *wl,
 }
 
 static int wlcore_set_bssid(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			    struct ieee80211_bss_conf *bss_conf,
-				struct ieee80211_vif *vif,
-			    u32 sta_rate_set)
+			struct ieee80211_bss_conf *bss_conf,
+			struct ieee80211_vif *vif,
+			u32 sta_rate_set)
 {
 	u32 rates;
-	int ret;
 
-	cc33xx_debug(DEBUG_MAC80211,
-	     "changed_bssid: %pM, aid: %d, bcn_int: %d, brates: 0x%x sta_rate_set: 0x%x, nontx: %d",
-	     bss_conf->bssid, vif->cfg.aid,
-	     bss_conf->beacon_int,
-	     bss_conf->basic_rates, sta_rate_set,
-	     bss_conf->nontransmitted);
+	cc33xx_debug(DEBUG_MAC80211, "changed_bssid: %pM, aid: %d, bcn_int: %d,"
+			" brates: 0x%x sta_rate_set: 0x%x, nontx: %d",
+			bss_conf->bssid, vif->cfg.aid, bss_conf->beacon_int,
+			bss_conf->basic_rates, sta_rate_set,
+			bss_conf->nontransmitted);
 
 	wlvif->beacon_int = bss_conf->beacon_int;
 	rates = bss_conf->basic_rates;
-	wlvif->basic_rate_set =
-		cc33xx_tx_enabled_rates_get(wl, rates,
-					    wlvif->band);
-	wlvif->basic_rate =
-		cc33xx_tx_min_rate_get(wl,
-				       wlvif->basic_rate_set);
-
-	if (sta_rate_set)
-		wlvif->rate_set =
-			cc33xx_tx_enabled_rates_get(wl,
-						sta_rate_set,
-						wlvif->band);
+	wlvif->basic_rate_set =	cc33xx_tx_enabled_rates_get(wl, rates,
+							    wlvif->band);
+	wlvif->basic_rate = cc33xx_tx_min_rate_get(wl, wlvif->basic_rate_set);
+
+	if (sta_rate_set) {
+		wlvif->rate_set = cc33xx_tx_enabled_rates_get(wl, sta_rate_set,
+							      wlvif->band);
+	}
 
 	wlvif->nontransmitted = bss_conf->nontransmitted;
-	cc33xx_debug(DEBUG_MAC80211,
-	     "changed_mbssid: nonTxbssid: %d, idx: %d, max_ind: %d, trans_bssid: %pM, ema_ap: %d",
-	     bss_conf->nontransmitted,
-	     bss_conf->bssid_index,
-	     bss_conf->bssid_indicator,
-	     bss_conf->transmitter_bssid,
-	     bss_conf->ema_ap);
+	cc33xx_debug(DEBUG_MAC80211, "changed_mbssid: nonTxbssid: %d, idx: %d, "
+		     "max_ind: %d, trans_bssid: %pM, ema_ap: %d",
+		     bss_conf->nontransmitted, bss_conf->bssid_index,
+		     bss_conf->bssid_indicator, bss_conf->transmitter_bssid,
+		     bss_conf->ema_ap);
+
 	if (bss_conf->nontransmitted)
 	{
 		wlvif->bssid_index = bss_conf->bssid_index;
@@ -4183,18 +4081,11 @@ static int wlcore_set_bssid(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			bss_conf->transmitter_bssid,
 			ETH_ALEN);
 	}
+
 	/* we only support sched_scan while not connected */
 	if (wl->sched_vif == wlvif)
 		cc33xx_scan_sched_scan_stop(wl, wlvif);
 
-	ret = cc33xx_cmd_build_null_data(wl, wlvif);
-	if (ret < 0)
-		return ret;
-
-	ret = cc33xx_build_qos_null_data(wl, cc33xx_wlvif_to_vif(wlvif));
-	if (ret < 0)
-		return ret;
-
 	wlcore_set_ssid(wl, wlvif);
 
 	set_bit(WLVIF_FLAG_IN_USE, &wlvif->flags);
@@ -4202,18 +4093,6 @@ static int wlcore_set_bssid(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return 0;
 }
 
-static int cc33xx_set_peer_cap(struct cc33xx *wl,
-			       struct ieee80211_sta_ht_cap *ht_cap,
-			       struct ieee80211_sta_he_cap *he_cap,
-			       struct cc33xx_vif *wlvif,
-			       bool allow_ht_operation,
-			       u32 rate_set, u8 hlid)
-{
-
-    return cc33xx_acx_set_peer_cap(wl, ht_cap, he_cap, wlvif, allow_ht_operation,
-			   rate_set, hlid);
-}
-
 static int wlcore_clear_bssid(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 {
 	int ret;
@@ -4232,13 +4111,13 @@ static int wlcore_clear_bssid(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	clear_bit(WLVIF_FLAG_IN_USE, &wlvif->flags);
 	return 0;
 }
+
 /* STA/IBSS mode changes */
 static void cc33xx_bss_info_changed_sta(struct cc33xx *wl,
 					struct ieee80211_vif *vif,
 					struct ieee80211_bss_conf *bss_conf,
 					u64 changed)
 {
-
 	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
 	bool do_join = false;
 	bool is_ibss = (wlvif->bss_type == BSS_TYPE_IBSS);
@@ -4251,15 +4130,14 @@ static void cc33xx_bss_info_changed_sta(struct cc33xx *wl,
 	struct ieee80211_sta_he_cap sta_he_cap;
 
 	if (is_ibss) {
-		ret = cc33xx_bss_beacon_info_changed(wl, vif, bss_conf,
-						     changed);
+		ret = cc33xx_bss_beacon_info_changed(wl, vif,
+						     bss_conf, changed);
 		if (ret < 0)
 			goto out;
 	}
 
-
 	if (changed & BSS_CHANGED_IBSS) {
-		if (vif->cfg.ibss_joined) {
+		if (vif->cfg.ibss_joined){
 			set_bit(WLVIF_FLAG_IBSS_JOINED, &wlvif->flags);
 			ibss_joined = true;
 		} else {
@@ -4286,19 +4164,17 @@ static void cc33xx_bss_info_changed_sta(struct cc33xx *wl,
 		cc33xx_sta_handle_idle(wl, wlvif, vif->cfg.idle);
 
 	if (changed & BSS_CHANGED_CQM) {
-		bool enable = false;
-		if (bss_conf->cqm_rssi_thold)
-			enable = true;
+		bool enable = bss_conf->cqm_rssi_thold;
 		ret = cc33xx_acx_rssi_snr_trigger(wl, wlvif, enable,
 						  bss_conf->cqm_rssi_thold,
 						  bss_conf->cqm_rssi_hyst);
 		if (ret < 0)
 			goto out;
+
 		wlvif->rssi_thold = bss_conf->cqm_rssi_thold;
 	}
 
-	if (changed & (BSS_CHANGED_BSSID | BSS_CHANGED_HT |
-		       BSS_CHANGED_ASSOC)) {
+	if (changed & (BSS_CHANGED_BSSID | BSS_CHANGED_HT | BSS_CHANGED_ASSOC)){
 		rcu_read_lock();
 		sta = ieee80211_find_sta(vif, bss_conf->bssid);
 		if (sta) {
@@ -4306,10 +4182,11 @@ static void cc33xx_bss_info_changed_sta(struct cc33xx *wl,
 
 			/* save the supp_rates of the ap */
 			sta_rate_set = sta->deflink.supp_rates[wlvif->band];
-			if (sta->deflink.ht_cap.ht_supported)
+			if (sta->deflink.ht_cap.ht_supported) {
 				sta_rate_set |=
 					(rx_mask[0] << HW_HT_RATES_OFFSET) |
 					(rx_mask[1] << HW_MIMO_RATES_OFFSET);
+			}
 			sta_ht_cap = sta->deflink.ht_cap;
 			sta_he_cap = sta->deflink.he_cap;
 			sta_exists = true;
@@ -4320,8 +4197,8 @@ static void cc33xx_bss_info_changed_sta(struct cc33xx *wl,
 
 	if (changed & BSS_CHANGED_BSSID) {
 		if (!is_zero_ether_addr(bss_conf->bssid)) {
-			ret = wlcore_set_bssid(wl, wlvif, bss_conf,
-					       vif, sta_rate_set);
+			ret = wlcore_set_bssid(wl, wlvif,
+					       bss_conf, vif, sta_rate_set);
 			if (ret < 0)
 				goto out;
 
@@ -4380,30 +4257,33 @@ static void cc33xx_bss_info_changed_sta(struct cc33xx *wl,
 
 			if (test_bit(WLVIF_FLAG_STA_AUTHORIZED, &wlvif->flags))
 				cc33xx_set_authorized(wl, wlvif);
+
 			if (sta) {
 				struct cc33xx_vif *wlvif_itr;
 				u8 he_count = 0;
 
 				wlvif->sta_has_he = sta->deflink.he_cap.has_he;
 
-				if (sta->deflink.he_cap.has_he) {
+				if (sta->deflink.he_cap.has_he)
 					cc33xx_info("HE Enabled");
-				} else {
+				else
 					cc33xx_info("HE Disabled");
-				}
 
 				cc33xx_for_each_wlvif_sta(wl, wlvif_itr) {
-					//check for all valid link id's
+					/* check for all valid link id's */
 					if (wlvif_itr->role_id != 0xFF) {
 						if (wlvif_itr->sta_has_he)
 							he_count++;
 					}
 				}
-				/* There can't be two stations connected with HE supported links*/
-				if (he_count > 1)
-					cc33xx_error("WARNING: Both station interfaces has HE enabled!");
-			}
 
+				/* There can't be two stations connected
+				   with HE supported links */
+				if (he_count > 1) {
+					cc33xx_error("WARNING: Both station "
+						  "interfaces has HE enabled!");
+				}
+			}
 		} else {
 			wlcore_unset_assoc(wl, wlvif);
 		}
@@ -4430,8 +4310,8 @@ static void cc33xx_bss_info_changed_sta(struct cc33xx *wl,
 			if (ret < 0)
 				cc33xx_warning("enter %s ps failed %d",
 					       ps_mode_str, ret);
-		} else if (!vif->cfg.ps &&
-			   test_bit(WLVIF_FLAG_IN_PS, &wlvif->flags)) {
+		} else if (!vif->cfg.ps && test_bit(WLVIF_FLAG_IN_PS,
+						     &wlvif->flags)) {
 			cc33xx_debug(DEBUG_PSM, "auto ps disabled");
 
 			ret = cc33xx_ps_set_mode(wl, wlvif,
@@ -4443,20 +4323,16 @@ static void cc33xx_bss_info_changed_sta(struct cc33xx *wl,
 
 	/* Handle new association with HT. Do this after join. */
 	if (sta_exists) {
-		bool enabled =
-			bss_conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT;
-		cc33xx_debug(DEBUG_CMD, " +++Debug wlcore_hw_set_peer_cap %x", wlvif->rate_set);
-		ret = cc33xx_set_peer_cap(	wl,
-						&sta_ht_cap,
-						&sta_he_cap,
-						wlvif,
-						enabled,
-						wlvif->rate_set,
-						wlvif->sta.hlid);
+		bool enabled = bss_conf->chandef.width !=
+						NL80211_CHAN_WIDTH_20_NOHT;
+		cc33xx_debug(DEBUG_CMD, "+++Debug wlcore_hw_set_peer_cap %x",
+					wlvif->rate_set);
+		ret = cc33xx_acx_set_peer_cap(wl, &sta_ht_cap, &sta_he_cap,
+					      wlvif, enabled, wlvif->rate_set,
+					      wlvif->sta.hlid);
 		if (ret < 0) {
 			cc33xx_warning("Set ht cap failed %d", ret);
 			goto out;
-
 		}
 
 		if (enabled) {
@@ -4487,19 +4363,17 @@ static void cc33xx_bss_info_changed_sta(struct cc33xx *wl,
 			 * isn't being set (when sending), so we have to
 			 * reconfigure the template upon every ip change.
 			 */
-			ret = cc33xx_cmd_build_arp_rsp(wl, wlvif);
 			if (ret < 0) {
 				cc33xx_warning("build arp rsp failed: %d", ret);
 				goto out;
 			}
 
-			ret = cc33x_acx_arp_ip_filter(wl, wlvif,
+			ret = cc33xx_acx_arp_ip_filter(wl, wlvif,
 				(ACX_ARP_FILTER_ARP_FILTERING |
-				 ACX_ARP_FILTER_AUTO_ARP),
-				addr);
+				ACX_ARP_FILTER_AUTO_ARP), addr);
 		} else {
 			wlvif->ip_addr = 0;
-			ret = cc33x_acx_arp_ip_filter(wl, wlvif, 0, addr);
+			ret = cc33xx_acx_arp_ip_filter(wl, wlvif, 0, addr);
 		}
 
 		if (ret < 0)
@@ -4520,7 +4394,6 @@ static void cc33xx_op_bss_info_changed(struct ieee80211_hw *hw,
 	bool is_ap = (wlvif->bss_type == BSS_TYPE_AP_BSS);
 	int ret, set_power;
 
-
 	cc33xx_debug(DEBUG_MAC80211, "mac80211 bss info role %d changed 0x%x",
 		     wlvif->role_id, (int)changed);
 
@@ -4543,14 +4416,13 @@ static void cc33xx_op_bss_info_changed(struct ieee80211_hw *hw,
 	if (unlikely(!test_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags)))
 		goto out;
 
-
 	if ((changed & BSS_CHANGED_TXPOWER) &&
 	    (bss_conf->txpower != wlvif->power_level)) {
 		/* bss_conf->txpower is initialized with a default value,
 		meaning the power has not been set and should be ignored, use
 		max value instead */
-		set_power = (bss_conf->txpower == INT_MIN) ? CC33XX_MAX_TXPWR :
-							     bss_conf->txpower;
+		set_power = (bss_conf->txpower == INT_MIN) ?
+					   CC33XX_MAX_TXPWR : bss_conf->txpower;
 		ret = cc33xx_acx_tx_power(wl, wlvif, set_power);
 
 		if (ret < 0)
@@ -4589,8 +4461,7 @@ static void cc33xx_op_change_chanctx(struct ieee80211_hw *hw,
 {
 	struct cc33xx *wl = hw->priv;
 	struct cc33xx_vif *wlvif;
-	int channel = ieee80211_frequency_to_channel(
-		ctx->def.chan->center_freq);
+	int channel =ieee80211_frequency_to_channel(ctx->def.chan->center_freq);
 
 	cc33xx_debug(DEBUG_MAC80211,
 		     "mac80211 change chanctx %d (type %d) changed 0x%x",
@@ -4629,14 +4500,11 @@ static int cc33xx_op_assign_vif_chanctx(struct ieee80211_hw *hw,
 {
 	struct cc33xx *wl = hw->priv;
 	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
-	int channel = ieee80211_frequency_to_channel(
-		ctx->def.chan->center_freq);
+	int channel =ieee80211_frequency_to_channel(ctx->def.chan->center_freq);
 
-	cc33xx_debug(DEBUG_MAC80211,
-		     "mac80211 assign chanctx (role %d) %d (type %d)"
-		     "(radar %d dfs_state %d)",
-		     wlvif->role_id, channel,
-		     cfg80211_get_chandef_type(&ctx->def),
+	cc33xx_debug(DEBUG_MAC80211, "mac80211 assign chanctx (role %d) %d "
+		     "(type %d) (radar %d dfs_state %d)",wlvif->role_id,
+		     channel, cfg80211_get_chandef_type(&ctx->def),
 		     ctx->radar_enabled, ctx->def.chan->dfs_state);
 
 	mutex_lock(&wl->mutex);
@@ -4655,7 +4523,7 @@ static int cc33xx_op_assign_vif_chanctx(struct ieee80211_hw *hw,
 	cc33xx_set_band_rate(wl, wlvif);
 
 	if (ctx->radar_enabled &&
-	    ctx->def.chan->dfs_state == NL80211_DFS_USABLE) {
+	    (ctx->def.chan->dfs_state == NL80211_DFS_USABLE)) {
 		cc33xx_debug(DEBUG_MAC80211, "Start radar detection");
 		cmd_set_cac(wl, wlvif, true);
 		wlvif->radar_enabled = true;
@@ -4701,9 +4569,8 @@ static void cc33xx_op_unassign_vif_chanctx(struct ieee80211_hw *hw,
 	mutex_unlock(&wl->mutex);
 }
 
-static int __wlcore_switch_vif_chan(struct cc33xx *wl,
-				    struct cc33xx_vif *wlvif,
-				    struct ieee80211_chanctx_conf *new_ctx)
+static int cc33xx_switch_vif_chan(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+				  struct ieee80211_chanctx_conf *new_ctx)
 {
 	int channel = ieee80211_frequency_to_channel(
 		new_ctx->def.chan->center_freq);
@@ -4713,7 +4580,13 @@ static int __wlcore_switch_vif_chan(struct cc33xx *wl,
 		     wlvif->role_id, wlvif->channel, channel,
 		     cfg80211_get_chandef_type(&new_ctx->def));
 
-	if (WARN_ON_ONCE(wlvif->bss_type != BSS_TYPE_AP_BSS))
+	cc33xx_debug(DEBUG_MAC80211, "switch vif bss_type: %d", wlvif->bss_type);
+
+	wlvif->band = new_ctx->def.chan->band;
+	wlvif->channel = channel;
+	wlvif->channel_type = cfg80211_get_chandef_type(&new_ctx->def);
+
+	if (wlvif->bss_type != BSS_TYPE_AP_BSS)
 		return 0;
 
 	WARN_ON(!test_bit(WLVIF_FLAG_BEACON_DISABLED, &wlvif->flags));
@@ -4724,9 +4597,6 @@ static int __wlcore_switch_vif_chan(struct cc33xx *wl,
 		wlvif->radar_enabled = false;
 	}
 
-	wlvif->band = new_ctx->def.chan->band;
-	wlvif->channel = channel;
-	wlvif->channel_type = cfg80211_get_chandef_type(&new_ctx->def);
 
 	/* start radar if needed */
 	if (new_ctx->radar_enabled) {
@@ -4738,25 +4608,23 @@ static int __wlcore_switch_vif_chan(struct cc33xx *wl,
 	return 0;
 }
 
-static int
-cc33xx_op_switch_vif_chanctx(struct ieee80211_hw *hw,
-			     struct ieee80211_vif_chanctx_switch *vifs,
-			     int n_vifs,
-			     enum ieee80211_chanctx_switch_mode mode)
+static int cc33xx_op_switch_vif_chanctx(struct ieee80211_hw *hw,
+					struct ieee80211_vif_chanctx_switch *vifs,
+					int n_vifs,
+					enum ieee80211_chanctx_switch_mode mode)
 {
 	struct cc33xx *wl = hw->priv;
 	int i, ret;
 
 	cc33xx_debug(DEBUG_MAC80211,
-		     "mac80211 switch chanctx n_vifs %d mode %d",
-		     n_vifs, mode);
+		     "mac80211 switch chanctx n_vifs %d mode %d", n_vifs, mode);
 
 	mutex_lock(&wl->mutex);
 
 	for (i = 0; i < n_vifs; i++) {
 		struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vifs[i].vif);
 
-		ret = __wlcore_switch_vif_chan(wl, wlvif, vifs[i].new_ctx);
+		ret = cc33xx_switch_vif_chan(wl, wlvif, vifs[i].new_ctx);
 		if (ret)
 			goto out;
 	}
@@ -4768,7 +4636,8 @@ cc33xx_op_switch_vif_chanctx(struct ieee80211_hw *hw,
 }
 
 static int cc33xx_op_conf_tx(struct ieee80211_hw *hw,
-			     struct ieee80211_vif *vif, unsigned int link_id, u16 queue,
+			     struct ieee80211_vif *vif,
+			     unsigned int link_id, u16 queue,
 			     const struct ieee80211_tx_queue_params *params)
 {
 	struct cc33xx *wl = hw->priv;
@@ -4796,12 +4665,11 @@ static int cc33xx_op_conf_tx(struct ieee80211_hw *hw,
 	 * we need us
 	 */
     ret = cc33xx_tx_param_cfg(wl, wlvif, cc33xx_tx_get_queue(queue),
-		params->cw_min, params->cw_max,
-		params->aifs, params->txop << 5, params->acm,
-		ps_scheme, params->mu_edca,
-		params->mu_edca_param_rec.aifsn,
-		params->mu_edca_param_rec.ecw_min_max,
-		params->mu_edca_param_rec.mu_edca_timer);
+			      params->cw_min, params->cw_max, params->aifs,
+			      params->txop << 5, params->acm, ps_scheme,
+			      params->mu_edca, params->mu_edca_param_rec.aifsn,
+			      params->mu_edca_param_rec.ecw_min_max,
+			      params->mu_edca_param_rec.mu_edca_timer);
 
 out:
 	mutex_unlock(&wl->mutex);
@@ -4809,8 +4677,7 @@ static int cc33xx_op_conf_tx(struct ieee80211_hw *hw,
 	return ret;
 }
 
-static u64 cc33xx_op_get_tsf(struct ieee80211_hw *hw,
-			     struct ieee80211_vif *vif)
+static u64 cc33xx_op_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 
 	struct cc33xx *wl = hw->priv;
@@ -4828,6 +4695,7 @@ static u64 cc33xx_op_get_tsf(struct ieee80211_hw *hw,
 
 out:
 	mutex_unlock(&wl->mutex);
+
 	return mactime;
 }
 
@@ -4851,8 +4719,7 @@ static int cc33xx_allocate_sta(struct cc33xx *wl,
 	struct cc33xx_station *wl_sta;
 	int ret;
 
-
-	if (wl->active_sta_count >= wl->max_ap_stations) {
+	if (wl->active_sta_count >= CC33XX_MAX_AP_STATIONS) {
 		cc33xx_warning("could not allocate HLID - too much stations");
 		return -EBUSY;
 	}
@@ -4944,11 +4811,9 @@ static int cc33xx_sta_remove(struct cc33xx *wl,
 	return ret;
 }
 
-static void wlcore_roc_if_possible(struct cc33xx *wl,
-				   struct cc33xx_vif *wlvif)
+static void wlcore_roc_if_possible(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 {
-	if (find_first_bit(wl->roc_map,
-			   CC33XX_MAX_ROLES) < CC33XX_MAX_ROLES)
+	if (find_first_bit(wl->roc_map, CC33XX_MAX_ROLES) < CC33XX_MAX_ROLES)
 		return;
 
 	if (WARN_ON(wlvif->role_id == CC33XX_INVALID_ROLE_ID))
@@ -4966,25 +4831,28 @@ static void wlcore_roc_if_possible(struct cc33xx *wl,
 void wlcore_update_inconn_sta(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			      struct cc33xx_station *wl_sta, bool in_conn)
 {
-	cc33xx_debug(DEBUG_CMD, "Enter update_inconn_sta: in_conn=%d count=%d, pending_auth=%d",
-		     in_conn, wlvif->inconn_count, wlvif->ap_pending_auth_reply);
+	cc33xx_debug(DEBUG_CMD, "Enter update_inconn_sta: "
+		     "in_conn=%d count=%d, pending_auth=%d", in_conn,
+		     wlvif->inconn_count, wlvif->ap_pending_auth_reply);
+
 	if (in_conn) {
 		if (WARN_ON(wl_sta && wl_sta->in_connection))
 			return;
 
-		if (!wlvif->ap_pending_auth_reply &&
-		    !wlvif->inconn_count){
+		if (!wlvif->ap_pending_auth_reply && !wlvif->inconn_count){
 			wlcore_roc_if_possible(wl, wlvif);
 			if (test_bit(wlvif->role_id, wl->roc_map)){
-				// set timer on croc timeout
+				/* set timer on croc timeout */
 				wlvif->pending_auth_reply_time = jiffies;
 				cancel_delayed_work(&wlvif->roc_timeout_work);
-				cc33xx_debug(DEBUG_AP, "delay queue roc_timeout_work");
+				cc33xx_debug(DEBUG_AP,
+					     "delay queue roc_timeout_work");
 				ieee80211_queue_delayed_work(wl->hw,
-					&wlvif->roc_timeout_work,
-					msecs_to_jiffies(CC33xx_PEND_ROC_COMPLETE_TIMEOUT));
+						&wlvif->roc_timeout_work,
+						msecs_to_jiffies(
+					     CC33xx_PEND_ROC_COMPLETE_TIMEOUT));
 			}
-		    }
+		}
 
 		if (wl_sta) {
 			wl_sta->in_connection = true;
@@ -5012,13 +4880,14 @@ void wlcore_update_inconn_sta(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 		if (!wlvif->inconn_count && !wlvif->ap_pending_auth_reply &&
 		    test_bit(wlvif->role_id, wl->roc_map)) {
 			cc33xx_croc(wl, wlvif->role_id);
-			//remove timer for croc t/o
+			/* remove timer for croc t/o */
 			cc33xx_debug(DEBUG_AP, "Cancel pending_roc timeout");
 			cancel_delayed_work(&wlvif->roc_timeout_work);
-		    }
+		}
 	}
-	cc33xx_debug(DEBUG_CMD, "Exit update_inconn_sta: in_conn=%d count=%d, pending_auth=%d",
-		     in_conn, wlvif->inconn_count, wlvif->ap_pending_auth_reply);
+	cc33xx_debug(DEBUG_CMD, "Exit update_inconn_sta: in_conn=%d count=%d, "
+		     "pending_auth=%d", in_conn, wlvif->inconn_count,
+		     wlvif->ap_pending_auth_reply);
 }
 
 static int cc33xx_update_sta_state(struct cc33xx *wl,
@@ -5035,9 +4904,8 @@ static int cc33xx_update_sta_state(struct cc33xx *wl,
 	wl_sta = (struct cc33xx_station *)sta->drv_priv;
 
 	/* Add station (AP mode) */
-	if (is_ap &&
-	    old_state == IEEE80211_STA_NOTEXIST &&
-	    new_state == IEEE80211_STA_NONE) {
+	if (is_ap && (old_state == IEEE80211_STA_NOTEXIST) &&
+	    (new_state == IEEE80211_STA_NONE)) {
 		ret = cc33xx_sta_add(wl, wlvif, sta);
 		if (ret)
 			return ret;
@@ -5046,9 +4914,8 @@ static int cc33xx_update_sta_state(struct cc33xx *wl,
 	}
 
 	/* Remove station (AP mode) */
-	if (is_ap &&
-	    old_state == IEEE80211_STA_NONE &&
-	    new_state == IEEE80211_STA_NOTEXIST) {
+	if (is_ap && (old_state == IEEE80211_STA_NONE) &&
+	    (new_state == IEEE80211_STA_NOTEXIST)) {
 		/* must not fail */
 		cc33xx_sta_remove(wl, wlvif, sta);
 
@@ -5056,9 +4923,7 @@ static int cc33xx_update_sta_state(struct cc33xx *wl,
 	}
 
 	/* Authorize station (AP mode) */
-	if (is_ap &&
-	    new_state == IEEE80211_STA_AUTHORIZED) {
-
+	if (is_ap && (new_state == IEEE80211_STA_AUTHORIZED)) {
 		/* reconfigure peer */
 		ret = cc33xx_cmd_add_peer(wl, wlvif, sta, NULL, true);
 		if (ret < 0)
@@ -5068,47 +4933,41 @@ static int cc33xx_update_sta_state(struct cc33xx *wl,
 	}
 
 	/* Authorize station */
-	if (is_sta &&
-	    new_state == IEEE80211_STA_AUTHORIZED) {
+	if (is_sta && (new_state == IEEE80211_STA_AUTHORIZED)) {
 		set_bit(WLVIF_FLAG_STA_AUTHORIZED, &wlvif->flags);
 		ret = cc33xx_set_authorized(wl, wlvif);
 		if (ret)
 			return ret;
 	}
 
-	if (is_sta &&
-	    old_state == IEEE80211_STA_AUTHORIZED &&
-	    new_state == IEEE80211_STA_ASSOC) {
+	if (is_sta && (old_state == IEEE80211_STA_AUTHORIZED) &&
+	    (new_state == IEEE80211_STA_ASSOC)) {
 		clear_bit(WLVIF_FLAG_STA_AUTHORIZED, &wlvif->flags);
 		clear_bit(WLVIF_FLAG_STA_STATE_SENT, &wlvif->flags);
 	}
 
 	/* save seq number on disassoc (suspend) */
-	if (is_sta &&
-	    old_state == IEEE80211_STA_ASSOC &&
-	    new_state == IEEE80211_STA_AUTH) {
+	if (is_sta && (old_state == IEEE80211_STA_ASSOC) &&
+	    (new_state == IEEE80211_STA_AUTH)) {
 		wlcore_save_freed_pkts(wl, wlvif, wlvif->sta.hlid, sta);
 		wlvif->total_freed_pkts = 0;
 	}
 
 	/* restore seq number on assoc (resume) */
-	if (is_sta &&
-	    old_state == IEEE80211_STA_AUTH &&
-	    new_state == IEEE80211_STA_ASSOC) {
+	if (is_sta && (old_state == IEEE80211_STA_AUTH) &&
+	    (new_state == IEEE80211_STA_ASSOC)) {
 		wlvif->total_freed_pkts = wl_sta->total_freed_pkts;
 	}
 
 	/* clear ROCs on failure or authorization */
-	if (is_sta &&
-	    (new_state == IEEE80211_STA_AUTHORIZED ||
-	     new_state == IEEE80211_STA_NOTEXIST)) {
+	if (is_sta && ((new_state == IEEE80211_STA_AUTHORIZED) ||
+	     (new_state == IEEE80211_STA_NOTEXIST))) {
 		if (test_bit(wlvif->role_id, wl->roc_map))
 			cc33xx_croc(wl, wlvif->role_id);
 	}
 
-	if (is_sta &&
-	    old_state == IEEE80211_STA_NOTEXIST &&
-	    new_state == IEEE80211_STA_NONE) {
+	if (is_sta && (old_state == IEEE80211_STA_NOTEXIST &&
+	    new_state == IEEE80211_STA_NONE)) {
 		if (find_first_bit(wl->roc_map,
 				   CC33XX_MAX_ROLES) >= CC33XX_MAX_ROLES) {
 			WARN_ON(wlvif->role_id == CC33XX_INVALID_ROLE_ID);
@@ -5116,6 +4975,7 @@ static int cc33xx_update_sta_state(struct cc33xx *wl,
 				   wlvif->band, wlvif->channel);
 		}
 	}
+
 	return 0;
 }
 
@@ -5161,8 +5021,8 @@ static int cc33xx_op_ampdu_action(struct ieee80211_hw *hw,
 	u16 tid = params->tid;
 	u16 *ssn = &params->ssn;
 
-	cc33xx_debug(DEBUG_MAC80211, "mac80211 ampdu action %d tid %d", action,
-		     tid);
+	cc33xx_debug(DEBUG_MAC80211, "mac80211 ampdu action %d tid %d",
+		     action, tid);
 
 	/* sanity check - the fields in FW are only 8bits wide */
 	if (WARN_ON(tid > 0xFF))
@@ -5187,6 +5047,16 @@ static int cc33xx_op_ampdu_action(struct ieee80211_hw *hw,
 		goto out;
 	}
 
+	if (hlid == CC33XX_INVALID_LINK_ID) {
+        ret = 0;
+        goto out;
+    }
+
+	if (WARN_ON(hlid >= CC33XX_MAX_LINKS)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
 	ba_bitmap = &wl->links[hlid].ba_bitmap;
 
 	cc33xx_debug(DEBUG_MAC80211, "mac80211 ampdu: Rx tid %d action %d",
@@ -5199,7 +5069,7 @@ static int cc33xx_op_ampdu_action(struct ieee80211_hw *hw,
 			break;
 		}
 
-		if (wl->ba_rx_session_count >= wl->ba_rx_session_count_max) {
+		if (wl->ba_rx_session_count >= CC33XX_RX_BA_MAX_SESSIONS) {
 			ret = -EBUSY;
 			cc33xx_error("exceeded max RX BA sessions");
 			break;
@@ -5212,9 +5082,9 @@ static int cc33xx_op_ampdu_action(struct ieee80211_hw *hw,
 			break;
 		}
 
-		ret = cc33xx_acx_set_ba_receiver_session(wl, tid, *ssn, true,
-				hlid,
-				params->buf_size);
+		ret = cc33xx_acx_set_ba_receiver_session(wl, tid, *ssn,
+							 true, hlid,
+							 params->buf_size);
 
 		if (!ret) {
 			*ba_bitmap |= BIT(tid);
@@ -5229,14 +5099,13 @@ static int cc33xx_op_ampdu_action(struct ieee80211_hw *hw,
 			 * message for now, and don't fail the function.
 			 */
 			cc33xx_debug(DEBUG_MAC80211,
-				     "no active RX BA session on tid: %d",
-				     tid);
+				     "no active RX BA session on tid: %d", tid);
 			ret = 0;
 			break;
 		}
 
-		ret = cc33xx_acx_set_ba_receiver_session(wl, tid, 0, false,
-							 hlid, 0);
+		ret = cc33xx_acx_set_ba_receiver_session(wl, tid, 0,
+							 false, hlid, 0);
 		if (!ret) {
 			*ba_bitmap &= ~BIT(tid);
 			wl->ba_rx_session_count--;
@@ -5280,19 +5149,9 @@ static int cc33xx_set_bitrate_mask(struct ieee80211_hw *hw,
 
 	mutex_lock(&wl->mutex);
 
-#ifdef WL8_ORIGINAL_CODE
-	int i;
-	for (i = 0; i < WLCORE_NUM_BANDS; i++)
-		wlvif->bitrate_masks[i] =
-			cc33xx_tx_enabled_rates_get(wl,
-						    mask->control[i].legacy,
-						    i);
-#else
-	wlvif->bitrate_masks[0] =
-		cc33xx_tx_enabled_rates_get(wl,
-					    mask->control[0].legacy,
-					    0);
-#endif
+	wlvif->bitrate_masks[0] = cc33xx_tx_enabled_rates_get(wl,
+						mask->control[0].legacy, 0);
+
 	if (unlikely(wl->state != WLCORE_STATE_ON))
 		goto out;
 
@@ -5300,8 +5159,8 @@ static int cc33xx_set_bitrate_mask(struct ieee80211_hw *hw,
 	    !test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) {
 
 		cc33xx_set_band_rate(wl, wlvif);
-		wlvif->basic_rate =
-			cc33xx_tx_min_rate_get(wl, wlvif->basic_rate_set);
+		wlvif->basic_rate = cc33xx_tx_min_rate_get(wl,
+							 wlvif->basic_rate_set);
 	}
 out:
 	mutex_unlock(&wl->mutex);
@@ -5344,7 +5203,7 @@ static void cc33xx_op_channel_switch(struct ieee80211_hw *hw,
 
 		/* indicate failure 5 seconds after channel switch time */
 		delay_usec = ieee80211_tu_to_usec(wlvif->beacon_int) *
-			ch_switch->count;
+							       ch_switch->count;
 		ieee80211_queue_delayed_work(hw, &wlvif->channel_switch_work,
 					     usecs_to_jiffies(delay_usec) +
 					     msecs_to_jiffies(5000));
@@ -5354,82 +5213,17 @@ static void cc33xx_op_channel_switch(struct ieee80211_hw *hw,
 	mutex_unlock(&wl->mutex);
 }
 
-static const void *wlcore_get_beacon_ie(struct cc33xx *wl,
-					struct cc33xx_vif *wlvif,
-					u8 eid)
-{
-	int ieoffset = offsetof(struct ieee80211_mgmt, u.beacon.variable);
-	struct sk_buff *beacon =
-		ieee80211_beacon_get(wl->hw, cc33xx_wlvif_to_vif(wlvif), 0);
-
-	if (!beacon)
-		return NULL;
-
-	return cfg80211_find_ie(eid,
-				beacon->data + ieoffset,
-				beacon->len - ieoffset);
-}
-
-static int wlcore_get_csa_count(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-				u8 *csa_count)
-{
-	const u8 *ie;
-	const struct ieee80211_channel_sw_ie *ie_csa;
-
-	ie = wlcore_get_beacon_ie(wl, wlvif, WLAN_EID_CHANNEL_SWITCH);
-	if (!ie)
-		return -EINVAL;
-
-	ie_csa = (struct ieee80211_channel_sw_ie *)&ie[2];
-	*csa_count = ie_csa->count;
-
-	return 0;
-}
-
 static void cc33xx_op_channel_switch_beacon(struct ieee80211_hw *hw,
 					    struct ieee80211_vif *vif,
 					    struct cfg80211_chan_def *chandef)
 {
-	struct cc33xx *wl = hw->priv;
-	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
-	struct ieee80211_channel_switch ch_switch = {
-		.block_tx = true,
-		.chandef = *chandef,
-	};
-	int ret;
-
-	cc33xx_debug(DEBUG_MAC80211,
-		     "mac80211 channel switch beacon (role %d)",
-		     wlvif->role_id);
-
-	ret = wlcore_get_csa_count(wl, wlvif, &ch_switch.count);
-	if (ret < 0) {
-		cc33xx_error("error getting beacon (for CSA counter)");
-		return;
-	}
-
-	mutex_lock(&wl->mutex);
-
-	if (unlikely(wl->state != WLCORE_STATE_ON)) {
-		ret = -EBUSY;
-		goto out;
-	}
-
-	ret = cmd_channel_switch(wl, wlvif, &ch_switch);
-	if (ret)
-		goto out;
-
-	set_bit(WLVIF_FLAG_CS_PROGRESS, &wlvif->flags);
-
-out:
-	mutex_unlock(&wl->mutex);
+	cc33xx_error("AP channel switch is not supported");
 }
 
 static void cc33xx_op_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-			    u32 queues, bool drop)
+		u32 queues, bool drop)
 {
 	struct cc33xx *wl = hw->priv;
-
 	cc33xx_tx_flush(wl);
 }
 
@@ -5445,8 +5239,8 @@ static int cc33xx_op_remain_on_channel(struct ieee80211_hw *hw,
 
 	channel = ieee80211_frequency_to_channel(chan->center_freq);
 
-	cc33xx_debug(DEBUG_MAC80211, "mac80211 roc %d (role %d)",
-		     channel, wlvif->role_id);
+	cc33xx_debug(DEBUG_MAC80211,
+		     "mac80211 roc %d (role %d)", channel, wlvif->role_id);
 
 	mutex_lock(&wl->mutex);
 
@@ -5461,8 +5255,9 @@ static int cc33xx_op_remain_on_channel(struct ieee80211_hw *hw,
 		goto out;
 	}
 
-	cc33xx_debug(DEBUG_MAC80211, "call cc33xx_start_dev, band = %d,"
-				     " channel = %d", chan->band, channel);
+	cc33xx_debug(DEBUG_MAC80211,
+		     "call cc33xx_start_dev, band = %d, channel = %d",
+		     chan->band, channel);
 	ret = cc33xx_start_dev(wl, wlvif, chan->band, channel);
 	if (ret < 0)
 		goto out;
@@ -5473,10 +5268,6 @@ static int cc33xx_op_remain_on_channel(struct ieee80211_hw *hw,
 
 out:
 	mutex_unlock(&wl->mutex);
-
-// Temporary workaround - ROC complete event from driver,
-// need to be sent from FW
-	//ieee80211_ready_on_channel(wl->hw);
 	return ret;
 }
 
@@ -5600,6 +5391,10 @@ static void cc33xx_op_sta_statistics(struct ieee80211_hw *hw,
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);
 	sinfo->signal = rssi_dbm;
 
+	ret = wlcore_acx_get_tx_rate(wl, wlvif, sinfo);
+	if (ret < 0)
+		goto out;
+
 out:
 	mutex_unlock(&wl->mutex);
 }
@@ -5633,18 +5428,16 @@ static bool cc33xx_tx_frames_pending(struct ieee80211_hw *hw)
 	return ret;
 }
 
-#undef CONFIG_PM // Not supported yet
 
+#ifdef CONFIG_PM
 static const struct ieee80211_ops cc33xx_ops = {
 	.start = cc33xx_op_start,
 	.stop = cc33xx_op_stop,
 	.add_interface = cc33xx_op_add_interface,
 	.remove_interface = cc33xx_op_remove_interface,
 	.change_interface = cc33xx_op_change_interface,
-#ifdef CONFIG_PM
 	.suspend = cc33xx_op_suspend,
 	.resume = cc33xx_op_resume,
-#endif
 	.config = cc33xx_op_config,
 	.prepare_multicast = cc33xx_op_prepare_multicast,
 	.configure_filter = cc33xx_op_configure_filter,
@@ -5682,6 +5475,87 @@ static const struct ieee80211_ops cc33xx_ops = {
 	CFG80211_TESTMODE_CMD(cc33xx_tm_cmd)
 };
 
+static const struct wiphy_wowlan_support wlcore_wowlan_support = {
+	.flags = WIPHY_WOWLAN_ANY,
+	.n_patterns = CC33XX_MAX_RX_FILTERS,
+	.pattern_min_len = 1,
+	.pattern_max_len = CC33XX_RX_FILTER_MAX_PATTERN_SIZE,
+};
+
+static void setup_wake_irq(struct cc33xx *wl)
+{
+	struct platform_device *pdev = wl->pdev;
+	struct wlcore_platdev_data *pdev_data = dev_get_platdata(&pdev->dev);
+
+	struct resource *res;
+	int ret;
+
+	device_init_wakeup(wl->dev, true);
+
+	if (pdev_data->pwr_in_suspend)
+		wl->hw->wiphy->wowlan = &wlcore_wowlan_support;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res) {
+		wl->wakeirq = res->start;
+		ret = dev_pm_set_dedicated_wake_irq(wl->dev, wl->wakeirq);
+		if (ret)
+			wl->wakeirq = -ENODEV;
+	} else {
+		wl->wakeirq = -ENODEV;
+	}
+
+	wl->keep_device_power = true;
+}
+#else
+static const struct ieee80211_ops cc33xx_ops = {
+	.start = cc33xx_op_start,
+	.stop = cc33xx_op_stop,
+	.add_interface = cc33xx_op_add_interface,
+	.remove_interface = cc33xx_op_remove_interface,
+	.change_interface = cc33xx_op_change_interface,
+	.config = cc33xx_op_config,
+	.prepare_multicast = cc33xx_op_prepare_multicast,
+	.configure_filter = cc33xx_op_configure_filter,
+	.tx = cc33xx_op_tx,
+	.set_key = cc33xx_op_set_key,
+	.hw_scan = cc33xx_op_hw_scan,
+	.cancel_hw_scan = cc33xx_op_cancel_hw_scan,
+	.sched_scan_start = cc33xx_op_sched_scan_start,
+	.sched_scan_stop = cc33xx_op_sched_scan_stop,
+	.bss_info_changed = cc33xx_op_bss_info_changed,
+	.set_frag_threshold = cc33xx_op_set_frag_threshold,
+	.set_rts_threshold = cc33xx_op_set_rts_threshold,
+	.conf_tx = cc33xx_op_conf_tx,
+	.get_tsf = cc33xx_op_get_tsf,
+	.get_survey = cc33xx_op_get_survey,
+	.sta_state = cc33xx_op_sta_state,
+	.ampdu_action = cc33xx_op_ampdu_action,
+	.tx_frames_pending = cc33xx_tx_frames_pending,
+	.set_bitrate_mask = cc33xx_set_bitrate_mask,
+	.set_default_unicast_key = cc33xx_op_set_default_key_idx,
+	.channel_switch = cc33xx_op_channel_switch,
+	.channel_switch_beacon = cc33xx_op_channel_switch_beacon,
+	.flush = cc33xx_op_flush,
+	.remain_on_channel = cc33xx_op_remain_on_channel,
+	.cancel_remain_on_channel = cc33xx_op_cancel_remain_on_channel,
+	.add_chanctx = cc33xx_op_add_chanctx,
+	.remove_chanctx = cc33xx_op_remove_chanctx,
+	.change_chanctx = cc33xx_op_change_chanctx,
+	.assign_vif_chanctx = cc33xx_op_assign_vif_chanctx,
+	.unassign_vif_chanctx = cc33xx_op_unassign_vif_chanctx,
+	.switch_vif_chanctx = cc33xx_op_switch_vif_chanctx,
+	.sta_rc_update = cc33xx_op_sta_rc_update,
+	.sta_statistics = cc33xx_op_sta_statistics,
+	.get_expected_throughput = cc33xx_op_get_expected_throughput,
+	CFG80211_TESTMODE_CMD(cc33xx_tm_cmd)
+};
+
+static inline void setup_wake_irq(struct cc33xx *wl)
+{
+	wl->keep_device_power = true;
+}
+#endif /* CONFIG_PM */
 
 u8 wlcore_rate_to_idx(struct cc33xx *wl, u8 rate, enum nl80211_band band)
 {
@@ -5689,12 +5563,12 @@ u8 wlcore_rate_to_idx(struct cc33xx *wl, u8 rate, enum nl80211_band band)
 
 	BUG_ON(band >= 2);
 
-	if (unlikely(rate > wl->hw_tx_rate_tbl_size)) {
+	if (unlikely(rate > CONF_HW_RATE_INDEX_MAX)) {
 		cc33xx_error("Illegal RX rate from HW: %d", rate);
 		return 0;
 	}
 
-	idx = wl->band_rate_to_idx[band][rate];
+	idx = cc33xx_band_rate_to_idx[band][rate];
 	if (unlikely(idx == CONF_HW_RXTX_RATE_UNSUPPORTED)) {
 		cc33xx_error("Unsupported RX rate from HW: %d", rate);
 		return 0;
@@ -5714,12 +5588,14 @@ static void cc33xx_derive_mac_addresses(struct cc33xx *wl)
 
 	if (wl->nvs_mac_addr_len != ETH_ALEN){
 		if (unlikely(wl->nvs_mac_addr_len > 0))
-			cc33xx_warning("NVS MAC address present but has a wrong size, ignoring.");
+			cc33xx_warning("NVS MAC address present "
+				       "but has a wrong size, ignoring.");
 
 		if (!ether_addr_equal(zero_mac, wl->efuse_mac_address)){
 			use_efuse = true;
 			ether_addr_copy(base_addr, wl->efuse_mac_address);
-			cc33xx_debug(DEBUG_BOOT, "MAC address derived from EFUSE");
+			cc33xx_debug(DEBUG_BOOT,
+				     "MAC address derived from EFUSE");
 		} else {
 			use_random = true;
 			eth_random_addr(base_addr);
@@ -5728,26 +5604,29 @@ static void cc33xx_derive_mac_addresses(struct cc33xx *wl)
 		}
 	} else {
 		u8 *nvs_addr = wl->nvs_mac_addr;
-		const u8 efuse_magic_addr[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-		const u8 random_magic_addr[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
+		const u8 efuse_magic_addr[ETH_ALEN] =
+					{0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+		const u8 random_magic_addr[ETH_ALEN] =
+					{0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
 
-		// In NVS, addresses 00-00-00-00-00-00 and 00-00-00-00-00-01
-		// have special meaning:
+		/* In NVS, addresses 00-00-00-00-00-00 and 00-00-00-00-00-01
+		   have special meaning: */
 
 		if (ether_addr_equal(nvs_addr, efuse_magic_addr)){
 			use_efuse = true;
 			ether_addr_copy(base_addr, wl->efuse_mac_address);
-			cc33xx_debug(DEBUG_BOOT, "NVS file selects address from EFUSE");
-
+			cc33xx_debug(DEBUG_BOOT,
+				     "NVS file selects address from EFUSE");
 		} else if (ether_addr_equal(nvs_addr, random_magic_addr)){
 			use_random = true;
 			eth_random_addr(base_addr);
-			cc33xx_debug(DEBUG_BOOT, "NVS file sets random MAC address");
-
+			cc33xx_debug(DEBUG_BOOT,
+				     "NVS file sets random MAC address");
 		} else {
 			use_nvs = true;
 			ether_addr_copy(base_addr, nvs_addr);
-			cc33xx_debug(DEBUG_BOOT, "NVS file sets explicit MAC address");
+			cc33xx_debug(DEBUG_BOOT,
+				     "NVS file sets explicit MAC address");
 		}
 	}
 
@@ -5766,9 +5645,7 @@ static void cc33xx_derive_mac_addresses(struct cc33xx *wl)
 		wl->addresses[2].addr[0] |= oui_laa_bit;
 
 		eth_addr_inc(wl->addresses[2].addr);
-
 		eth_addr_inc(bd_addr);
-
 	} else if (use_random) {
 		ether_addr_copy(wl->addresses[0].addr, base_addr);
 		ether_addr_copy(wl->addresses[1].addr, base_addr);
@@ -5776,19 +5653,17 @@ static void cc33xx_derive_mac_addresses(struct cc33xx *wl)
 		ether_addr_copy(bd_addr, base_addr);
 
 		eth_addr_inc(bd_addr);
-
 		eth_addr_inc(wl->addresses[1].addr);
 		eth_addr_inc(wl->addresses[1].addr);
-
 		eth_addr_inc(wl->addresses[2].addr);
 		eth_addr_inc(wl->addresses[2].addr);
 		eth_addr_inc(wl->addresses[2].addr);
-
 	} else {
 		BUG_ON(1);
 	}
 
-	cc33xx_debug(DEBUG_BOOT, "Base MAC address: %pM", wl->addresses[0].addr);
+	cc33xx_debug(DEBUG_BOOT, "Base MAC address: %pM",
+		     wl->addresses[0].addr);
 
 	wl->hw->wiphy->n_addresses = WLCORE_NUM_MAC_ADDRESSES;
 	wl->hw->wiphy->addresses = wl->addresses;
@@ -5796,7 +5671,6 @@ static void cc33xx_derive_mac_addresses(struct cc33xx *wl)
 	cmd_set_bd_addr(wl, bd_addr);
 }
 
-
 static int cc33xx_register_hw(struct cc33xx *wl)
 {
 	int ret;
@@ -5827,7 +5701,6 @@ static void cc33xx_unregister_hw(struct cc33xx *wl)
 
 	ieee80211_unregister_hw(wl->hw);
 	wl->mac80211_registered = false;
-
 }
 
 static int cc33xx_init_ieee80211(struct cc33xx *wl)
@@ -5868,7 +5741,8 @@ static int cc33xx_init_ieee80211(struct cc33xx *wl)
 
 	/* unit us */
 	/* FIXME: find a proper value */
-	wl->hw->max_listen_interval = wl->conf.host_conf.conn.max_listen_interval;
+	wl->hw->max_listen_interval =
+				wl->conf.host_conf.conn.max_listen_interval;
 
 	ieee80211_hw_set(wl->hw, SUPPORT_FAST_XMIT);
 	ieee80211_hw_set(wl->hw, CHANCTX_STA_CSA);
@@ -5887,17 +5761,7 @@ static int cc33xx_init_ieee80211(struct cc33xx *wl)
 	ieee80211_hw_set(wl->hw, SUPPORTS_MULTI_BSSID);
 	ieee80211_hw_set(wl->hw, SUPPORTS_AMSDU_IN_AMPDU);
 
-	// wl->hw->wiphy->cipher_suites = cipher_suites;
-	// wl->hw->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
-
-	wl->hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
-					 BIT(NL80211_IFTYPE_AP) |
-					 BIT(NL80211_IFTYPE_P2P_DEVICE) |
-					 BIT(NL80211_IFTYPE_P2P_CLIENT) |
-#ifdef CONFIG_MAC80211_MESH
-					 BIT(NL80211_IFTYPE_MESH_POINT) |
-#endif
-					 BIT(NL80211_IFTYPE_P2P_GO);
+	wl->hw->wiphy->interface_modes = cc33xx_wiphy_interface_modes();
 
 	wl->hw->wiphy->max_scan_ssids = 1;
 	wl->hw->wiphy->max_sched_scan_ssids = 16;
@@ -5919,9 +5783,9 @@ static int cc33xx_init_ieee80211(struct cc33xx *wl)
 	wl->hw->wiphy->features |= NL80211_FEATURE_AP_SCAN;
 
 	/*
-	* clear channel flags from the previous usage
-	* and restore max_power & max_antenna_gain values.
-	*/
+	 * clear channel flags from the previous usage
+	 * and restore max_power & max_antenna_gain values.
+	 */
 	for (i = 0; i < ARRAY_SIZE(cc33xx_channels); i++) {
 		cc33xx_band_2ghz.channels[i].flags = 0;
 		cc33xx_band_2ghz.channels[i].max_power = CC33XX_MAX_TXPWR;
@@ -5943,7 +5807,12 @@ static int cc33xx_init_ieee80211(struct cc33xx *wl)
 		cc33xx_band_5ghz.iftype_data = NULL;
 		cc33xx_band_5ghz.n_iftype_data = 0;
 	}
-
+	else
+	{
+		wl->hw->wiphy->iftype_ext_capab = he_iftypes_ext_capa;
+		wl->hw->wiphy->num_iftype_ext_capab =
+			ARRAY_SIZE(he_iftypes_ext_capa);
+	}
 
 	/*
 	 * We keep local copies of the band structs because we need to
@@ -5981,8 +5850,8 @@ static int cc33xx_init_ieee80211(struct cc33xx *wl)
 	wl->hw->wiphy->reg_notifier = cc33xx_reg_notify;
 
 	/* allowed interface combinations */
-	wl->hw->wiphy->iface_combinations = wl->iface_combinations;
-	wl->hw->wiphy->n_iface_combinations = wl->n_iface_combinations;
+	wl->hw->wiphy->iface_combinations = cc33xx_iface_combinations;
+	wl->hw->wiphy->n_iface_combinations = ARRAY_SIZE(cc33xx_iface_combinations);
 
 	SET_IEEE80211_DEV(wl->hw, wl->dev);
 
@@ -6004,11 +5873,10 @@ static int cc33xx_init_ieee80211(struct cc33xx *wl)
 		wl->hw->uapsd_queues = 0;
 	}
 
-
 	return 0;
 }
 
-#define create_high_prio_freezable_workqueue(name)				\
+#define create_high_prio_freezable_workqueue(name)			\
 	alloc_workqueue("%s", __WQ_LEGACY | WQ_FREEZABLE | WQ_UNBOUND |	\
 			WQ_MEM_RECLAIM | WQ_HIGHPRI, 1, (name))
 
@@ -6037,9 +5905,11 @@ struct ieee80211_hw *wlcore_alloc_hw(u32 aggr_buf_size)
 	 * wl->num_links is not configured yet, so just use CC33XX_MAX_LINKS.
 	 * we don't allocate any additional resource here, so that's fine.
 	 */
-	for (i = 0; i < NUM_TX_QUEUES; i++)
-		for (j = 0; j < CC33XX_MAX_LINKS; j++)
+	for (i = 0; i < NUM_TX_QUEUES; i++)	{
+		for (j = 0; j < CC33XX_MAX_LINKS; j++) {
 			skb_queue_head_init(&wl->links[j].tx_queue[i]);
+		}
+	}
 
 	skb_queue_head_init(&wl->deferred_rx_queue);
 	skb_queue_head_init(&wl->deferred_tx_queue);
@@ -6054,9 +5924,10 @@ struct ieee80211_hw *wlcore_alloc_hw(u32 aggr_buf_size)
 	INIT_DELAYED_WORK(&wl->roc_complete_work, wlcore_roc_complete_work);
 	INIT_DELAYED_WORK(&wl->tx_watchdog_work, cc33xx_tx_watchdog_work);
 
-	wl->freezable_netstack_wq  = create_freezable_workqueue("cc33xx_netstack_wq");
+	wl->freezable_netstack_wq =
+			create_freezable_workqueue("cc33xx_netstack_wq");
 
-	wl->freezable_wq =  create_high_prio_freezable_workqueue("cc33xx_wq");
+	wl->freezable_wq = create_high_prio_freezable_workqueue("cc33xx_wq");
 
 	if (!wl->freezable_wq || !wl->freezable_netstack_wq) {
 		ret = -ENOMEM;
@@ -6080,7 +5951,7 @@ struct ieee80211_hw *wlcore_alloc_hw(u32 aggr_buf_size)
 	__set_bit(CC33XX_SYSTEM_HLID, wl->links_map);
 
 	memset(wl->tx_frames_map, 0, sizeof(wl->tx_frames_map));
-	for (i = 0; i < wl->num_tx_desc; i++)
+	for (i = 0; i < CC33XX_NUM_TX_DESCRIPTORS; i++)
 		wl->tx_frames[i] = NULL;
 
 	spin_lock_init(&wl->wl_lock);
@@ -6121,8 +5992,6 @@ struct ieee80211_hw *wlcore_alloc_hw(u32 aggr_buf_size)
 	if (!wl->core_status)
 		goto err_buf32;
 
-
-
 	return hw;
 
 err_buf32:
@@ -6145,7 +6014,6 @@ struct ieee80211_hw *wlcore_alloc_hw(u32 aggr_buf_size)
 	cc33xx_debugfs_exit(wl);
 
 err_hw_alloc:
-
 	return ERR_PTR(ret);
 }
 
@@ -6178,17 +6046,6 @@ int wlcore_free_hw(struct cc33xx *wl)
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static const struct wiphy_wowlan_support wlcore_wowlan_support = {
-	.flags = WIPHY_WOWLAN_ANY,
-	.n_patterns = CC33XX_MAX_RX_FILTERS,
-	.pattern_min_len = 1,
-	.pattern_max_len = CC33XX_RX_FILTER_MAX_PATTERN_SIZE,
-};
-#endif
-
-
-
 static int cc33xx_identify_chip(struct cc33xx *wl)
 {
 	int ret = 0;
@@ -6200,14 +6057,6 @@ static int cc33xx_identify_chip(struct cc33xx *wl)
 		      WLCORE_QUIRK_REGDOMAIN_CONF |
 		      WLCORE_QUIRK_DUAL_PROBE_TMPL;
 
-
-	wl->scan_templ_id_2_4 = CMD_TEMPL_CFG_PROBE_REQ_2_4;
-	wl->scan_templ_id_5 = CMD_TEMPL_CFG_PROBE_REQ_5;
-	wl->sched_scan_templ_id_2_4 = CMD_TEMPL_PROBE_REQ_2_4_PERIODIC;
-	wl->sched_scan_templ_id_5 = CMD_TEMPL_PROBE_REQ_5_PERIODIC;
-	wl->max_channels_5 = MAX_CHANNELS_5GHZ;
-	wl->ba_rx_session_count_max = CC33XX_RX_BA_MAX_SESSIONS;
-
 	if (wl->if_ops->get_max_transaction_len)
 		wl->max_transaction_len =
 			wl->if_ops->get_max_transaction_len(wl->dev);
@@ -6234,18 +6083,18 @@ static int read_version_info(struct cc33xx *wl)
 	}
 
 	cc33xx_info("Wireless firmware version %u.%u.%u.%u",
-		wl->all_versions.fw_ver->major_version,
-		wl->all_versions.fw_ver->minor_version,
-		wl->all_versions.fw_ver->api_version,
-		wl->all_versions.fw_ver->build_version);
+		    wl->all_versions.fw_ver->major_version,
+		    wl->all_versions.fw_ver->minor_version,
+		    wl->all_versions.fw_ver->api_version,
+		    wl->all_versions.fw_ver->build_version);
 
 	cc33xx_info("Wireless PHY version %u.%u.%u.%u.%u.%u",
-		wl->all_versions.fw_ver->phy_version[5],
-		wl->all_versions.fw_ver->phy_version[4],
-		wl->all_versions.fw_ver->phy_version[3],
-		wl->all_versions.fw_ver->phy_version[2],
-		wl->all_versions.fw_ver->phy_version[1],
-		wl->all_versions.fw_ver->phy_version[0]);
+		    wl->all_versions.fw_ver->phy_version[5],
+		    wl->all_versions.fw_ver->phy_version[4],
+		    wl->all_versions.fw_ver->phy_version[3],
+		    wl->all_versions.fw_ver->phy_version[2],
+		    wl->all_versions.fw_ver->phy_version[1],
+		    wl->all_versions.fw_ver->phy_version[0]);
 
 	wl->all_versions.driver_ver.major_version = MAJOR_VERSION;
 	wl->all_versions.driver_ver.minor_version = MINOR_VERSION;
@@ -6260,9 +6109,6 @@ static void wlcore_nvs_cb(const struct firmware *fw, void *context)
 	struct cc33xx *wl = context;
 	struct platform_device *pdev = wl->pdev;
 	struct wlcore_platdev_data *pdev_data = dev_get_platdata(&pdev->dev);
-#ifdef CONFIG_PM
-	struct resource *res;
-#endif
 
 	int ret;
 
@@ -6287,7 +6133,7 @@ static void wlcore_nvs_cb(const struct firmware *fw, void *context)
 	if (ret < 0)
 		goto out_free_nvs;
 
-	BUG_ON(wl->num_tx_desc > WLCORE_MAX_TX_DESCRIPTORS);
+	BUG_ON(CC33XX_NUM_TX_DESCRIPTORS > WLCORE_MAX_TX_DESCRIPTORS);
 
 	/* adjust some runtime configuration parameters */
 	wlcore_adjust_conf(wl);
@@ -6297,25 +6143,7 @@ static void wlcore_nvs_cb(const struct firmware *fw, void *context)
 
 	cc33xx_power_off(wl);
 
-#ifdef CONFIG_PM
-	device_init_wakeup(wl->dev, true);
-
-	if (pdev_data->pwr_in_suspend)
-		wl->hw->wiphy->wowlan = &wlcore_wowlan_support;
-
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (res) {
-		wl->wakeirq = res->start;
-		ret = dev_pm_set_dedicated_wake_irq(wl->dev, wl->wakeirq);
-		if (ret)
-			wl->wakeirq = -ENODEV;
-	} else {
-		wl->wakeirq = -ENODEV;
-	}
-#else
-	wl->keep_device_power = true;
-#endif
-
+	setup_wake_irq(wl);
 
 	ret = cc33xx_init_fw(wl);
 	if (ret < 0) {
@@ -6373,7 +6201,6 @@ int wlcore_probe(struct cc33xx *wl, struct platform_device *pdev)
 	cc33xx_debug(DEBUG_CC33xx, "Wireless Driver Version %d.%d.%d.%d",
 		MAJOR_VERSION, MINOR_VERSION, API_VERSION, BUILD_VERSION);
 
-
 	if (!pdev_data)
 		return -EINVAL;
 
@@ -6387,8 +6214,9 @@ int wlcore_probe(struct cc33xx *wl, struct platform_device *pdev)
 					      nvs_name, &pdev->dev, GFP_KERNEL,
 					      wl, wlcore_nvs_cb);
 		if (ret < 0) {
-			cc33xx_error("request_firmware_nowait failed for %s: %d",
-				     nvs_name, ret);
+			cc33xx_error(
+				    "request_firmware_nowait failed for %s: %d",
+				    nvs_name, ret);
 			complete_all(&wl->nvs_loading_complete);
 		}
 	} else {
@@ -6419,27 +6247,17 @@ int wlcore_remove(struct platform_device *pdev)
 	}
 
 	device_init_wakeup(wl->dev, false);
-
 	cc33xx_unregister_hw(wl);
 	cc33xx_turn_off(wl);
 
 out:
 	wlcore_free_hw(wl);
-
 	return 0;
 }
 
-bool cc33xx_is_mimo_supported(struct cc33xx *wl)
-{
-	/* only support MIMO with multiple antennas, and when SISO
-	 * is not forced through config
-	 */
-	return (wl->conf.host_conf.ht.mode != HT_MODE_WIDE) &&
-	       (wl->conf.host_conf.ht.mode != HT_MODE_SISO20);
-}
-
-static int cc33xx_load_ini_bin_file(struct device *dev, struct cc33xx_conf_file *conf,
-				 const char *file)
+static int cc33xx_load_ini_bin_file(struct device *dev,
+				    struct cc33xx_conf_file *conf,
+				    const char *file)
 {
 	struct cc33xx_conf_file *conf_file;
 	const struct firmware *fw;
@@ -6453,8 +6271,9 @@ static int cc33xx_load_ini_bin_file(struct device *dev, struct cc33xx_conf_file
 	}
 
 	if (fw->size != CC33X_CONF_SIZE) {
-		cc33xx_error("%s configuration binary size is wrong, expected %zu got %zu",
-			     file, CC33X_CONF_SIZE, fw->size);
+		cc33xx_error("%s configuration binary size is wrong, "
+			     "expected %zu got %zu", file, CC33X_CONF_SIZE,
+			     fw->size);
 		ret = -EINVAL;
 		goto out_release;
 	}
@@ -6481,15 +6300,18 @@ static int cc33xx_ini_bin_init(struct cc33xx *wl, struct device *dev)
 	struct platform_device *pdev = wl->pdev;
 	struct wlcore_platdev_data *pdata = dev_get_platdata(&pdev->dev);
 
-	if (cc33xx_load_ini_bin_file(dev, &wl->conf, pdata->family->cfg_name) < 0){
+	if (cc33xx_load_ini_bin_file(dev, &wl->conf,
+				     pdata->family->cfg_name) < 0)
 		cc33xx_warning("falling back to default config");
 
-
-	}
-
 	return 0;
 }
 
+static inline void wlcore_set_ht_cap(struct cc33xx *wl, enum nl80211_band band,
+				     struct ieee80211_sta_ht_cap *ht_cap)
+{
+	memcpy(&wl->ht_cap[band], ht_cap, sizeof(*ht_cap));
+}
 
 static int cc33xx_setup(struct cc33xx *wl)
 {
@@ -6497,48 +6319,26 @@ static int cc33xx_setup(struct cc33xx *wl)
 
 	BUILD_BUG_ON(CC33XX_MAX_AP_STATIONS > CC33XX_MAX_LINKS);
 
-	wl->num_tx_desc = CC33XX_NUM_TX_DESCRIPTORS;
-	wl->num_rx_desc = CC33XX_NUM_RX_DESCRIPTORS;
-	wl->num_links = CC33XX_MAX_LINKS;
-	wl->max_ap_stations = CC33XX_MAX_AP_STATIONS;
-	wl->iface_combinations = cc33xx_iface_combinations;
-	wl->n_iface_combinations = ARRAY_SIZE(cc33xx_iface_combinations);
-	wl->band_rate_to_idx = cc33xx_band_rate_to_idx;
-	wl->hw_tx_rate_tbl_size = CONF_HW_RATE_INDEX_MAX;
-	wl->stats.fw_stats_len = sizeof(struct cc33xx_acx_statistics);
-
-	if (num_rx_desc_param != -1)
-		wl->num_rx_desc = num_rx_desc_param;
-
 	ret = cc33xx_ini_bin_init(wl, wl->dev);
 	if (ret < 0)
 		return ret;
 
-
 	if (ht_mode_param) {
-		if (!strcmp(ht_mode_param, "default"))
+		if (!strcmp(ht_mode_param, "default")) {
 			wl->conf.host_conf.ht.mode = HT_MODE_DEFAULT;
-		else if (!strcmp(ht_mode_param, "wide"))
+		} else if (!strcmp(ht_mode_param, "wide")) {
 			wl->conf.host_conf.ht.mode = HT_MODE_WIDE;
-		else if (!strcmp(ht_mode_param, "siso20"))
+		} else if (!strcmp(ht_mode_param, "siso20")) {
 			wl->conf.host_conf.ht.mode = HT_MODE_SISO20;
-		else {
+		} else {
 			cc33xx_error("invalid ht_mode '%s'", ht_mode_param);
 			return -EINVAL;
 		}
 	}
 
 	if (wl->conf.host_conf.ht.mode == HT_MODE_DEFAULT) {
-		/*
-		 * Only support mimo with multiple antennas. Fall back to
-		 * siso40.
-		 */
-		if (cc33xx_is_mimo_supported(wl))
-			wlcore_set_ht_cap(wl, NL80211_BAND_2GHZ,
-					  &cc33xx_mimo_ht_cap_2ghz);
-		else
-			wlcore_set_ht_cap(wl, NL80211_BAND_2GHZ,
-					  &cc33xx_siso40_ht_cap_2ghz);
+		wlcore_set_ht_cap(wl, NL80211_BAND_2GHZ,
+				  &cc33xx_siso40_ht_cap_2ghz);
 
 		/* 5Ghz is always wide */
 		wlcore_set_ht_cap(wl, NL80211_BAND_5GHZ,
@@ -6549,30 +6349,22 @@ static int cc33xx_setup(struct cc33xx *wl)
 		wlcore_set_ht_cap(wl, NL80211_BAND_5GHZ,
 				  &cc33xx_siso40_ht_cap_5ghz);
 	} else if (wl->conf.host_conf.ht.mode == HT_MODE_SISO20) {
-		wlcore_set_ht_cap(wl, NL80211_BAND_2GHZ,
-				  &cc33xx_siso20_ht_cap);
-		wlcore_set_ht_cap(wl, NL80211_BAND_5GHZ,
-				  &cc33xx_siso20_ht_cap);
-	}
-
-	wl->event_mask = BSS_LOSS_EVENT_ID |
-		SCAN_COMPLETE_EVENT_ID |
-		RADAR_DETECTED_EVENT_ID |
-		RSSI_SNR_TRIGGER_0_EVENT_ID |
-		PERIODIC_SCAN_COMPLETE_EVENT_ID |
-		PERIODIC_SCAN_REPORT_EVENT_ID |
-		DUMMY_PACKET_EVENT_ID |
-		PEER_REMOVE_COMPLETE_EVENT_ID |
-		BA_SESSION_RX_CONSTRAINT_EVENT_ID |
-		REMAIN_ON_CHANNEL_COMPLETE_EVENT_ID |
-		INACTIVE_STA_EVENT_ID |
-		CHANNEL_SWITCH_COMPLETE_EVENT_ID |
-		DFS_CHANNELS_CONFIG_COMPLETE_EVENT |
-		SMART_CONFIG_SYNC_EVENT_ID |
-		SMART_CONFIG_DECODE_EVENT_ID |
-		TIME_SYNC_EVENT_ID |
-		FW_LOGGER_INDICATION |
-		RX_BA_WIN_SIZE_CHANGE_EVENT_ID;
+		wlcore_set_ht_cap(wl, NL80211_BAND_2GHZ, &cc33xx_siso20_ht_cap);
+		wlcore_set_ht_cap(wl, NL80211_BAND_5GHZ, &cc33xx_siso20_ht_cap);
+	}
+
+	wl->event_mask = BSS_LOSS_EVENT_ID | SCAN_COMPLETE_EVENT_ID |
+			 RADAR_DETECTED_EVENT_ID | RSSI_SNR_TRIGGER_0_EVENT_ID |
+			 PERIODIC_SCAN_COMPLETE_EVENT_ID |
+			 PERIODIC_SCAN_REPORT_EVENT_ID | DUMMY_PACKET_EVENT_ID |
+			 PEER_REMOVE_COMPLETE_EVENT_ID |
+			 BA_SESSION_RX_CONSTRAINT_EVENT_ID |
+			 REMAIN_ON_CHANNEL_COMPLETE_EVENT_ID |
+			 CHANNEL_SWITCH_COMPLETE_EVENT_ID |
+			 DFS_CHANNELS_CONFIG_COMPLETE_EVENT |
+			 SMART_CONFIG_SYNC_EVENT_ID | INACTIVE_STA_EVENT_ID |
+			 SMART_CONFIG_DECODE_EVENT_ID | TIME_SYNC_EVENT_ID |
+			 FW_LOGGER_INDICATION | RX_BA_WIN_SIZE_CHANGE_EVENT_ID;
 
 	wl->ap_event_mask = MAX_TX_FAILURE_EVENT_ID;
 
@@ -6635,24 +6427,12 @@ MODULE_PARM_DESC(secure_boot_enable, "Enables secure boot and FW downlaod");
 module_param_named(fwlog, fwlog_param, charp, 0);
 MODULE_PARM_DESC(fwlog, "FW logger options: continuous, dbgpins or disable");
 
-module_param(fwlog_mem_blocks, int, 0600);
-MODULE_PARM_DESC(fwlog_mem_blocks, "fwlog mem_blocks");
-
 module_param(no_recovery, int, 0600);
 MODULE_PARM_DESC(no_recovery, "Prevent HW recovery. FW will remain stuck.");
 
 module_param_named(ht_mode, ht_mode_param, charp, 0400);
 MODULE_PARM_DESC(ht_mode, "Force HT mode: wide or siso20");
 
-module_param_named(pwr_limit_reference_11_abg,
-		   pwr_limit_reference_11_abg_param, int, 0400);
-MODULE_PARM_DESC(pwr_limit_reference_11_abg, "Power limit reference: u8 "
-		 "(default is 0xc8)");
-
-module_param_named(num_rx_desc, num_rx_desc_param, int, 0400);
-MODULE_PARM_DESC(num_rx_desc_param,
-		 "Number of Rx descriptors: u8 (default is 32)");
-
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Luciano Coelho <coelho@ti.com>");
 MODULE_AUTHOR("Juuso Oikarinen <juuso.oikarinen@nokia.com>");
diff --git a/drivers/net/wireless/ti/cc33xx/ps.c b/drivers/net/wireless/ti/cc33xx/ps.c
index f61ee6817117..5d66cd956280 100644
--- a/drivers/net/wireless/ti/cc33xx/ps.c
+++ b/drivers/net/wireless/ti/cc33xx/ps.c
@@ -8,12 +8,12 @@
  */
 
 #include "ps.h"
-#include "io.h"
 #include "tx.h"
 #include "debug.h"
 
+
 int cc33xx_ps_set_mode(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-		       enum cc33xx_cmd_ps_mode mode)
+		       enum cc33xx_cmd_ps_mode_e mode)
 {
 	int ret;
 	u16 timeout = wl->conf.host_conf.conn.dynamic_ps_timeout;
@@ -41,6 +41,7 @@ int cc33xx_ps_set_mode(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				return ret;
 		}
 		break;
+
 	case STATION_ACTIVE_MODE:
 		cc33xx_debug(DEBUG_PSM, "leaving psm");
 
@@ -58,6 +59,7 @@ int cc33xx_ps_set_mode(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 
 		clear_bit(WLVIF_FLAG_IN_PS, &wlvif->flags);
 		break;
+
 	default:
 		cc33xx_warning("trying to set ps to unsupported mode %d", mode);
 		ret = -EINVAL;
@@ -97,8 +99,8 @@ static void cc33xx_ps_filter_frames(struct cc33xx *wl, u8 hlid)
 		if (lnk->wlvif)
 			lnk->wlvif->tx_queue_count[i] -= filtered[i];
 	}
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
 
+	spin_unlock_irqrestore(&wl->wl_lock, flags);
 	cc33xx_handle_tx_low_watermark(wl);
 }
 
@@ -115,9 +117,9 @@ void cc33xx_ps_link_start(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	    test_bit(hlid, &wl->ap_ps_map))
 		return;
 
-	cc33xx_debug(DEBUG_PSM, "start mac80211 PSM on hlid %d pkts %d "
-		     "clean_queues %d", hlid, wl->links[hlid].allocated_pkts,
-		     clean_queues);
+	cc33xx_debug(DEBUG_PSM,
+		     "start mac80211 PSM on hlid %d pkts %d clean_queues %d",
+		     hlid, wl->links[hlid].allocated_pkts, clean_queues);
 
 	rcu_read_lock();
 	sta = ieee80211_find_sta(vif, wl->links[hlid].addr);
@@ -137,28 +139,3 @@ void cc33xx_ps_link_start(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 
 	__set_bit(hlid, &wl->ap_ps_map);
 }
-
-void cc33xx_ps_link_end(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 hlid)
-{
-	struct ieee80211_sta *sta;
-	struct ieee80211_vif *vif = cc33xx_wlvif_to_vif(wlvif);
-
-	if (!test_bit(hlid, &wl->ap_ps_map))
-		return;
-
-	cc33xx_debug(DEBUG_PSM, "end mac80211 PSM on hlid %d", hlid);
-
-	__clear_bit(hlid, &wl->ap_ps_map);
-
-	rcu_read_lock();
-	sta = ieee80211_find_sta(vif, wl->links[hlid].addr);
-	if (!sta) {
-		cc33xx_error("could not find sta %pM for ending ps",
-			     wl->links[hlid].addr);
-		goto end;
-	}
-
-	ieee80211_sta_ps_transition_ni(sta, false);
-end:
-	rcu_read_unlock();
-}
diff --git a/drivers/net/wireless/ti/cc33xx/ps.h b/drivers/net/wireless/ti/cc33xx/ps.h
index 85651e562bd5..bacd7ad84472 100644
--- a/drivers/net/wireless/ti/cc33xx/ps.h
+++ b/drivers/net/wireless/ti/cc33xx/ps.h
@@ -10,13 +10,13 @@
 #ifndef __PS_H__
 #define __PS_H__
 
-#include "wlcore.h"
 #include "acx.h"
 
+
 int cc33xx_ps_set_mode(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-		       enum cc33xx_cmd_ps_mode mode);
+		       enum cc33xx_cmd_ps_mode_e mode);
 void cc33xx_ps_link_start(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			  u8 hlid, bool clean_queues);
-void cc33xx_ps_link_end(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 hlid);
 
-#endif /* __WL1271_PS_H__ */
+
+#endif /* __PS_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/rx.c b/drivers/net/wireless/ti/cc33xx/rx.c
index 4a55216b6d70..0a042d4c51d6 100644
--- a/drivers/net/wireless/ti/cc33xx/rx.c
+++ b/drivers/net/wireless/ti/cc33xx/rx.c
@@ -7,18 +7,15 @@
  * Contact: Luciano Coelho <luciano.coelho@nokia.com>
  */
 
-#include <linux/gfp.h>
-#include <linux/sched.h>
-
-#include "wlcore.h"
-#include "debug.h"
 #include "acx.h"
 #include "rx.h"
 #include "tx.h"
 #include "io.h"
 
 
-
+#define RSSI_LEVEL_BITMASK	0x7F
+#define ANT_DIVERSITY_BITMASK	BIT(7)
+#define ANT_DIVERSITY_SHIFT		7
 
 
 /* Construct the rx status structure for upper layers */
@@ -38,10 +35,8 @@ static void cc33xx_rx_status(struct cc33xx *wl,
 	else
 		status->band = NL80211_BAND_5GHZ; /* todo -Should be 6GHZ when added */
 
-
 	status->rate_idx = wlcore_rate_to_idx(wl, desc->rate, status->band);
 
-
 	if (desc->frame_format == CC33xx_VHT)
 		status->encoding = RX_ENC_VHT;
 	else if ((desc->frame_format == CC33xx_HT_MF) ||
@@ -61,7 +56,7 @@ static void cc33xx_rx_status(struct cc33xx *wl,
 	* The antenna indication is the msb of the rssi.
 	*/
 	status->signal = ((desc->rssi & RSSI_LEVEL_BITMASK) | BIT(7));
-	status->antenna = ((desc->rssi & ANT_DIVERSITY_BITMASK) >> 7);
+	status->antenna = ((desc->rssi & ANT_DIVERSITY_BITMASK) >> ANT_DIVERSITY_SHIFT);
 
 	/*
 	 * FIXME: In wl1251, the SNR should be divided by two.  In cc33xx we
@@ -80,8 +75,7 @@ static void cc33xx_rx_status(struct cc33xx *wl,
 		/* Frame is sent to driver with the IV (for PN replay check)
 		 * but without the MIC */
 		status->flag |=  RX_FLAG_MMIC_STRIPPED |
-				 RX_FLAG_DECRYPTED |
-				 RX_FLAG_MIC_STRIPPED;
+				 RX_FLAG_DECRYPTED | RX_FLAG_MIC_STRIPPED;
 
 
 		if (unlikely(desc_err_code & CC33XX_RX_DESC_MIC_FAIL)) {
@@ -93,16 +87,16 @@ static void cc33xx_rx_status(struct cc33xx *wl,
 
 	if (beacon || probe_rsp)
 		status->boottime_ns = ktime_get_boottime_ns();
+
 	if (beacon)
 		wlcore_set_pending_regdomain_ch(wl, (u16)desc->channel,
 						status->band);
 	status->nss = 1;
 }
 
-
 /* Copy part\ all of the descriptor. Allocate skb, or drop corrupted packet */
-int wlcore_rx_getPacketDescriptor(struct cc33xx *wl, u8 *raw_buffer_ptr,
-				  u16 *raw_buffer_len)
+static int wlcore_rx_getPacketDescriptor(struct cc33xx *wl, u8 *raw_buffer_ptr,
+					 u16 *raw_buffer_len)
 {
 	u16 missing_desc_bytes;
 	u16 available_desc_bytes;
@@ -110,8 +104,8 @@ int wlcore_rx_getPacketDescriptor(struct cc33xx *wl, u8 *raw_buffer_ptr,
 	struct sk_buff *skb;
 	u16 prev_buffer_len = *raw_buffer_len;
 
-	missing_desc_bytes = sizeof(struct cc33xx_rx_descriptor) -
-				wl->partial_rx.handled_bytes;
+	missing_desc_bytes = sizeof(struct cc33xx_rx_descriptor);
+	missing_desc_bytes -= wl->partial_rx.handled_bytes;
 	available_desc_bytes = min(*raw_buffer_len, missing_desc_bytes);
 	memcpy(((u8 *)(&wl->partial_rx.desc))+wl->partial_rx.handled_bytes,
 		raw_buffer_ptr,available_desc_bytes);
@@ -128,11 +122,10 @@ int wlcore_rx_getPacketDescriptor(struct cc33xx *wl, u8 *raw_buffer_ptr,
 	}
 
 	/* Descriptor was fully copied */
-	pkt_data_len = wl->partial_rx.original_bytes -
-			sizeof(struct cc33xx_rx_descriptor);
-
+	pkt_data_len = wl->partial_rx.original_bytes;
+	pkt_data_len -=	sizeof(struct cc33xx_rx_descriptor);
 
-	if (unlikely(wl->partial_rx.desc.status & CC33XX_RX_DESC_DECRYPT_FAIL)) {
+	if (unlikely(wl->partial_rx.desc.status & CC33XX_RX_DESC_DECRYPT_FAIL)){
 		cc33xx_warning("corrupted packet in RX: status: 0x%x len: %d",
 			wl->partial_rx.desc.status & CC33XX_RX_DESC_STATUS_MASK,
 			pkt_data_len);
@@ -150,8 +143,7 @@ int wlcore_rx_getPacketDescriptor(struct cc33xx *wl, u8 *raw_buffer_ptr,
 		goto out;
 	}
 
-
-	skb = __dev_alloc_skb(pkt_data_len , GFP_KERNEL);
+	skb = __dev_alloc_skb(pkt_data_len, GFP_KERNEL);
 	if (!skb) {
 		cc33xx_error("Couldn't allocate RX frame");
 		/* If frame can be fully dropped */
@@ -170,14 +162,14 @@ int wlcore_rx_getPacketDescriptor(struct cc33xx *wl, u8 *raw_buffer_ptr,
 	wl->partial_rx.skb = skb;
 	wl->partial_rx.status = CURR_RX_DATA;
 
-	out:
+out:
 	/* Function return the amount of consumed bytes */
 	return (prev_buffer_len - *raw_buffer_len);
 }
 
 /* Copy part or all of the packet's data. push skb to queue if possible */
-int wlcore_rx_getPacketData(struct cc33xx *wl, u8 *raw_buffer_ptr,
-			    u16 *raw_buffer_len)
+static int wlcore_rx_getPacketData(struct cc33xx *wl, u8 *raw_buffer_ptr,
+				   u16 *raw_buffer_len)
 {
 	u16 missing_data_bytes;
 	u16 available_data_bytes;
@@ -192,12 +184,13 @@ int wlcore_rx_getPacketData(struct cc33xx *wl, u8 *raw_buffer_ptr,
 	u16 prev_buffer_len = *raw_buffer_len;
 
 	cc33xx_debug(DEBUG_RX, "current rx data: original bytes: %d, "
-		"handled bytes %d, desc pad len %d, missing_data_bytes %d",
-		wl->partial_rx.original_bytes, wl->partial_rx.handled_bytes,
-		wl->partial_rx.desc.pad_len,missing_data_bytes);
+		     "handled bytes %d, desc pad len %d, missing_data_bytes %d",
+		     wl->partial_rx.original_bytes,
+		     wl->partial_rx.handled_bytes,
+		     wl->partial_rx.desc.pad_len,missing_data_bytes);
 
-	missing_data_bytes = wl->partial_rx.original_bytes -
-				wl->partial_rx.handled_bytes;
+	missing_data_bytes = wl->partial_rx.original_bytes;
+	missing_data_bytes -= wl->partial_rx.handled_bytes;
 	available_data_bytes = min(missing_data_bytes,*raw_buffer_len);
 
 	skb_put_data(wl->partial_rx.skb, raw_buffer_ptr, available_data_bytes);
@@ -205,13 +198,12 @@ int wlcore_rx_getPacketData(struct cc33xx *wl, u8 *raw_buffer_ptr,
 	/* Check if we didn't manage to copy the entire packet - got out,
 	* continue next time */
 	if (available_data_bytes != missing_data_bytes) {
-	wl->partial_rx.handled_bytes += *raw_buffer_len;
-	wl->partial_rx.status = CURR_RX_DATA;
-	*raw_buffer_len = 0;
-	goto out;
-	}
-	else {
-	*raw_buffer_len -=  available_data_bytes;
+		wl->partial_rx.handled_bytes += *raw_buffer_len;
+		wl->partial_rx.status = CURR_RX_DATA;
+		*raw_buffer_len = 0;
+		goto out;
+	} else {
+		*raw_buffer_len -=  available_data_bytes;
 	}
 
 	/* Data fully copied */
@@ -220,10 +212,10 @@ int wlcore_rx_getPacketData(struct cc33xx *wl, u8 *raw_buffer_ptr,
 	if (rx_align == WLCORE_RX_BUF_PADDED)
 		skb_pull(wl->partial_rx.skb, RX_BUF_ALIGN);
 
-
 	extra_bytes = wl->partial_rx.desc.pad_len;
 	if (extra_bytes != 0)
-		skb_trim(wl->partial_rx.skb, wl->partial_rx.skb->len - extra_bytes);
+		skb_trim(wl->partial_rx.skb,
+			 wl->partial_rx.skb->len - extra_bytes);
 
 	hdr = (struct ieee80211_hdr *)wl->partial_rx.skb->data;
 
@@ -234,22 +226,20 @@ int wlcore_rx_getPacketData(struct cc33xx *wl, u8 *raw_buffer_ptr,
 	if (ieee80211_is_probe_resp(hdr->frame_control))
 		is_probe_resp = 1;
 
-
 	cc33xx_rx_status(wl, &wl->partial_rx.desc,
-		     IEEE80211_SKB_RXCB(wl->partial_rx.skb),
-		     beacon, is_probe_resp);
-
+			 IEEE80211_SKB_RXCB(wl->partial_rx.skb),
+			 beacon, is_probe_resp);
 
 	seq_num = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;
 	cc33xx_debug(DEBUG_RX, "rx skb 0x%p: %d B %s seq %d link id %d",
-			wl->partial_rx.skb,
-			wl->partial_rx.skb->len - wl->partial_rx.desc.pad_len,
-			beacon ? "beacon" : "", seq_num, wl->partial_rx.desc.hlid);
+		     wl->partial_rx.skb,
+		     wl->partial_rx.skb->len - wl->partial_rx.desc.pad_len,
+		     beacon ? "beacon" : "", seq_num, wl->partial_rx.desc.hlid);
 
 	cc33xx_debug(DEBUG_RX, "rx frame. frame type 0x%x, frame length 0x%x, "
-			"frame address 0x%lx",hdr->frame_control,
-			wl->partial_rx.skb->len,
-			(unsigned long)wl->partial_rx.skb->data);
+		     "frame address 0x%lx",
+		     hdr->frame_control, wl->partial_rx.skb->len,
+		     (unsigned long)wl->partial_rx.skb->data);
 
 	/* Adding frame to queue */
 	skb_queue_tail(&wl->deferred_rx_queue, wl->partial_rx.skb);
@@ -257,8 +247,8 @@ int wlcore_rx_getPacketData(struct cc33xx *wl, u8 *raw_buffer_ptr,
 	wl->partial_rx.status = CURR_RX_START;
 
 	/* Make sure the deferred queues don't get too long */
-	defer_count = skb_queue_len(&wl->deferred_tx_queue) +
-			skb_queue_len(&wl->deferred_rx_queue);
+	defer_count = skb_queue_len(&wl->deferred_tx_queue);
+	defer_count += skb_queue_len(&wl->deferred_rx_queue);
 	if (defer_count >= CC33XX_RX_QUEUE_MAX_LEN)
 		cc33xx_flush_deferred_work(wl);
 	else
@@ -268,10 +258,9 @@ int wlcore_rx_getPacketData(struct cc33xx *wl, u8 *raw_buffer_ptr,
 	return (prev_buffer_len - *raw_buffer_len);
 }
 
-int wlcore_rx_dropPacketData(struct cc33xx *wl, u8 *raw_buffer_ptr,
-			     u16 *raw_buffer_len)
+static int wlcore_rx_dropPacketData(struct cc33xx *wl, u8 *raw_buffer_ptr,
+				    u16 *raw_buffer_len)
 {
-
 	u16 prev_buffer_len = *raw_buffer_len;
 
 	/* Can we drop the entire frame ? */
@@ -297,7 +286,6 @@ static void cc33xx_rx_handle_packet(struct cc33xx *wl, u8 *raw_buffer_ptr,
 	struct cc33xx_rx_descriptor *desc;
 	u16 consumedBytes;
 
-
 	if (CURR_RX_START == wl->partial_rx.status) {
 		BUG_ON(*raw_buffer_len < 2);
 		desc = (struct cc33xx_rx_descriptor *)raw_buffer_ptr;
@@ -305,16 +293,16 @@ static void cc33xx_rx_handle_packet(struct cc33xx *wl, u8 *raw_buffer_ptr,
 		wl->partial_rx.handled_bytes = 0;
 		wl->partial_rx.status = CURR_RX_DESC;
 
-		cc33xx_debug(DEBUG_RX,
-			"rx frame. desc length 0x%x, alignment 0x%x, padding 0x%x",
+		cc33xx_debug(DEBUG_RX, "rx frame. desc length 0x%x, "
+			"alignment 0x%x, padding 0x%x",
 			desc->length, desc->header_alignment, desc->pad_len);
 	}
 
-
 	/* start \ continue copy descriptor */
 	if (CURR_RX_DESC == wl->partial_rx.status) {
-		consumedBytes = wlcore_rx_getPacketDescriptor(wl, raw_buffer_ptr,
-							raw_buffer_len);
+		consumedBytes = wlcore_rx_getPacketDescriptor(wl,
+							      raw_buffer_ptr,
+							      raw_buffer_len);
 		raw_buffer_ptr += consumedBytes;
 	}
 
@@ -333,7 +321,6 @@ static void cc33xx_rx_handle_packet(struct cc33xx *wl, u8 *raw_buffer_ptr,
 	}
 }
 
-
 /*
  * It is assumed that SDIO buffer was read prior to this function (data buffer
  * is read along with the status). The RX function gets pointer to the RX data
@@ -352,9 +339,8 @@ int wlcore_rx(struct cc33xx *wl, u8 *rx_buf_ptr, u16 rx_buf_len)
 
 	/* Split data into separate packets */
 	while (local_rx_buffer_len > 0) {
-		cc33xx_debug(DEBUG_RX,"start loop. buffer length %d" ,
-			local_rx_buffer_len);
-
+		cc33xx_debug(DEBUG_RX, "start loop. buffer length %d" ,
+			     local_rx_buffer_len);
 
 		/*
 		* the handle data call can only fail in memory-outage
@@ -362,25 +348,24 @@ int wlcore_rx(struct cc33xx *wl, u8 *rx_buf_ptr, u16 rx_buf_len)
 		* be dropped.
 		*/
 		prev_rx_buf_len = local_rx_buffer_len;
-		cc33xx_rx_handle_packet (wl,
-					rx_buf_ptr + pkt_offset,
+		cc33xx_rx_handle_packet(wl, rx_buf_ptr + pkt_offset,
 					&local_rx_buffer_len);
 		consumed_bytes = prev_rx_buf_len - local_rx_buffer_len;
 
 		pkt_offset +=  consumed_bytes;
 
-		cc33xx_debug(DEBUG_RX,"end rx loop. buffer length %d, "
-			"packet counter %d, current packet status %d" ,
-			local_rx_buffer_len, wl->rx_counter, wl->partial_rx.status);
+		cc33xx_debug(DEBUG_RX, "end rx loop. buffer length %d, "
+			     "packet counter %d, current packet status %d",
+			     local_rx_buffer_len, wl->rx_counter,
+			     wl->partial_rx.status);
 	}
 
-	return(0);
+	return 0;
 }
 
 #ifdef CONFIG_PM
-int cc33xx_rx_filter_enable(struct cc33xx *wl,
-		int index, bool enable,
-		struct cc33xx_rx_filter *filter)
+int cc33xx_rx_filter_enable(struct cc33xx *wl, int index, bool enable,
+			    struct cc33xx_rx_filter *filter)
 {
 	int ret;
 
@@ -412,7 +397,7 @@ int cc33xx_rx_filter_clear_all(struct cc33xx *wl)
 
 	for (i = 0; i < CC33XX_MAX_RX_FILTERS; i++) {
 		if (!test_bit(i, wl->rx_filter_enabled))
-		continue;
+			continue;
 		ret = cc33xx_rx_filter_enable(wl, i, 0, NULL);
 		if (ret)
 			goto out;
@@ -421,4 +406,9 @@ int cc33xx_rx_filter_clear_all(struct cc33xx *wl)
 out:
 	return ret;
 }
+#else
+int cc33xx_rx_filter_enable(struct cc33xx *wl, int index, bool enable,
+			    struct cc33xx_rx_filter *filter) {}
+
+int cc33xx_rx_filter_clear_all(struct cc33xx *wl) {}
 #endif /* CONFIG_PM */
diff --git a/drivers/net/wireless/ti/cc33xx/rx.h b/drivers/net/wireless/ti/cc33xx/rx.h
index 6074a462ddde..6171b5444628 100644
--- a/drivers/net/wireless/ti/cc33xx/rx.h
+++ b/drivers/net/wireless/ti/cc33xx/rx.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * This file is part of wl1271
+ * This file is part of cc33xx
  *
  * Copyright (C) 1998-2009 Texas Instruments. All rights reserved.
  * Copyright (C) 2008-2009 Nokia Corporation
@@ -11,32 +11,6 @@
 #ifndef __RX_H__
 #define __RX_H__
 
-#include <linux/bitops.h>
-
-#define RSSI_LEVEL_BITMASK	0x7F
-#define ANT_DIVERSITY_BITMASK	BIT(7)
-
-#define SHORT_PREAMBLE_BIT   BIT(0)
-#define OFDM_RATE_BIT        BIT(6)
-#define PBCC_RATE_BIT        BIT(7)
-
-#define PLCP_HEADER_LENGTH 8
-#define RX_DESC_PACKETID_SHIFT 11
-#define RX_MAX_PACKET_ID 3
-
-#define RX_DESC_VALID_FCS         0x0001
-#define RX_DESC_MATCH_RXADDR1     0x0002
-#define RX_DESC_MCAST             0x0004
-#define RX_DESC_STAINTIM          0x0008
-#define RX_DESC_VIRTUAL_BM        0x0010
-#define RX_DESC_BCAST             0x0020
-#define RX_DESC_MATCH_SSID        0x0040
-#define RX_DESC_MATCH_BSSID       0x0080
-#define RX_DESC_ENCRYPTION_MASK   0x0300
-#define RX_DESC_MEASURMENT        0x0400
-#define RX_DESC_SEQNUM_MASK       0x1800
-#define	RX_DESC_MIC_FAIL	  0x2000
-#define	RX_DESC_DECRYPT_FAIL	  0x4000
 
 /*
  * RX Descriptor flags:
@@ -62,23 +36,12 @@
  * Bits 3-5 - process_id tag (AP mode FW)
  * Bits 6-7 - reserved
  */
-#define CC33XX_RX_DESC_STATUS_MASK      0x07
-
-#define CC33XX_RX_DESC_SUCCESS          0x00
-#define CC33XX_RX_DESC_DECRYPT_FAIL     0x01
-#define CC33XX_RX_DESC_MIC_FAIL         0x02
-
-#define RX_MEM_BLOCK_MASK            0xFF
-#define RX_BUF_SIZE_MASK             0xFFF00
-#define RX_BUF_SIZE_SHIFT_DIV        6
-#define ALIGNED_RX_BUF_SIZE_MASK     0xFFFF00
-#define ALIGNED_RX_BUF_SIZE_SHIFT    8
-
-/* If set, the start of IP payload is not 4 bytes aligned */
-#define RX_BUF_UNALIGNED_PAYLOAD     BIT(20)
-
-/* If set, the buffer was padded by the FW to be 4 bytes aligned */
-#define RX_BUF_PADDED_PAYLOAD        BIT(30)
+enum {
+	CC33XX_RX_DESC_SUCCESS		= 0x00,
+	CC33XX_RX_DESC_DECRYPT_FAIL	= 0x01,
+	CC33XX_RX_DESC_MIC_FAIL		= 0x02,
+	CC33XX_RX_DESC_STATUS_MASK	= 0x07
+};
 
 /*
  * Account for the padding inserted by the FW in case of RX_ALIGNMENT
@@ -95,17 +58,17 @@ enum wl_rx_buf_align {
 
 enum wl_rx_curr_status
 {
-    CURR_RX_START,
-    CURR_RX_DROP,
-    CURR_RX_DESC,
-    CURR_RX_DATA
+	CURR_RX_START,
+	CURR_RX_DROP,
+	CURR_RX_DESC,
+	CURR_RX_DATA
 };
 
 struct cc33xx_rx_descriptor {
 	__le16 length;
 	u8  header_alignment;
 	u8  status;
-    __le32 timestamp;
+	__le32 timestamp;
 
 	u8  flags;
 	u8  rate;
@@ -118,19 +81,19 @@ struct cc33xx_rx_descriptor {
 	u8  frame_format;
 } __packed;
 
-
 struct partial_rx_frame{
-    struct sk_buff *skb;
-    struct cc33xx_rx_descriptor desc;
-    u16 handled_bytes;
-    u16 original_bytes; /* including descriptor */
-    enum wl_rx_curr_status status;
+	struct sk_buff *skb;
+	struct cc33xx_rx_descriptor desc;
+	u16 handled_bytes;
+	u16 original_bytes; /* including descriptor */
+	enum wl_rx_curr_status status;
 };
 
+
 int wlcore_rx(struct cc33xx *wl, u8 *rx_buf_ptr, u16 rx_buf_len);
-int cc33xx_rx_filter_enable(struct cc33xx *wl,
-			    int index, bool enable,
+int cc33xx_rx_filter_enable(struct cc33xx *wl, int index, bool enable,
 			    struct cc33xx_rx_filter *filter);
 int cc33xx_rx_filter_clear_all(struct cc33xx *wl);
 
-#endif
+
+#endif /* __RX_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/scan.c b/drivers/net/wireless/ti/cc33xx/scan.c
index 20e99ab1bb05..c0d2f4061d01 100644
--- a/drivers/net/wireless/ti/cc33xx/scan.c
+++ b/drivers/net/wireless/ti/cc33xx/scan.c
@@ -7,133 +7,345 @@
  * Contact: Luciano Coelho <luciano.coelho@nokia.com>
  */
 
-#include <linux/ieee80211.h>
-
 #include "wlcore.h"
 #include "debug.h"
 #include "cmd.h"
 #include "scan.h"
-#include "acx.h"
 #include "tx.h"
-
+#include "conf.h"
 
 
 static void cc33xx_adjust_channels(struct scan_param *scanParam,
 				   struct wlcore_scan_channels *cmd_channels,
 				   EScanRequestType scan_type)
 {
+	struct conn_scan_ch_info	*ch_info_list;
+	struct conn_scan_dwell_info	*dwell_info;
+	struct conn_scan_ch_params	*channel;
+	struct conn_scan_ch_params	*ch_params_list;
+
+	u8 *passive;
+	u8 *dfs;
+	u8 *active;
+	int i,j;
+	u8 band;
+
+	if(scan_type == SCAN_REQUEST_CONNECT_PERIODIC_SCAN)
+	{
+		ch_info_list	= scanParam->u.periodic.channel_list;
+		dwell_info	= scanParam->u.periodic.dwell_info;
+		active		= (u8*)&scanParam->u.periodic.active;
+		passive		= (u8*)&scanParam->u.periodic.passive;
+		dfs		= (u8*)&scanParam->u.periodic.dfs;
+	} else {
+		ch_info_list	= scanParam->u.one_shot.channel_list;
+		dwell_info	= scanParam->u.one_shot.dwell_info;
+		active		= (u8*)&scanParam->u.one_shot.active;
+		passive		= (u8*)&scanParam->u.one_shot.passive;
+		dfs		= (u8*)&scanParam->u.one_shot.dfs;
+	}
 
-    struct conn_scan_ch_info      *ch_list;
-    struct conn_scan_dwell_info   *dwell_info;
-
-    u8 *passive;
-    u8 *dfs;
-    u8 *active;
-    int i,j;
-
-    if(scan_type == SCAN_REQUEST_CONNECT_PERIODIC_SCAN)
-    {
-        //struct scan_periodic_info *pPeriodicScanParams = &scanParam->u.periodic;
-
-        ch_list        = scanParam->u.periodic.channel_list;
-        dwell_info   = scanParam->u.periodic.dwell_info;
-        active        = (u8*)&scanParam->u.periodic.active;
-        passive       = (u8*)&scanParam->u.periodic.passive;
-        dfs           = (u8*)&scanParam->u.periodic.dfs;
-
-    }
-    else
-    {
-        ch_list        = scanParam->u.one_shot.channel_list;
-        dwell_info   = scanParam->u.one_shot.dwell_info;
-        active        = (u8*)&scanParam->u.one_shot.active;
-        passive       = (u8*)&scanParam->u.one_shot.passive;
-        dfs           = (u8*)&scanParam->u.one_shot.dfs;
-    }
-
-    memcpy(passive, cmd_channels->passive, sizeof(cmd_channels->passive));
-    memcpy(active, cmd_channels->active, sizeof(cmd_channels->active));
-    *dfs = cmd_channels->dfs;
-
-    for (i = 0; i < MAX_CHANNELS_2GHZ; ++i)
-    {
-	ch_list[i].channel = cmd_channels->channels_2[i].channel;
-	ch_list[i].flags = cmd_channels->channels_2[i].flags;
-	ch_list[i].tx_power_att = cmd_channels->channels_2[i].tx_power_att;
-    }
-
-    dwell_info[NL80211_BAND_2GHZ].min_duration     = cmd_channels->channels_2[0].min_duration;
-    dwell_info[NL80211_BAND_2GHZ].max_duration     = cmd_channels->channels_2[0].max_duration;
-    dwell_info[NL80211_BAND_2GHZ].passive_duration = cmd_channels->channels_2[0].passive_duration;
-
-    for (j = 0; j < MAX_CHANNELS_5GHZ; ++i, ++j)
-    {
-        ch_list[i].channel = cmd_channels->channels_5[j].channel;
-        ch_list[i].flags = cmd_channels->channels_5[j].flags;
-        ch_list[i].tx_power_att = cmd_channels->channels_5[j].tx_power_att;
-    }
-    dwell_info[NL80211_BAND_5GHZ].min_duration     = cmd_channels->channels_5[0].min_duration;
-    dwell_info[NL80211_BAND_5GHZ].max_duration     = cmd_channels->channels_5[0].max_duration;
-    dwell_info[NL80211_BAND_5GHZ].passive_duration = cmd_channels->channels_5[0].passive_duration;
+	memcpy(passive, cmd_channels->passive, sizeof(cmd_channels->passive));
+	memcpy(active, cmd_channels->active, sizeof(cmd_channels->active));
+	*dfs = cmd_channels->dfs;
 
+	ch_params_list = cmd_channels->channels_2;
+	for (i = 0; i < MAX_CHANNELS_2GHZ; ++i)
+	{
+		ch_info_list[i].channel	= ch_params_list[i].channel;
+		ch_info_list[i].flags = ch_params_list[i].flags;
+		ch_info_list[i].tx_power_att = ch_params_list[i].tx_power_att;
+	}
+
+	channel = &ch_params_list[0];
+	band = NL80211_BAND_2GHZ;
+	dwell_info[band].min_duration     = channel->min_duration;
+	dwell_info[band].max_duration     = channel->max_duration;
+	dwell_info[band].passive_duration = channel->passive_duration;
+
+	ch_params_list = cmd_channels->channels_5;
+	for (j = 0; j < MAX_CHANNELS_5GHZ; ++i, ++j)
+	{
+		ch_info_list[i].channel = ch_params_list[j].channel;
+		ch_info_list[i].flags = ch_params_list[j].flags;
+		ch_info_list[i].tx_power_att = ch_params_list[j].tx_power_att;
+	}
+
+	channel = &ch_params_list[0];
+	band = NL80211_BAND_5GHZ;
+	dwell_info[band].min_duration     = channel->min_duration;
+	dwell_info[band].max_duration     = channel->max_duration;
+	dwell_info[band].passive_duration = channel->passive_duration;
 }
 
+static int cc33xx_cmd_build_probe_req(struct cc33xx *wl,
+				      struct cc33xx_vif *wlvif, u8 role_id,
+				      u8 scan_type, const u8 *ssid,
+				      size_t ssid_len, const u8 *ie0,
+				      size_t ie0_len, const u8 *ie1,
+				      size_t ie1_len, bool sched_scan)
+{
+	struct ieee80211_vif *vif = cc33xx_wlvif_to_vif(wlvif);
+	struct sk_buff *skb=NULL;
+	struct cc33xx_cmd_set_ies *cmd;
+	int ret;
+
+	cc33xx_debug(DEBUG_SCAN, "build probe request scan_type %d", scan_type);
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	skb = ieee80211_probereq_get(wl->hw, vif->addr, ssid,
+				     ssid_len, ie0_len + ie1_len);
+	if (!skb) {
+		ret = -ENOMEM;
+		goto out_free;
+	}
+
+	if (ie0_len)
+		skb_put_data(skb, ie0, ie0_len);
+
+	if (ie1_len)
+		skb_put_data(skb, ie1, ie1_len);
+
+	cmd->scan_type = scan_type;
+	cmd->role_id = role_id;
+
+	cmd->len = cpu_to_le16(skb->len) - sizeof(struct ieee80211_hdr_3addr);
+
+	if (skb->data)
+	{
+		memcpy(cmd->data,
+		       skb->data + sizeof(struct ieee80211_hdr_3addr),cmd->len);
+	}
+
+	//Katya - temporary workaround - untill scan module is changed
+	usleep_range(10000, 11000);
+	ret = cc33xx_cmd_send(wl, CMD_SET_PROBE_IE, cmd, sizeof(*cmd), 0);
+
+	if (ret < 0) {
+		cc33xx_warning("cmd set_template failed: %d", ret);
+		goto out_free;
+	}
+
+	out_free:
+	dev_kfree_skb(skb);
+	kfree(cmd);
+	out:
+	return ret;
+}
 
-int cc33xx_cmd_build_probe_req(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-                   u8 role_id, u8 scan_type,
-                   const u8 *ssid, size_t ssid_len,
-                   const u8 *ie0, size_t ie0_len, const u8 *ie1,
-                   size_t ie1_len, bool sched_scan)
+static void wlcore_started_vifs_iter(void *data, u8 *mac,
+				     struct ieee80211_vif *vif)
 {
-    struct ieee80211_vif *vif = cc33xx_wlvif_to_vif(wlvif);
-    struct sk_buff *skb=NULL;
+	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
+	bool active = false;
+	int *count = (int *)data;
 
-    struct cc33xx_cmd_set_ies *cmd;
-    int ret;
+	/*
+	 * count active interfaces according to interface type.
+	 * checking only bss_conf.idle is bad for some cases, e.g.
+	 * we don't want to count sta in p2p_find as active interface.
+	 */
+	switch (wlvif->bss_type) {
+	case BSS_TYPE_STA_BSS:
+		if (test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))
+			active = true;
+		break;
 
-    cc33xx_debug(DEBUG_SCAN, "build probe request scan_type %d", scan_type);
+	case BSS_TYPE_AP_BSS:
+		if (wlvif->wl->active_sta_count > 0)
+			active = true;
+		break;
 
-    cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
-    if (!cmd) {
-        ret = -ENOMEM;
-        goto out;
-    }
+	default:
+		break;
+	}
 
-    skb = ieee80211_probereq_get(wl->hw, vif->addr, ssid, ssid_len,
-                     ie0_len + ie1_len);
-    if (!skb) {
-        ret = -ENOMEM;
-        goto out_free;
-    }
-    if (ie0_len)
-        skb_put_data(skb, ie0, ie0_len);
-    if (ie1_len)
-        skb_put_data(skb, ie1, ie1_len);
+	if (active)
+		(*count)++;
+}
 
-    cmd->scan_type = scan_type;
-    cmd->role_id = role_id;
+static int wlcore_count_started_vifs(struct cc33xx *wl)
+{
+	int count = 0;
 
-    cmd->len = cpu_to_le16(skb->len) - sizeof(struct ieee80211_hdr_3addr);
+	ieee80211_iterate_active_interfaces_atomic(wl->hw,
+						IEEE80211_IFACE_ITER_RESUME_ALL,
+						   wlcore_started_vifs_iter,
+						   &count);
+	return count;
+}
 
-    if (skb->data)
-        memcpy(cmd->data, skb->data + sizeof(struct ieee80211_hdr_3addr), cmd->len);
+static int wlcore_scan_get_channels(struct cc33xx *wl,
+				    struct ieee80211_channel *req_channels[],
+				    u32 n_channels, u32 n_ssids,
+				    struct conn_scan_ch_params *channels,
+				    u32 band, bool radar, bool passive,
+				    int start, int max_channels,
+				    u8 *n_pactive_ch, int scan_type)
+{
+	int i, j;
+	u32 flags;
+	bool force_passive = !n_ssids;
+	u32 min_dwell_time_active, max_dwell_time_active;
+	u32 dwell_time_passive, dwell_time_dfs;
+	struct conn_scan_ch_params *ch;
+	struct ieee80211_channel *req_ch;
 
-    //Katya - temporary workaround - untill scan module is changed
-    usleep_range(10000, 11000);
-    ret = cc33xx_cmd_send(wl, CMD_SET_PROBE_IE, cmd, sizeof(*cmd), 0);
+	/* configure dwell times according to scan type */
+	if (scan_type == SCAN_TYPE_SEARCH) {
+		struct conf_scan_settings *c = &wl->conf.host_conf.scan;
+		bool active_vif_exists = !!wlcore_count_started_vifs(wl);
 
-    if (ret < 0) {
-        cc33xx_warning("cmd set_template failed: %d", ret);
-        goto out_free;
-    }
+		min_dwell_time_active = active_vif_exists ?
+						c->min_dwell_time_active :
+						c->min_dwell_time_active_long;
+		max_dwell_time_active = active_vif_exists ?
+						c->max_dwell_time_active :
+						c->max_dwell_time_active_long;
+		dwell_time_passive = c->dwell_time_passive;
+		dwell_time_dfs = c->dwell_time_dfs;
+	} else {
+		struct conf_sched_scan_settings *c =
+					&wl->conf.host_conf.sched_scan;
+		u32 delta_per_probe;
 
-out_free:
-    dev_kfree_skb(skb);
-    kfree(cmd);
-out:
-    return ret;
+		delta_per_probe = (band == NL80211_BAND_5GHZ) ?
+					c->dwell_time_delta_per_probe_5 :
+					c->dwell_time_delta_per_probe;
+
+		min_dwell_time_active = c->base_dwell_time +
+			 n_ssids * c->num_probe_reqs * delta_per_probe;
+
+		max_dwell_time_active = min_dwell_time_active;
+		max_dwell_time_active += c->max_dwell_time_delta;
+		dwell_time_passive = c->dwell_time_passive;
+		dwell_time_dfs = c->dwell_time_dfs;
+	}
+
+	min_dwell_time_active = DIV_ROUND_UP(min_dwell_time_active, 1000);
+	max_dwell_time_active = DIV_ROUND_UP(max_dwell_time_active, 1000);
+	dwell_time_passive = DIV_ROUND_UP(dwell_time_passive, 1000);
+	dwell_time_dfs = DIV_ROUND_UP(dwell_time_dfs, 1000);
+
+	for (i = 0, j = start; i < n_channels && j < max_channels; i++) {
+		flags = req_channels[i]->flags;
+		ch = &channels[j];
+		req_ch = req_channels[i];
+
+		if (force_passive)
+			flags |= IEEE80211_CHAN_NO_IR;
+
+		if ((req_ch->band == band) && !(flags & IEEE80211_CHAN_DISABLED)
+		    && (!!(flags & IEEE80211_CHAN_RADAR) == radar) &&
+		    /* if radar is set, we ignore the passive flag */
+		    (radar || !!(flags & IEEE80211_CHAN_NO_IR) == passive)) {
+			if (flags & IEEE80211_CHAN_RADAR) {
+				ch->flags |= SCAN_CHANNEL_FLAGS_DFS;
+
+				ch->passive_duration =
+					cpu_to_le16(dwell_time_dfs);
+			} else {
+				ch->passive_duration =
+					cpu_to_le16(dwell_time_passive);
+			}
+
+			ch->min_duration = cpu_to_le16(min_dwell_time_active);
+			ch->max_duration = cpu_to_le16(max_dwell_time_active);
+
+			ch->tx_power_att = req_ch->max_power;
+			ch->channel = req_ch->hw_value;
+
+			if (n_pactive_ch && (band == NL80211_BAND_2GHZ) &&
+			    (ch->channel >= 12) && (ch->channel <= 14) &&
+			    (flags & IEEE80211_CHAN_NO_IR) && !force_passive) {
+				/* pactive channels treated as DFS */
+				ch->flags = SCAN_CHANNEL_FLAGS_DFS;
+
+				/*
+				 * n_pactive_ch is counted down from the end of
+				 * the passive channel list
+				 */
+				(*n_pactive_ch)++;
+				cc33xx_debug(DEBUG_SCAN, "n_pactive_ch = %d",
+					     *n_pactive_ch);
+			}
+
+			cc33xx_debug(DEBUG_SCAN, "freq %d, ch. %d, flags 0x%x, "
+				     "power %d, min/max_dwell %d/%d%s%s",
+				     req_ch->center_freq, req_ch->hw_value,
+				     req_ch->flags, req_ch->max_power,
+				     min_dwell_time_active,
+				     max_dwell_time_active,
+				     flags & IEEE80211_CHAN_RADAR ? ", DFS": "",
+				     flags & IEEE80211_CHAN_NO_IR?", NO-IR":"");
+			j++;
+		}
+	}
+
+	return j - start;
 }
 
+static bool wlcore_set_scan_chan_params(struct cc33xx *wl,
+					struct wlcore_scan_channels *cfg,
+					struct ieee80211_channel *channels[],
+					u32 n_channels, u32 n_ssids,
+					int scan_type)
+{
+	u8 n_pactive_ch = 0;
+
+	cfg->passive[0] = wlcore_scan_get_channels(wl, channels, n_channels,
+						   n_ssids, cfg->channels_2,
+						   NL80211_BAND_2GHZ, false,
+						   true, 0, MAX_CHANNELS_2GHZ,
+						   &n_pactive_ch, scan_type);
+
+	cfg->active[0] = wlcore_scan_get_channels(wl, channels, n_channels,
+						  n_ssids, cfg->channels_2,
+						  NL80211_BAND_2GHZ, false,
+						  false, cfg->passive[0],
+						  MAX_CHANNELS_2GHZ,
+						  &n_pactive_ch, scan_type);
+
+	cfg->passive[1] = wlcore_scan_get_channels(wl, channels, n_channels,
+						   n_ssids, cfg->channels_5,
+						   NL80211_BAND_5GHZ, false,
+						   true, 0, MAX_CHANNELS_5GHZ,
+						   &n_pactive_ch, scan_type);
+
+	cfg->dfs = wlcore_scan_get_channels(wl, channels, n_channels, n_ssids,
+					    cfg->channels_5, NL80211_BAND_5GHZ,
+					    true, true, cfg->passive[1],
+					    MAX_CHANNELS_5GHZ, &n_pactive_ch,
+					    scan_type);
+
+	cfg->active[1] = wlcore_scan_get_channels(wl, channels, n_channels,
+						  n_ssids, cfg->channels_5,
+						  NL80211_BAND_5GHZ, false,
+						  false,
+						  cfg->passive[1] + cfg->dfs,
+						  MAX_CHANNELS_5GHZ,
+						  &n_pactive_ch, scan_type);
+
+	/* 802.11j channels are not supported yet */
+	cfg->passive[2] = 0;
+	cfg->active[2] = 0;
+
+	cfg->passive_active = n_pactive_ch;
+
+	cc33xx_debug(DEBUG_SCAN, "2.4GHz: active %d passive %d",
+		     cfg->active[0], cfg->passive[0]);
+	cc33xx_debug(DEBUG_SCAN, "5GHz: active %d passive %d",
+		     cfg->active[1], cfg->passive[1]);
+	cc33xx_debug(DEBUG_SCAN, "DFS: %d", cfg->dfs);
+
+	return  cfg->passive[0] || cfg->active[0] || cfg->passive[1] ||
+		cfg->active[1] || cfg->dfs || cfg->passive[2] || cfg->active[2];
+}
 
 static int cc33xx_scan_send(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			    struct cfg80211_scan_request *req)
@@ -143,6 +355,7 @@ static int cc33xx_scan_send(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	struct cc33xx_ssid *cmd_ssid;
 	u16 alloc_size;
 	int ret;
+	int i;
 
 	alloc_size =  sizeof(*cmd) + (sizeof(struct cc33xx_ssid)*req->n_ssids);
 	cmd = kzalloc(alloc_size, GFP_KERNEL);
@@ -166,7 +379,8 @@ static int cc33xx_scan_send(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	cmd->rssi_threshold = -127;
 	cmd->snr_threshold = 0;
 
-
+	for(i = 0; i < ETH_ALEN; i++)
+		cmd->bssid[i] = req->bssid[i];
 	cmd->ssid_from_list = 0;
 	cmd->filter = 0;
 	WARN_ON(req->n_ssids > 1);
@@ -195,19 +409,15 @@ static int cc33xx_scan_send(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				SCAN_SSID_TYPE_HIDDEN : SCAN_SSID_TYPE_PUBLIC;
 	}
 
-	ret = cc33xx_cmd_build_probe_req(wl, wlvif,
-             cmd->role_id, cmd->scan_type,
-             req->ssids ? req->ssids[0].ssid : NULL,
-             req->ssids ? req->ssids[0].ssid_len : 0,
-             req->ie,
-             req->ie_len,
-             NULL,
-             0,
-             false);
+	ret = cc33xx_cmd_build_probe_req(wl, wlvif, cmd->role_id,cmd->scan_type,
+					 req->ssids ? req->ssids[0].ssid : NULL,
+					 req->ssids ? req->ssids[0].ssid_len :0,
+					 req->ie, req->ie_len, NULL, 0, false);
 	if (ret < 0) {
 		cc33xx_error("PROBE request template failed");
 		goto out;
 	}
+
 	cc33xx_dump(DEBUG_SCAN, "SCAN: ", cmd, alloc_size);
 
 	ret = cc33xx_cmd_send(wl, CMD_SCAN, cmd, alloc_size, 0);
@@ -222,11 +432,10 @@ static int cc33xx_scan_send(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-int
-cc33xx_scan_sched_scan_ssid_list(struct cc33xx *wl,
-				 struct cc33xx_vif *wlvif,
-				 struct cfg80211_sched_scan_request *req,
-				 struct cc33xx_cmd_ssid_list *cmd)
+static int cc33xx_scan_sched_scan_ssid_list(struct cc33xx *wl,
+					    struct cc33xx_vif *wlvif,
+					struct cfg80211_sched_scan_request *req,
+					    struct cc33xx_cmd_ssid_list *cmd)
 {
 	struct cfg80211_match_set *sets = req->match_sets;
 	struct cfg80211_ssid *ssids = req->ssids;
@@ -239,9 +448,9 @@ cc33xx_scan_sched_scan_ssid_list(struct cc33xx *wl,
 		if (sets[i].ssid.ssid_len > 0)
 			n_match_ssids++;
 	}
+
 	/* No filter, no ssids or only bcast ssid */
-	if (!n_match_ssids &&
-	    (!req->n_ssids ||
+	if (!n_match_ssids && (!req->n_ssids ||
 	     (req->n_ssids == 1 && req->ssids[0].ssid_len == 0))) {
 		type = SCAN_SSID_FILTER_ANY;
 		goto out;
@@ -288,10 +497,10 @@ cc33xx_scan_sched_scan_ssid_list(struct cc33xx *wl,
 				for (j = 0; j < cmd->n_ssids; j++)
 				{
 					if ((req->ssids[i].ssid_len ==
-					     cmd->ssids[j].len) &&
+					    cmd->ssids[j].len) &&
 					    !memcmp(req->ssids[i].ssid,
-						   cmd->ssids[j].ssid,
-						   req->ssids[i].ssid_len)) {
+						    cmd->ssids[j].ssid,
+						    req->ssids[i].ssid_len)) {
 						cmd->ssids[j].type =
 							SCAN_SSID_TYPE_HIDDEN;
 						break;
@@ -306,21 +515,19 @@ cc33xx_scan_sched_scan_ssid_list(struct cc33xx *wl,
 		}
 	}
 
-	cc33xx_debug(DEBUG_CMD, "cmd sched scan with ssid list %d",cmd->n_ssids);
+	cc33xx_debug(DEBUG_CMD, "cmd sched scan with ssid list %d",
+		     cmd->n_ssids);
 	return cmd->n_ssids;
 out:
 	if (ret < 0)
 		return ret;
-	return 0;
 
+	return 0;
 }
 
-
-static
-int cc33xx_scan_sched_scan_config(struct cc33xx *wl,
-				  struct cc33xx_vif *wlvif,
-				  struct cfg80211_sched_scan_request *req,
-				  struct ieee80211_scan_ies *ies)
+int cc33xx_sched_scan_start(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+			    struct cfg80211_sched_scan_request *req,
+			    struct ieee80211_scan_ies *ies)
 {
 	struct cc33xx_cmd_scan_params *cmd;
 	struct cc33xx_cmd_ssid_list *ssid_list;
@@ -342,15 +549,15 @@ int cc33xx_scan_sched_scan_config(struct cc33xx *wl,
 	if(n_ssids < 0) {
 		return n_ssids;
 	}
-	cc33xx_debug(DEBUG_CMD, "ssid list num of ssids %d",
-		ssid_list->n_ssids);
-	if(n_ssids <= 5)
+
+	cc33xx_debug(DEBUG_CMD, "ssid list num of ssids %d",ssid_list->n_ssids);
+
+	if(n_ssids <= 5) {
 		alloc_size += (n_ssids * sizeof(struct cc33xx_ssid));
-	else //n_ssids > 5
-	{
+	} else { /* n_ssids > 5 */
 		ssid_list->scan_type = SCAN_REQUEST_CONNECT_PERIODIC_SCAN;
-		ret = cc33xx_cmd_send(wl, CMD_CONNECTION_SCAN_SSID_CFG, ssid_list,
-			      sizeof(*ssid_list), 0);
+		ret = cc33xx_cmd_send(wl, CMD_CONNECTION_SCAN_SSID_CFG,
+				      ssid_list, sizeof(*ssid_list), 0);
 		if (ret < 0) {
 			cc33xx_error("cmd sched scan ssid list failed");
 			goto out_ssid_free;
@@ -377,13 +584,10 @@ int cc33xx_scan_sched_scan_config(struct cc33xx *wl,
 	cmd->filter = 1;
 	cmd->num_of_ssids = n_ssids;
 
-	cc33xx_debug(DEBUG_CMD, "ssid list num of n_ssids %d",
-				n_ssids);
-	if( (n_ssids > 0) && (n_ssids <= 5) )
-	{
+	cc33xx_debug(DEBUG_CMD, "ssid list num of n_ssids %d", n_ssids);
+	if ((n_ssids > 0) && (n_ssids <= 5)) {
 		cmd->ssid_from_list = 1;
-		memcpy((u8*)cmd + sizeof(*cmd),
-			ssid_list->ssids,
+		memcpy((u8*)cmd + sizeof(*cmd), ssid_list->ssids,
 			n_ssids * sizeof(struct cc33xx_ssid));
 	}
 
@@ -399,33 +603,29 @@ int cc33xx_scan_sched_scan_config(struct cc33xx *wl,
 				    SCAN_TYPE_PERIODIC);
 	cc33xx_adjust_channels(&cmd->params, cmd_channels, cmd->scan_type);
 
-
-	memcpy(cmd->params.u.periodic.sched_scan_plans,
-	       req->scan_plans,
+	memcpy(cmd->params.u.periodic.sched_scan_plans, req->scan_plans,
 	       sizeof(struct sched_scan_plan_cmd)*req->n_scan_plans);
 
 	cmd->params.u.periodic.sched_scan_plans_num = req->n_scan_plans;
 
-	cc33xx_debug(DEBUG_SCAN, "interval[0]: %d, iterations[0]: %d, num_plans: %d",
+	cc33xx_debug(DEBUG_SCAN,
+		     "interval[0]: %d, iterations[0]: %d, num_plans: %d",
 		     cmd->params.u.periodic.sched_scan_plans[0].interval,
 		     cmd->params.u.periodic.sched_scan_plans[0].iterations,
 		     cmd->params.u.periodic.sched_scan_plans_num);
 
+	ret = cc33xx_cmd_build_probe_req(wl, wlvif, cmd->role_id,cmd->scan_type,
+					 req->ssids ? req->ssids[0].ssid : NULL,
+					 req->ssids ? req->ssids[0].ssid_len :0,
+					 ies->ies[NL80211_BAND_2GHZ],
+					 ies->len[NL80211_BAND_2GHZ],
+					 ies->common_ies,
+					 ies->common_ie_len, true);
 
-	ret = cc33xx_cmd_build_probe_req(wl, wlvif,
-             cmd->role_id, cmd->scan_type,
-             req->ssids ? req->ssids[0].ssid : NULL,
-             req->ssids ? req->ssids[0].ssid_len : 0,
-	     ies->ies[NL80211_BAND_2GHZ],
-	     ies->len[NL80211_BAND_2GHZ],
-             ies->common_ies,
-	     ies->common_ie_len,
-	     true);
-    if (ret < 0) {
-        cc33xx_error("PROBE request template failed");
-        goto out_free;
-    }
-
+	if (ret < 0) {
+		cc33xx_error("PROBE request template failed");
+		goto out_free;
+	}
 
 	cc33xx_dump(DEBUG_SCAN, "SCAN: ", cmd, alloc_size);
 
@@ -438,24 +638,17 @@ int cc33xx_scan_sched_scan_config(struct cc33xx *wl,
 out_free:
 	kfree(cmd_channels);
 	kfree(cmd);
+
 out_ssid_free:
 	kfree(ssid_list);
 
 	return ret;
 }
-int cc33xx_sched_scan_start(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			    struct cfg80211_sched_scan_request *req,
-			    struct ieee80211_scan_ies *ies)
-{
-	return cc33xx_scan_sched_scan_config(wl, wlvif, req, ies);
-}
 
-static int __cc33xx_scan_stop(struct cc33xx *wl, struct cc33xx_vif *wlvif,
-			       u8 scan_type)
+static int __cc33xx_scan_stop(struct cc33xx *wl,
+			      struct cc33xx_vif *wlvif, u8 scan_type)
 {
-
 	struct cc33xx_cmd_scan_stop *stop;
-
 	int ret;
 
 	cc33xx_debug(DEBUG_CMD, "cmd periodic scan stop");
@@ -480,7 +673,8 @@ static int __cc33xx_scan_stop(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return ret;
 }
 
-void cc33xx_scan_sched_scan_stop(struct cc33xx *wl, struct cc33xx_vif *wlvif)
+void cc33xx_scan_sched_scan_stop(struct cc33xx *wl,
+				 struct cc33xx_vif *wlvif)
 {
 	__cc33xx_scan_stop(wl, wlvif, SCAN_REQUEST_CONNECT_PERIODIC_SCAN);
 }
@@ -494,7 +688,6 @@ int cc33xx_scan_start(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 int cc33xx_scan_stop(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 {
 	return __cc33xx_scan_stop(wl, wlvif, SCAN_REQUEST_ONE_SHOT);
-
 }
 
 void cc33xx_scan_complete_work(struct work_struct *work)
@@ -532,11 +725,6 @@ void cc33xx_scan_complete_work(struct work_struct *work)
 	wl->scan.req = NULL;
 	wl->scan_wlvif = NULL;
 
-	if (test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) {
-		/* restore hardware connection monitoring template */
-		cc33xx_cmd_build_ap_probe_req(wl, wlvif, wlvif->probereq);
-	}
-
 	if (wl->scan.failed) {
 		cc33xx_info("Scan completed due to error.");
 		cc33xx_queue_recovery_work(wl);
@@ -548,259 +736,10 @@ void cc33xx_scan_complete_work(struct work_struct *work)
 
 out:
 	mutex_unlock(&wl->mutex);
-
-}
-
-static void wlcore_started_vifs_iter(void *data, u8 *mac,
-				     struct ieee80211_vif *vif)
-{
-	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
-	bool active = false;
-	int *count = (int *)data;
-
-	/*
-	 * count active interfaces according to interface type.
-	 * checking only bss_conf.idle is bad for some cases, e.g.
-	 * we don't want to count sta in p2p_find as active interface.
-	 */
-	switch (wlvif->bss_type) {
-	case BSS_TYPE_STA_BSS:
-		if (test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))
-			active = true;
-		break;
-
-	case BSS_TYPE_AP_BSS:
-		if (wlvif->wl->active_sta_count > 0)
-			active = true;
-		break;
-
-	default:
-		break;
-	}
-
-	if (active)
-		(*count)++;
-}
-
-static int wlcore_count_started_vifs(struct cc33xx *wl)
-{
-	int count = 0;
-
-	ieee80211_iterate_active_interfaces_atomic(wl->hw,
-					IEEE80211_IFACE_ITER_RESUME_ALL,
-					wlcore_started_vifs_iter, &count);
-	return count;
-}
-
-static int
-wlcore_scan_get_channels(struct cc33xx *wl,
-			 struct ieee80211_channel *req_channels[],
-			 u32 n_channels,
-			 u32 n_ssids,
-			 struct conn_scan_ch_params *channels,
-			 u32 band, bool radar, bool passive,
-			 int start, int max_channels,
-			 u8 *n_pactive_ch,
-			 int scan_type)
-{
-	int i, j;
-	u32 flags;
-	bool force_passive = !n_ssids;
-	u32 min_dwell_time_active, max_dwell_time_active;
-	u32 dwell_time_passive, dwell_time_dfs;
-
-	/* configure dwell times according to scan type */
-	if (scan_type == SCAN_TYPE_SEARCH) {
-		struct conf_scan_settings *c = &wl->conf.host_conf.scan;
-		bool active_vif_exists = !!wlcore_count_started_vifs(wl);
-
-		min_dwell_time_active = active_vif_exists ?
-			c->min_dwell_time_active :
-			c->min_dwell_time_active_long;
-		max_dwell_time_active = active_vif_exists ?
-			c->max_dwell_time_active :
-			c->max_dwell_time_active_long;
-		dwell_time_passive = c->dwell_time_passive;
-		dwell_time_dfs = c->dwell_time_dfs;
-	} else {
-		struct conf_sched_scan_settings *c = &wl->conf.host_conf.sched_scan;
-		u32 delta_per_probe;
-
-		if (band == NL80211_BAND_5GHZ)
-			delta_per_probe = c->dwell_time_delta_per_probe_5;
-		else
-			delta_per_probe = c->dwell_time_delta_per_probe;
-
-		min_dwell_time_active = c->base_dwell_time +
-			 n_ssids * c->num_probe_reqs * delta_per_probe;
-
-		max_dwell_time_active = min_dwell_time_active +
-					c->max_dwell_time_delta;
-		dwell_time_passive = c->dwell_time_passive;
-		dwell_time_dfs = c->dwell_time_dfs;
-	}
-	min_dwell_time_active = DIV_ROUND_UP(min_dwell_time_active, 1000);
-	max_dwell_time_active = DIV_ROUND_UP(max_dwell_time_active, 1000);
-	dwell_time_passive = DIV_ROUND_UP(dwell_time_passive, 1000);
-	dwell_time_dfs = DIV_ROUND_UP(dwell_time_dfs, 1000);
-
-	for (i = 0, j = start;
-	     i < n_channels && j < max_channels;
-	     i++) {
-		flags = req_channels[i]->flags;
-
-		if (force_passive)
-			flags |= IEEE80211_CHAN_NO_IR;
-
-		if ((req_channels[i]->band == band) &&
-		    !(flags & IEEE80211_CHAN_DISABLED) &&
-		    (!!(flags & IEEE80211_CHAN_RADAR) == radar) &&
-		    /* if radar is set, we ignore the passive flag */
-		    (radar ||
-		     !!(flags & IEEE80211_CHAN_NO_IR) == passive)) {
-			if (flags & IEEE80211_CHAN_RADAR) {
-				channels[j].flags |= SCAN_CHANNEL_FLAGS_DFS;
-
-				channels[j].passive_duration =
-					cpu_to_le16(dwell_time_dfs);
-			} else {
-				channels[j].passive_duration =
-					cpu_to_le16(dwell_time_passive);
-			}
-
-			channels[j].min_duration =
-				cpu_to_le16(min_dwell_time_active);
-			channels[j].max_duration =
-				cpu_to_le16(max_dwell_time_active);
-
-			channels[j].tx_power_att = req_channels[i]->max_power;
-			channels[j].channel = req_channels[i]->hw_value;
-
-			if (n_pactive_ch &&
-			    (band == NL80211_BAND_2GHZ) &&
-			    (channels[j].channel >= 12) &&
-			    (channels[j].channel <= 14) &&
-			    (flags & IEEE80211_CHAN_NO_IR) &&
-			    !force_passive) {
-				/* pactive channels treated as DFS */
-				channels[j].flags = SCAN_CHANNEL_FLAGS_DFS;
-
-				/*
-				 * n_pactive_ch is counted down from the end of
-				 * the passive channel list
-				 */
-				(*n_pactive_ch)++;
-				cc33xx_debug(DEBUG_SCAN, "n_pactive_ch = %d",
-					     *n_pactive_ch);
-			}
-
-			cc33xx_debug(DEBUG_SCAN, "freq %d, ch. %d, flags 0x%x, power %d, min/max_dwell %d/%d%s%s",
-				     req_channels[i]->center_freq,
-				     req_channels[i]->hw_value,
-				     req_channels[i]->flags,
-				     req_channels[i]->max_power,
-				     min_dwell_time_active,
-				     max_dwell_time_active,
-				     flags & IEEE80211_CHAN_RADAR ?
-					", DFS" : "",
-				     flags & IEEE80211_CHAN_NO_IR ?
-					", NO-IR" : "");
-			j++;
-		}
-	}
-
-	return j - start;
-}
-
-bool
-wlcore_set_scan_chan_params(struct cc33xx *wl,
-			    struct wlcore_scan_channels *cfg,
-			    struct ieee80211_channel *channels[],
-			    u32 n_channels,
-			    u32 n_ssids,
-			    int scan_type)
-{
-	u8 n_pactive_ch = 0;
-
-	cfg->passive[0] =
-		wlcore_scan_get_channels(wl,
-					 channels,
-					 n_channels,
-					 n_ssids,
-					 cfg->channels_2,
-					 NL80211_BAND_2GHZ,
-					 false, true, 0,
-					 MAX_CHANNELS_2GHZ,
-					 &n_pactive_ch,
-					 scan_type);
-	cfg->active[0] =
-		wlcore_scan_get_channels(wl,
-					 channels,
-					 n_channels,
-					 n_ssids,
-					 cfg->channels_2,
-					 NL80211_BAND_2GHZ,
-					 false, false,
-					 cfg->passive[0],
-					 MAX_CHANNELS_2GHZ,
-					 &n_pactive_ch,
-					 scan_type);
-	cfg->passive[1] =
-		wlcore_scan_get_channels(wl,
-					 channels,
-					 n_channels,
-					 n_ssids,
-					 cfg->channels_5,
-					 NL80211_BAND_5GHZ,
-					 false, true, 0,
-					 wl->max_channels_5,
-					 &n_pactive_ch,
-					 scan_type);
-	cfg->dfs =
-		wlcore_scan_get_channels(wl,
-					 channels,
-					 n_channels,
-					 n_ssids,
-					 cfg->channels_5,
-					 NL80211_BAND_5GHZ,
-					 true, true,
-					 cfg->passive[1],
-					 wl->max_channels_5,
-					 &n_pactive_ch,
-					 scan_type);
-	cfg->active[1] =
-		wlcore_scan_get_channels(wl,
-					 channels,
-					 n_channels,
-					 n_ssids,
-					 cfg->channels_5,
-					 NL80211_BAND_5GHZ,
-					 false, false,
-					 cfg->passive[1] + cfg->dfs,
-					 wl->max_channels_5,
-					 &n_pactive_ch,
-					 scan_type);
-
-	/* 802.11j channels are not supported yet */
-	cfg->passive[2] = 0;
-	cfg->active[2] = 0;
-
-	cfg->passive_active = n_pactive_ch;
-
-	cc33xx_debug(DEBUG_SCAN, "    2.4GHz: active %d passive %d",
-		     cfg->active[0], cfg->passive[0]);
-	cc33xx_debug(DEBUG_SCAN, "    5GHz: active %d passive %d",
-		     cfg->active[1], cfg->passive[1]);
-	cc33xx_debug(DEBUG_SCAN, "    DFS: %d", cfg->dfs);
-
-	return  cfg->passive[0] || cfg->active[0] ||
-		cfg->passive[1] || cfg->active[1] || cfg->dfs ||
-		cfg->passive[2] || cfg->active[2];
 }
 
-int wlcore_scan(struct cc33xx *wl, struct ieee80211_vif *vif,
-		const u8 *ssid, size_t ssid_len,
-		struct cfg80211_scan_request *req)
+int wlcore_scan(struct cc33xx *wl, struct ieee80211_vif *vif, const u8 *ssid,
+		size_t ssid_len, struct cfg80211_scan_request *req)
 {
 	struct cc33xx_vif *wlvif = cc33xx_vif_to_data(vif);
 
@@ -836,7 +775,7 @@ int wlcore_scan(struct cc33xx *wl, struct ieee80211_vif *vif,
 	return 0;
 }
 
-void wlcore_scan_sched_scan_results(struct cc33xx *wl)
+void inline wlcore_scan_sched_scan_results(struct cc33xx *wl)
 {
 	cc33xx_debug(DEBUG_SCAN, "got periodic scan results");
 
@@ -845,9 +784,8 @@ void wlcore_scan_sched_scan_results(struct cc33xx *wl)
 
 void cc33xx_scan_completed(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 {
-	cc33xx_debug(DEBUG_SCAN, "calling scan complete!");
 	wl->scan.failed = false;
 	cancel_delayed_work(&wl->scan_complete_work);
 	ieee80211_queue_delayed_work(wl->hw, &wl->scan_complete_work,
 				     msecs_to_jiffies(0));
-}
+}
\ No newline at end of file
diff --git a/drivers/net/wireless/ti/cc33xx/scan.h b/drivers/net/wireless/ti/cc33xx/scan.h
index 9b0098b161a5..44433339f4ec 100644
--- a/drivers/net/wireless/ti/cc33xx/scan.h
+++ b/drivers/net/wireless/ti/cc33xx/scan.h
@@ -14,6 +14,7 @@
 
 #define CC33XX_SCAN_TIMEOUT    30000 /* msec */
 
+
 enum {
 	CC33XX_SCAN_STATE_IDLE,
 	CC33XX_SCAN_STATE_2GHZ_ACTIVE,
@@ -42,31 +43,12 @@ enum {
 	SCAN_SSID_TYPE_HIDDEN = 1,
 };
 
-
-struct tracking_ch_params {
-	struct conn_scan_ch_params channel;
-
-	__le32 bssid_lsb;
-	__le16 bssid_msb;
-
-	u8 padding[2];
-} __packed;
-
-
 #define MAX_CHANNELS_2GHZ	14
 #define MAX_CHANNELS_4GHZ	4
 #define MAX_CHANNELS_5GHZ	32
 
 #define SCAN_MAX_CYCLE_INTERVALS 16
-
-/* The FW intervals can take up to 16 entries.
- * The 1st entry isn't used (scan is immediate). The last
- * entry should be used for the long_interval
- */
-#define SCAN_MAX_SHORT_INTERVALS (SCAN_MAX_CYCLE_INTERVALS - 2)
 #define SCAN_MAX_BANDS 3
-
-
 #define SCHED_SCAN_MAX_SSIDS 16
 
 /******************************************************************************
@@ -75,20 +57,17 @@ struct tracking_ch_params {
 * ** ***                                                               *** ** *
 *******************************************************************************/
 
-#define CONN_SCAN_MAX_NUMBER_OF_SSID_ENTRIES        (16)
 #define CONN_SCAN_MAX_BAND                          (2)
 #define CONN_SCAN_MAX_CHANNELS_ALL_BANDS            (46)
-
-// Maximum number of supported scan plans for scheduled scan, supported by the driver
 #define SCAN_MAX_SCHED_SCAN_PLANS           (12)
 
 typedef enum
 {
-    SCAN_REQUEST_NONE,
-    SCAN_REQUEST_CONNECT_PERIODIC_SCAN,
-    SCAN_REQUEST_ONE_SHOT,
-    SCAN_REQUEST_SURVEY_SCAN,
-    SCAN_NUM_OF_REQUEST_TYPE
+	SCAN_REQUEST_NONE,
+	SCAN_REQUEST_CONNECT_PERIODIC_SCAN,
+	SCAN_REQUEST_ONE_SHOT,
+	SCAN_REQUEST_SURVEY_SCAN,
+	SCAN_NUM_OF_REQUEST_TYPE
 } EScanRequestType;
 
 /******************************************************************************
@@ -106,14 +85,12 @@ typedef enum
 *
 * @ssid: SSID
 */
- struct cc33xx_ssid
+struct cc33xx_ssid
 {
-    u8 type;
+	u8 type;
 	u8 len;
 	u8 ssid[IEEE80211_MAX_SSID_LEN];
-
-    u8 padding[2];
-
+	u8 padding[2];
 } __packed;
 
 /**
@@ -127,13 +104,13 @@ typedef enum
 */
 struct cc33xx_cmd_ssid_list
 {
-    struct cc33xx_cmd_header header;
+	struct cc33xx_cmd_header header;
 
-    u8 role_id;
-    u8 scan_type;
+	u8 role_id;
+	u8 scan_type;
 	u8 n_ssids;
-    struct cc33xx_ssid ssids[SCHED_SCAN_MAX_SSIDS];
-    u8 padding;
+	struct cc33xx_ssid ssids[SCHED_SCAN_MAX_SSIDS];
+	u8 padding;
 }__packed;
 
 /**
@@ -147,9 +124,9 @@ struct cc33xx_cmd_ssid_list
 */
 struct conn_scan_dwell_info
 {
-    __le16  min_duration;
-    __le16  max_duration;
-    __le16  passive_duration;
+	__le16  min_duration;
+	__le16  max_duration;
+	__le16  passive_duration;
 } __packed ;
 
 /**
@@ -163,9 +140,9 @@ struct conn_scan_dwell_info
 */
 struct conn_scan_ch_info
 {
-    u8   channel;
-    u8   tx_power_att;
-    u8   flags;
+	u8   channel;
+	u8   tx_power_att;
+	u8   flags;
 } __packed;
 
 /**
@@ -189,14 +166,13 @@ struct conn_scan_ch_info
 */
 struct scan_one_shot_info
 {
-    u8  passive[CONN_SCAN_MAX_BAND];
-    u8  active[CONN_SCAN_MAX_BAND];
-    u8  dfs;
-
-    struct conn_scan_ch_info    channel_list[ CONN_SCAN_MAX_CHANNELS_ALL_BANDS ];
-    struct conn_scan_dwell_info dwell_info[CONN_SCAN_MAX_BAND];
-    u8  reserved;
+	u8  passive[CONN_SCAN_MAX_BAND];
+	u8  active[CONN_SCAN_MAX_BAND];
+	u8  dfs;
 
+	struct conn_scan_ch_info    channel_list[ CONN_SCAN_MAX_CHANNELS_ALL_BANDS ];
+	struct conn_scan_dwell_info dwell_info[CONN_SCAN_MAX_BAND];
+	u8  reserved;
 };
 
 /**
@@ -212,9 +188,10 @@ struct scan_one_shot_info
  * iterations.
  */
 struct sched_scan_plan_cmd {
-     u32 interval; /* In seconds */
-     u32 iterations; /* Zero to run infinitely */
+	u32 interval; /* In seconds */
+	u32 iterations; /* Zero to run infinitely */
  } ;
+
  /**
  * struct periodicScanParams_t - Periodic scan param
  *
@@ -239,16 +216,15 @@ struct sched_scan_plan_cmd {
 */
 struct scan_periodic_info
 {
-    struct sched_scan_plan_cmd  sched_scan_plans[SCAN_MAX_SCHED_SCAN_PLANS];
-    u16 sched_scan_plans_num;
+	struct sched_scan_plan_cmd  sched_scan_plans[SCAN_MAX_SCHED_SCAN_PLANS];
+	u16 sched_scan_plans_num;
 
-    u8 passive[CONN_SCAN_MAX_BAND];
-    u8 active[CONN_SCAN_MAX_BAND];
-    u8 dfs;
-
-    struct conn_scan_ch_info      channel_list[ CONN_SCAN_MAX_CHANNELS_ALL_BANDS ];
-    struct conn_scan_dwell_info   dwell_info[CONN_SCAN_MAX_BAND];
+	u8 passive[CONN_SCAN_MAX_BAND];
+	u8 active[CONN_SCAN_MAX_BAND];
+	u8 dfs;
 
+	struct conn_scan_ch_info      channel_list[ CONN_SCAN_MAX_CHANNELS_ALL_BANDS ];
+	struct conn_scan_dwell_info   dwell_info[CONN_SCAN_MAX_BAND];
 }__packed;
 
 /**
@@ -260,11 +236,11 @@ struct scan_periodic_info
 */
 struct scan_param
 {
-    union
-    {
-        struct scan_one_shot_info    one_shot;
-        struct scan_periodic_info    periodic;
-    } u;
+	union
+	{
+		struct scan_one_shot_info    one_shot;
+		struct scan_periodic_info    periodic;
+	} u;
 }__packed;
 
 /**
@@ -280,6 +256,8 @@ struct scan_param
  *
  * @snr_threshold:      SNR threshold for basic filter
  *
+ * @bssid:              BSSID to scan for
+ *
  * @ssid_from_list:     0 - if there are more than 5 SSIDs entries, (list was sent SSID CONFIGURE COMMAND),
  * 						1 - 5 or less SSIDs entries, the list is at the end of the scan command
  *
@@ -289,20 +267,23 @@ struct scan_param
  * @num_of_ssids: 		Number of SSIDs
 */
 struct cc33xx_cmd_scan_params{
-    struct cc33xx_cmd_header header;
-    u8 scan_type;
-    u8 role_id;
+	struct cc33xx_cmd_header header;
+	u8 scan_type;
+	u8 role_id;
 
-    struct scan_param   params;
-    s8 rssi_threshold; /* for filtering (in dBm) */
-    s8 snr_threshold;  /* for filtering (in dB) */
+	struct scan_param   params;
+	s8 rssi_threshold; /* for filtering (in dBm) */
+	s8 snr_threshold;  /* for filtering (in dB) */
 
-    u8 ssid_from_list; /* use ssid from configured ssid list */
-    u8 filter;         /* forward only results with matching ssids */
+	u8 bssid[ETH_ALEN];
+	u8 padding[2];
 
-    u8 num_of_ssids;
+	u8 ssid_from_list; /* use ssid from configured ssid list */
+	u8 filter;         /* forward only results with matching ssids */
 
+	u8 num_of_ssids;
 } __packed;
+
 /******************************************************************************
         ID:     CMD_SET_PROBE_IE
         Desc:   This command will  set the Info elements data for
@@ -322,12 +303,13 @@ struct cc33xx_cmd_scan_params{
  * @len:          info element length
 */
 struct cc33xx_cmd_set_ies{
-    struct cc33xx_cmd_header header;
-    u8 scan_type;
-    u8 role_id;
-    __le16 len;
-    u8                   data[MAX_EXTRA_IES_LEN];
+	struct cc33xx_cmd_header header;
+	u8 scan_type;
+	u8 role_id;
+	__le16 len;
+	u8                   data[MAX_EXTRA_IES_LEN];
 } __packed;
+
 /******************************************************************************
         ID:     CMD_STOP_SCAN
         Desc:   This command will stop scan process depending scan request
@@ -344,12 +326,12 @@ struct cc33xx_cmd_set_ies{
  * @is_ET:               TRUE - Early termination is on, FALSE - no ET
 */
 struct cc33xx_cmd_scan_stop {
-    struct cc33xx_cmd_header header;
+	struct cc33xx_cmd_header header;
 
-    u8 scan_type;
-    u8 role_id;
-    u8 is_ET;
-    u8 padding;
+	u8 scan_type;
+	u8 role_id;
+	u8 is_ET;
+	u8 padding;
 } __packed;
 
 
@@ -373,12 +355,6 @@ enum {
 	SCAN_SSID_FILTER_DISABLED = 3
 };
 
-enum {
-	SCAN_BSS_TYPE_INDEPENDENT,
-	SCAN_BSS_TYPE_INFRASTRUCTURE,
-	SCAN_BSS_TYPE_ANY,
-};
-
 #define SCAN_CHANNEL_FLAGS_DFS		BIT(0) /* channel is passive until an
 						  activity is detected on it */
 #define SCAN_CHANNEL_FLAGS_DFS_ENABLED	BIT(1)
@@ -400,12 +376,4 @@ enum {
 	SCAN_TYPE_TRACKING	= 2,
 };
 
-bool
-wlcore_set_scan_chan_params(struct cc33xx *wl,
-			    struct wlcore_scan_channels *cfg,
-			    struct ieee80211_channel *channels[],
-			    u32 n_channels,
-			    u32 n_ssids,
-			    int scan_type);
-
 #endif /* __CC33XX_SCAN_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/sdio.c b/drivers/net/wireless/ti/cc33xx/sdio.c
index 2e5a2325e550..6314e681551e 100644
--- a/drivers/net/wireless/ti/cc33xx/sdio.c
+++ b/drivers/net/wireless/ti/cc33xx/sdio.c
@@ -7,26 +7,16 @@
  * Contact: Luciano Coelho <luciano.coelho@nokia.com>
  */
 
-#include <linux/irq.h>
-#include <linux/module.h>
-#include <linux/vmalloc.h>
-#include <linux/platform_device.h>
-#include <linux/mmc/sdio.h>
 #include <linux/mmc/sdio_func.h>
-#include <linux/mmc/sdio_ids.h>
-#include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
 #include <linux/gpio.h>
 #include <linux/pm_runtime.h>
-#include <linux/printk.h>
-#include <linux/of.h>
-#include <linux/of_gpio.h>
 #include <linux/of_irq.h>
 
 #include "wlcore.h"
-#include "cc33xx_80211.h"
 #include "io.h"
 
+
 #ifndef SDIO_VENDOR_ID_TI
 #define SDIO_VENDOR_ID_TI		0x0097
 #endif
@@ -83,15 +73,12 @@ static int __must_check cc33xx_sdio_raw_read(struct device *child, int addr,
 	struct cc33xx_sdio_glue *glue = dev_get_drvdata(child->parent);
 	struct sdio_func *func = dev_to_sdio_func(glue->dev);
 
-
 	sdio_claim_host(func);
 
-
 	if (unlikely(addr == HW_ACCESS_ELP_CTRL_REG)) {
 		((u8 *)buf)[0] = sdio_f0_readb(func, addr, &ret);
 		dev_dbg(child->parent, "sdio read 52 addr 0x%x, byte 0x%02x\n",
 			addr, ((u8 *)buf)[0]);
-
 	} else {
 		if (fixed)
 			ret = sdio_readsb(func, buf, addr, len);
@@ -100,7 +87,6 @@ static int __must_check cc33xx_sdio_raw_read(struct device *child, int addr,
 
 		dev_dbg(child->parent, "sdio read 53 addr 0x%x, %zu bytes\n",
 			addr, len);
-
 	}
 
 	sdio_release_host(func);
@@ -111,8 +97,7 @@ static int __must_check cc33xx_sdio_raw_read(struct device *child, int addr,
 	if (unlikely(dump)) {
 		printk(KERN_DEBUG "wlcore_sdio: READ from 0x%04x\n", addr);
 		print_hex_dump(KERN_DEBUG, "wlcore_sdio: READ ",
-			       DUMP_PREFIX_OFFSET, 16, 1,
-			       buf, len, false);
+			       DUMP_PREFIX_OFFSET, 16, 1, buf, len, false);
 	}
 
 	return ret;
@@ -129,10 +114,11 @@ static int __must_check cc33xx_sdio_raw_write(struct device *child, int addr,
 
 	if (unlikely(dump)) {
 		printk(KERN_DEBUG "wlcore_sdio: "
-			"WRITE to 0x%04x length 0x%x (first 64 Bytes):\n", addr, len);
+		       "WRITE to 0x%04x length 0x%x (first 64 Bytes):\n",
+		       addr, len);
 		print_hex_dump(KERN_DEBUG, "wlcore_sdio: WRITE ",
-				DUMP_PREFIX_OFFSET, 16, 1,
-				buf, min(len, (size_t)64), false);
+			       DUMP_PREFIX_OFFSET,16, 1, buf,
+			       min(len, (size_t)64), false);
 	}
 
 	if (unlikely(addr == HW_ACCESS_ELP_CTRL_REG)) {
@@ -203,12 +189,11 @@ static int cc33xx_sdio_set_power(struct device *child, bool enable)
 		return cc33xx_sdio_power_off(glue);
 }
 
-
 /**
  *	inband_irq_handler - Called from the MMC subsystem when the
  *	function's IRQ is signaled.
  *	@func: an SDIO function of the card
-
+ *
  *	Note that the host is already claimed when handler is invoked.
  */
 static void inband_irq_handler(struct sdio_func *func)
@@ -270,7 +255,7 @@ static void cc33xx_disable_line_irq(struct device *child)
 	struct platform_device *pdev = glue->core;
 	struct wlcore_platdev_data *pdev_data = dev_get_platdata(&pdev->dev);
 
-	disable_irq(pdev_data->gpio_irq_num);
+	disable_irq_nosync(pdev_data->gpio_irq_num);
 }
 
 static void cc33xx_set_irq_handler(struct device *child, void* handler)
@@ -282,7 +267,6 @@ static void cc33xx_set_irq_handler(struct device *child, void* handler)
 	pdev_data->irq_handler = handler;
 }
 
-
 static struct cc33xx_if_operations sdio_ops_gpio_irq = {
 	.interface_claim	= cc33xx_sdio_claim,
 	.interface_release 	= cc33xx_sdio_release,
@@ -308,7 +292,6 @@ static struct cc33xx_if_operations sdio_ops_inband_irq = {
 };
 
 #ifdef CONFIG_OF
-
 static const struct cc33xx_family_data cc33xx_data = {
 	.name = "cc33xx",
 	.cfg_name = "ti-connectivity/cc33xx-conf.bin",
@@ -336,12 +319,6 @@ static int wlcore_probe_of(struct device *dev, int *irq, int *wakeirq,
 
 	*wakeirq = irq_of_parse_and_map(np, 1);
 
-	/* optional clock frequency params */
-	of_property_read_u32(np, "ref-clock-frequency",
-			     &pdev_data->ref_clock_freq);
-	of_property_read_u32(np, "tcxo-clock-frequency",
-			     &pdev_data->tcxo_clock_freq);
-
 	return 0;
 }
 #else
@@ -350,7 +327,7 @@ static int wlcore_probe_of(struct device *dev, int *irq, int *wakeirq,
 {
 	return -ENODATA;
 }
-#endif
+#endif /* CONFIG_OF */
 
 static irqreturn_t gpio_irq_hard_handler(int irq, void *cookie)
 {
@@ -437,9 +414,9 @@ static int sdio_cc33xx_probe(struct sdio_func *func,
 		if (irq_flags & (IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW))
 			irq_flags |= IRQF_ONESHOT;
 
-		ret = request_threaded_irq(
-			gpio_irq, gpio_irq_hard_handler, gpio_irq_thread_handler,
-			irq_flags, glue->core->name, func);
+		ret = request_threaded_irq(gpio_irq, gpio_irq_hard_handler,
+					   gpio_irq_thread_handler,
+					   irq_flags, glue->core->name, func);
 		if (ret) {
 			dev_err(glue->dev, "can't register GPIO IRQ handler\n");
 			goto out_dev_put;
@@ -447,7 +424,8 @@ static int sdio_cc33xx_probe(struct sdio_func *func,
 
 		pdev_data->gpio_irq_num = gpio_irq;
 
-		if ((mmcflags & MMC_PM_KEEP_POWER) && (enable_irq_wake(gpio_irq)==0))
+		if ((mmcflags & MMC_PM_KEEP_POWER) &&
+		    (enable_irq_wake(gpio_irq)==0))
 			pdev_data->pwr_in_suspend = true;
 
 		pdev_data->if_ops = &sdio_ops_gpio_irq;
@@ -506,7 +484,8 @@ static void sdio_cc33xx_remove(struct sdio_func *func)
 
 	if (pdev_data->gpio_irq_num){
 		free_irq(pdev_data->gpio_irq_num, func);
-		disable_irq_wake(pdev_data->gpio_irq_num);
+		if (pdev_data->pwr_in_suspend)
+			disable_irq_wake(pdev_data->gpio_irq_num);
 	}
 	else{
 		sdio_claim_host(func);
@@ -566,19 +545,24 @@ static const struct dev_pm_ops cc33xx_sdio_pm_ops = {
 	.suspend	= cc33xx_suspend,
 	.resume		= cc33xx_resume,
 };
-#endif
 
 static struct sdio_driver cc33xx_sdio_driver = {
 	.name		= "cc33xx_sdio",
 	.id_table	= cc33xx_devices,
 	.probe		= sdio_cc33xx_probe,
 	.remove		= sdio_cc33xx_remove,
-#ifdef CONFIG_PM
 	.drv = {
 		.pm = &cc33xx_sdio_pm_ops,
 	},
-#endif
 };
+#else
+static struct sdio_driver cc33xx_sdio_driver = {
+	.name		= "cc33xx_sdio",
+	.id_table	= cc33xx_devices,
+	.probe		= sdio_cc33xx_probe,
+	.remove		= sdio_cc33xx_remove,
+};
+#endif /* CONFIG_PM */
 
 static int __init sdio_cc33xx_init(void)
 {
diff --git a/drivers/net/wireless/ti/cc33xx/spi.c b/drivers/net/wireless/ti/cc33xx/spi.c
index c2a9e39f33d0..258ac895bcdc 100644
--- a/drivers/net/wireless/ti/cc33xx/spi.c
+++ b/drivers/net/wireless/ti/cc33xx/spi.c
@@ -7,48 +7,40 @@
  * Contact: Luciano Coelho <luciano.coelho@nokia.com>
  */
 
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/swab.h>
 #include <linux/crc7.h>
 #include <linux/spi/spi.h>
-#include <linux/wl12xx.h>
-#include <linux/platform_device.h>
-#include <linux/of_gpio.h>
 #include <linux/of_irq.h>
 #include <linux/regulator/consumer.h>
 
 #include "wlcore.h"
-#include "cc33xx_80211.h"
 #include "io.h"
 
-#define WSPI_CMD_READ			0x40000000
-#define WSPI_CMD_WRITE			0x00000000
-#define WSPI_CMD_FIXED			0x20000000
-#define WSPI_CMD_BYTE_LENGTH		0x1FFE0000
-#define WSPI_CMD_BYTE_LENGTH_OFFSET	17
-#define WSPI_CMD_BYTE_ADDR		0x0001FFFF
-
-#define WSPI_INIT_CMD_CRC_LEN		5
-
-#define WSPI_INIT_CMD_START		0x00
-#define WSPI_INIT_CMD_TX		0x40
-/* the extra bypass bit is sampled by the TNET as '1' */
-#define WSPI_INIT_CMD_BYPASS_BIT	0x80
-#define WSPI_INIT_CMD_FIXEDBUSY_LEN	0x07
-#define WSPI_INIT_CMD_EN_FIXEDBUSY	0x80
-#define WSPI_INIT_CMD_DIS_FIXEDBUSY	0x00
-#define WSPI_INIT_CMD_OPS		0x08
-#define WSPI_INIT_CMD_IOD		0x40
-#define WSPI_INIT_CMD_IP		0x20
-#define WSPI_INIT_CMD_CS		0x10
-#define WSPI_INIT_CMD_WS		0x08
-#define WSPI_INIT_CMD_WSPI		0x01
-#define WSPI_INIT_CMD_END		0x01
-
-#define WSPI_INIT_CMD_LEN		8
+
+enum {
+	WSPI_CMD_READ				= 0x40000000,
+	WSPI_CMD_WRITE				= 0x00000000,
+	WSPI_CMD_FIXED				= 0x20000000,
+	WSPI_CMD_BYTE_LENGTH		= 0x1FFE0000,
+	WSPI_CMD_BYTE_LENGTH_OFFSET	= 17,
+	WSPI_CMD_BYTE_ADDR			= 0x0001FFFF
+};
+
+enum {
+	WSPI_INIT_CMD_CRC_LEN		= 5,
+	WSPI_INIT_CMD_START			= 0x00,
+	WSPI_INIT_CMD_TX			= 0x40,
+	WSPI_INIT_CMD_FIXEDBUSY_LEN	= 0x07,
+	WSPI_INIT_CMD_EN_FIXEDBUSY	= 0x80,
+	WSPI_INIT_CMD_DIS_FIXEDBUSY	= 0x00,
+	WSPI_INIT_CMD_OPS			= 0x08,
+	WSPI_INIT_CMD_IOD			= 0x40,
+	WSPI_INIT_CMD_IP			= 0x20,
+	WSPI_INIT_CMD_CS			= 0x10,
+	WSPI_INIT_CMD_WS			= 0x08,
+	WSPI_INIT_CMD_WSPI			= 0x01,
+	WSPI_INIT_CMD_END			= 0x01,
+	WSPI_INIT_CMD_LEN			= 8,
+};
 
 #define HW_ACCESS_WSPI_FIXED_BUSY_LEN \
 		((CC33XX_BUSY_WORD_LEN - 4) / sizeof(u32))
@@ -58,17 +50,6 @@
 /* Actual size will have to be 32 bit aligned */
 #define WSPI_MAX_CHUNK_SIZE		4092
 
-/*
- * wl18xx driver aggregation buffer size is (13 * 4K) compared to
- * (4 * 4K) for wl12xx, so use the larger buffer needed for wl18xx
- */
-#define SPI_AGGR_BUFFER_SIZE (13 * SZ_4K)
-
-/* Maximum number of SPI write chunks */
-#define WSPI_MAX_NUM_OF_CHUNKS \
-	((SPI_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE) + 1)
-
-
 static const struct cc33xx_family_data cc33xx_data = {
 	.name = "cc33xx",
 	.cfg_name = "ti-connectivity/cc33xx-conf.bin",
@@ -409,16 +390,10 @@ static int __cc33xx_spi_raw_write(struct device *child, int addr,
 	return ret;
 }
 
-static int __must_check cc33xx_spi_raw_write(struct device *child, int addr,
-					     void *buf, size_t len, bool fixed)
+static inline int __must_check cc33xx_spi_raw_write(struct device *child,
+						    int addr, void *buf,
+						    size_t len, bool fixed)
 {
-	/* The ELP wakeup write may fail the first time due to internal
-	 * hardware latency. It is safer to send the wakeup command twice to
-	 * avoid unexpected failures.
-	 */
-	if (addr == HW_ACCESS_ELP_CTRL_REG)
-		__cc33xx_spi_raw_write(child, addr, buf, len, fixed);
-
 	return __cc33xx_spi_raw_write(child, addr, buf, len, fixed);
 }
 
@@ -576,11 +551,6 @@ static int wlcore_probe_of(struct spi_device *spi, struct cc33xx_spi_glue *glue,
 
 	if (of_find_property(dt_node, "clock-xtal", NULL))
 		pdev_data->ref_clock_xtal = true;
-	/* optional clock frequency params */
-	of_property_read_u32(dt_node, "ref-clock-frequency",
-			     &pdev_data->ref_clock_freq);
-	of_property_read_u32(dt_node, "tcxo-clock-frequency",
-			     &pdev_data->tcxo_clock_freq);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/ti/cc33xx/sysfs.c b/drivers/net/wireless/ti/cc33xx/sysfs.c
index 6d99ba839aaa..2c8cf0829c25 100644
--- a/drivers/net/wireless/ti/cc33xx/sysfs.c
+++ b/drivers/net/wireless/ti/cc33xx/sysfs.c
@@ -1,13 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * This file is part of wlcore
+ * This file is part of cc33xx
  *
  * Copyright (C) 2013 Texas Instruments Inc.
  */
 
 #include "acx.h"
-#include "wlcore.h"
-#include "debug.h"
 #include "sysfs.h"
 
 
@@ -52,7 +50,6 @@ int wlcore_sysfs_init(struct cc33xx *wl)
 {
 	int ret;
 
-
 	/* Create sysfs file for the FW log */
 	ret = device_create_bin_file(wl->dev, &fwlog_attr);
 	if (ret < 0) {
diff --git a/drivers/net/wireless/ti/cc33xx/sysfs.h b/drivers/net/wireless/ti/cc33xx/sysfs.h
index cd346177959c..47afb8223663 100644
--- a/drivers/net/wireless/ti/cc33xx/sysfs.h
+++ b/drivers/net/wireless/ti/cc33xx/sysfs.h
@@ -8,7 +8,9 @@
 #ifndef __SYSFS_H__
 #define __SYSFS_H__
 
+
 int wlcore_sysfs_init(struct cc33xx *wl);
 void wlcore_sysfs_free(struct cc33xx *wl);
 
-#endif
+
+#endif /* __SYSFS_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/testmode.c b/drivers/net/wireless/ti/cc33xx/testmode.c
index 809c812b8903..5e282f4505d0 100644
--- a/drivers/net/wireless/ti/cc33xx/testmode.c
+++ b/drivers/net/wireless/ti/cc33xx/testmode.c
@@ -6,15 +6,14 @@
  *
  * Contact: Luciano Coelho <luciano.coelho@nokia.com>
  */
-#include "testmode.h"
 
-#include <linux/slab.h>
+
 #include <net/genetlink.h>
 
 #include "wlcore.h"
-#include "debug.h"
 #include "acx.h"
 #include "io.h"
+#include "testmode.h"
 
 #define CC33XX_TM_MAX_DATA_LENGTH 1024
 
@@ -42,6 +41,7 @@ enum cc33xx_tm_attrs {
 
 	__CC33XX_TM_ATTR_AFTER_LAST
 };
+
 #define CC33XX_TM_ATTR_MAX (__CC33XX_TM_ATTR_AFTER_LAST - 1)
 
 static struct nla_policy cc33xx_tm_policy[CC33XX_TM_ATTR_MAX + 1] = {
@@ -53,7 +53,6 @@ static struct nla_policy cc33xx_tm_policy[CC33XX_TM_ATTR_MAX + 1] = {
 	[CC33XX_TM_ATTR_PLT_MODE] =	{ .type = NLA_U32 },
 };
 
-
 static int cc33xx_tm_cmd_test(struct cc33xx *wl, struct nlattr *tb[])
 {
 	int buf_len, ret, len;
@@ -95,7 +94,8 @@ static int cc33xx_tm_cmd_test(struct cc33xx *wl, struct nlattr *tb[])
 		s16 radio_status = (s16) le16_to_cpu(params->radio_status);
 
 		if (params->test.id == TEST_CMD_P2G_CAL && radio_status < 0)
-			cc33xx_warning("testmode cmd: radio status=%d", radio_status);
+			cc33xx_warning("testmode cmd: radio status=%d",
+				       radio_status);
 		else
 			cc33xx_info("testmode cmd: radio status=%d",
 					radio_status);
@@ -307,7 +307,8 @@ static int cc33xx_tm_cmd_get_mac(struct cc33xx *wl, struct nlattr *tb[])
 		goto out;
 	}
 
-	if (nla_put(skb, CC33XX_TM_ATTR_DATA, ETH_ALEN, wl->efuse_mac_address)) {
+	if (nla_put(skb, CC33XX_TM_ATTR_DATA,
+		    ETH_ALEN, wl->efuse_mac_address)) {
 		kfree_skb(skb);
 		ret = -EMSGSIZE;
 		goto out;
diff --git a/drivers/net/wireless/ti/cc33xx/testmode.h b/drivers/net/wireless/ti/cc33xx/testmode.h
index f650db7ee83e..c5927d7221df 100644
--- a/drivers/net/wireless/ti/cc33xx/testmode.h
+++ b/drivers/net/wireless/ti/cc33xx/testmode.h
@@ -10,9 +10,9 @@
 #ifndef __TESTMODE_H__
 #define __TESTMODE_H__
 
-#include <net/mac80211.h>
 
 int cc33xx_tm_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		  void *data, int len);
 
-#endif /* __WL1271_TESTMODE_H__ */
+
+#endif /* __TESTMODE_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/tx.c b/drivers/net/wireless/ti/cc33xx/tx.c
index 0464f55b960d..04757d036aa3 100644
--- a/drivers/net/wireless/ti/cc33xx/tx.c
+++ b/drivers/net/wireless/ti/cc33xx/tx.c
@@ -7,23 +7,13 @@
  * Contact: Luciano Coelho <luciano.coelho@nokia.com>
  */
 
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/etherdevice.h>
-#include <linux/spinlock.h>
-
-#include "wlcore.h"
+#include "acx.h"
 #include "debug.h"
 #include "io.h"
 #include "ps.h"
 #include "tx.h"
-#include "event.h"
+#include "wlcore.h"
 
-/*
- * TODO: this is here just for now, it must be removed when the data
- * operations are in place.
- */
-#include "../wl12xx/reg.h"
 
 static int cc33xx_set_default_wep_key(struct cc33xx *wl,
 				      struct cc33xx_vif *wlvif, u8 id)
@@ -48,27 +38,29 @@ static int cc33xx_alloc_tx_id(struct cc33xx *wl, struct sk_buff *skb)
 {
 	int id;
 
-	id = find_first_zero_bit(wl->tx_frames_map, wl->num_tx_desc);
-	if (id >= wl->num_tx_desc)
+	id = find_first_zero_bit(wl->tx_frames_map, CC33XX_NUM_TX_DESCRIPTORS);
+	if (id >= CC33XX_NUM_TX_DESCRIPTORS)
 		return -EBUSY;
 
 	__set_bit(id, wl->tx_frames_map);
 	wl->tx_frames[id] = skb;
 	wl->tx_frames_cnt++;
-	cc33xx_debug(DEBUG_TX, "alloc desc ID. id - %d, frames count %d",id,wl->tx_frames_cnt);
+	cc33xx_debug(DEBUG_TX, "alloc desc ID. id - %d, frames count %d",
+		     id, wl->tx_frames_cnt);
 	return id;
 }
 
 void cc33xx_free_tx_id(struct cc33xx *wl, int id)
 {
 	if (__test_and_clear_bit(id, wl->tx_frames_map)) {
-		if (unlikely(wl->tx_frames_cnt == wl->num_tx_desc))
+		if (unlikely(wl->tx_frames_cnt == CC33XX_NUM_TX_DESCRIPTORS))
 			clear_bit(CC33XX_FLAG_FW_TX_BUSY, &wl->flags);
 
 		wl->tx_frames[id] = NULL;
 		wl->tx_frames_cnt--;
 	}
-	cc33xx_debug(DEBUG_TX, "free desc ID. id - %d, frames count %d",id,wl->tx_frames_cnt);
+	cc33xx_debug(DEBUG_TX, "free desc ID. id - %d, frames count %d",
+		     id, wl->tx_frames_cnt);
 
 }
 EXPORT_SYMBOL(cc33xx_free_tx_id);
@@ -100,7 +92,7 @@ static void cc33xx_tx_ap_update_inconnection_sta(struct cc33xx *wl,
 	wlvif->pending_auth_reply_time = jiffies;
 	cancel_delayed_work(&wlvif->pending_auth_complete_work);
 	ieee80211_queue_delayed_work(wl->hw,
-				&wlvif->pending_auth_complete_work,
+				     &wlvif->pending_auth_complete_work,
 				msecs_to_jiffies(WLCORE_PEND_AUTH_ROC_TIMEOUT));
 }
 
@@ -132,7 +124,7 @@ static void cc33xx_tx_regulate_link(struct cc33xx *wl,
 		cc33xx_ps_link_start(wl, wlvif, hlid, true);
 }
 
-bool cc33xx_is_dummy_packet(struct cc33xx *wl, struct sk_buff *skb)
+inline bool cc33xx_is_dummy_packet(struct cc33xx *wl, struct sk_buff *skb)
 {
 	return wl->dummy_packet == skb;
 }
@@ -190,25 +182,25 @@ EXPORT_SYMBOL(wlcore_calc_packet_alignment);
 
 static u32 cc33xx_calc_tx_blocks(struct cc33xx *wl, u32 len, u32 spare_blks)
 {
-    u32 blk_size = CC33XX_TX_HW_BLOCK_SIZE;
-    /* In CC33xx the packet will be stored along with its internal descriptor.
-     * the descriptor is not part of the host transaction, but should be considered as part of
-     * the allocate memory blocks in the device
-     */
-    len = len + CC33xx_INTERNAL_DESC_SIZE;
-    return (len + blk_size - 1) / blk_size + spare_blks;
+	u32 blk_size = CC33XX_TX_HW_BLOCK_SIZE;
+	/* In CC33xx the packet will be stored along with its internal descriptor.
+	* the descriptor is not part of the host transaction, but should be
+	* considered as part of the allocate memory blocks in the device
+	*/
+	len = len + CC33xx_INTERNAL_DESC_SIZE;
+	return (len + blk_size - 1) / blk_size + spare_blks;
 }
 
-static void
-cc33xx_set_tx_desc_blocks(struct cc33xx *wl, struct cc33xx_tx_hw_descr *desc,
-			  u32 blks, u32 spare_blks)
+static inline void cc33xx_set_tx_desc_blocks(struct cc33xx *wl,
+					     struct cc33xx_tx_hw_descr *desc,
+					     u32 blks, u32 spare_blks)
 {
 	desc->cc33xx_mem.total_mem_blocks = blks;
 }
 
-static void
-cc33xx_set_tx_desc_data_len(struct cc33xx *wl, struct cc33xx_tx_hw_descr *desc,
-			    struct sk_buff *skb)
+static void cc33xx_set_tx_desc_data_len(struct cc33xx *wl,
+					struct cc33xx_tx_hw_descr *desc,
+					struct sk_buff *skb)
 {
 	desc->length = cpu_to_le16(skb->len);
 
@@ -218,14 +210,12 @@ cc33xx_set_tx_desc_data_len(struct cc33xx *wl, struct cc33xx_tx_hw_descr *desc,
 	else
 		desc->cc33xx_mem.ctrl = 0;
 
-	cc33xx_debug(DEBUG_TX, "tx_fill_hdr: hlid: %d "
-		     "len: %d life: %d mem: %d", desc->hlid,
-		     le16_to_cpu(desc->length),
+	cc33xx_debug(DEBUG_TX,"tx_fill_hdr: hlid: %d  len: %d life: %d mem: %d",
+		     desc->hlid, le16_to_cpu(desc->length),
 		     le16_to_cpu(desc->life_time),
 		     desc->cc33xx_mem.total_mem_blocks);
 }
 
-
 static int cc33xx_get_spare_blocks(struct cc33xx *wl, bool is_gem)
 {
 	/* If we have keys requiring extra spare, indulge them */
@@ -235,35 +225,53 @@ static int cc33xx_get_spare_blocks(struct cc33xx *wl, bool is_gem)
 	return CC33XX_TX_HW_BLOCK_SPARE;
 }
 
+int cc33xx_tx_get_queue(int queue)
+{
+	switch (queue) {
+	case 0:
+		return CONF_TX_AC_VO;
+	case 1:
+		return CONF_TX_AC_VI;
+	case 2:
+		return CONF_TX_AC_BE;
+	case 3:
+		return CONF_TX_AC_BK;
+	default:
+		return CONF_TX_AC_BE;
+	}
+}
 
 static int cc33xx_tx_allocate(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			      struct sk_buff *skb, u32 extra, u32 buf_offset,
-			      u8 hlid, bool is_gem, struct NAB_tx_header *nab_cmd)
+			      u8 hlid, bool is_gem,
+			      struct NAB_tx_header *nab_cmd)
 {
 	struct cc33xx_tx_hw_descr *desc;
-
 	u32 total_blocks;
 	int id, ret = -EBUSY, ac;
 	u32 spare_blocks;
-	u32 total_skb_len = skb->len + sizeof(struct cc33xx_tx_hw_descr) + extra;
-	// Add  NAB command required for CC33xx architecture
-	u32 total_len = total_skb_len + sizeof(struct NAB_tx_header);
+	u32 total_skb_len = skb->len + extra;
+	/* Add NAB command required for CC33xx architecture */
+	u32 total_len = sizeof(struct NAB_tx_header);
 
-    cc33xx_debug(DEBUG_TX,"michal1 wl->tx_blocks_available %d", wl->tx_blocks_available);
+	total_skb_len += sizeof(struct cc33xx_tx_hw_descr);
+	total_len += total_skb_len;
 
-	if (buf_offset + total_len > wl->aggr_buf_size)
-	{
-	    cc33xx_debug(DEBUG_TX,"michal2");
+	cc33xx_debug(DEBUG_TX, "michal1 wl->tx_blocks_available %d",
+		     wl->tx_blocks_available);
 
+	if (buf_offset + total_len > wl->aggr_buf_size) {
+		cc33xx_debug(DEBUG_TX,"michal2");
 		return -EAGAIN;
 	}
+
 	spare_blocks = cc33xx_get_spare_blocks(wl, is_gem);
 
 	/* allocate free identifier for the packet */
 	id = cc33xx_alloc_tx_id(wl, skb);
 	if (id < 0)
 	{
-	    cc33xx_debug(DEBUG_TX,"michal3");
+		cc33xx_debug(DEBUG_TX,"michal3");
 		return id;
 	}
 
@@ -272,33 +280,42 @@ static int cc33xx_tx_allocate(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	cc33xx_debug(DEBUG_TX,"michal1 total blocks %d", total_blocks);
 
 	if (total_blocks <= wl->tx_blocks_available) {
+		/**
+		 * In CC33XX the packet starts with NAB command,
+		 * only then the descriptor.
+		 */
+		nab_cmd->sync = cpu_to_le32(HOST_SYNC_PATTERN);
+		nab_cmd->opcode = cpu_to_le16(NAB_SEND_CMD);
 
-	    // In CC33XX the packet starts with NAB command, only then the descriptor.
-
-	    nab_cmd->sync = cpu_to_le32(HOST_SYNC_PATTERN);
-	    nab_cmd->opcode = cpu_to_le16(NAB_SEND_CMD);
-	    nab_cmd->len = cpu_to_le16(total_len - sizeof(struct NAB_header)); // length should include the following 4 bytes of the NAB comand.
-	    nab_cmd->desc_length = cpu_to_le16(total_len - sizeof(struct NAB_tx_header));
-	    nab_cmd->sd = 0;
-	    nab_cmd->flags = NAB_SEND_FLAGS;
+		/**
+		 * length should include the following 4 bytes
+		 * of the NAB comand.
+		 */
+		nab_cmd->len = cpu_to_le16(total_len -
+						sizeof(struct NAB_header));
+		nab_cmd->desc_length = cpu_to_le16(total_len -
+						sizeof(struct NAB_tx_header));
+		nab_cmd->sd = 0;
+		nab_cmd->flags = NAB_SEND_FLAGS;
 
-	    desc = skb_push(skb, total_skb_len - skb->len);
+		desc = skb_push(skb, total_skb_len - skb->len);
 
 		cc33xx_set_tx_desc_blocks(wl, desc, total_blocks, spare_blocks);
 
 		desc->id = id;
 
-		cc33xx_debug(DEBUG_TX, "tx alocate id %u skb 0x%p tx_memblocks %d",
-		             id, skb,desc->cc33xx_mem.total_mem_blocks);
+		cc33xx_debug(DEBUG_TX,
+			     "tx alocate id %u skb 0x%p tx_memblocks %d",
+			     id, skb, desc->cc33xx_mem.total_mem_blocks);
 
 		wl->tx_blocks_available -= total_blocks;
 		wl->tx_allocated_blocks += total_blocks;
 
 		/*
-		 * If the FW was empty before, arm the Tx watchdog. Also do
-		 * this on the first Tx after resume, as we always cancel the
-		 * watchdog on suspend.
-		 */
+		* If the FW was empty before, arm the Tx watchdog. Also do
+		* this on the first Tx after resume, as we always cancel the
+		* watchdog on suspend.
+		*/
 		if (wl->tx_allocated_blocks == total_blocks ||
 		    test_and_clear_bit(CC33XX_FLAG_REINIT_TX_WDOG, &wl->flags))
 			cc33xx_rearm_tx_watchdog_locked(wl);
@@ -336,7 +353,6 @@ static void cc33xx_tx_fill_hdr(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	u8 *frame_start;
 	bool is_dummy;
 
-
 	desc = (struct cc33xx_tx_hw_descr *) skb->data;
 
 	frame_start = (u8 *)(desc + 1);
@@ -431,7 +447,6 @@ static void cc33xx_tx_fill_hdr(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 
 	desc->tx_attr = cpu_to_le16(tx_attr);
 
-
 	cc33xx_set_tx_desc_data_len(wl, desc, skb);
 }
 
@@ -483,7 +498,9 @@ static int cc33xx_prepare_tx_frame(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 
 		is_gem = (cipher == CC33XX_CIPHER_SUITE_GEM);
 	}
-	extra += IEEE80211_HT_CTL_LEN; // Add 4 bytes gap, may be filled later on by the PMAC.
+
+	/* Add 4 bytes gap, may be filled later on by the PMAC. */
+	extra += IEEE80211_HT_CTL_LEN;
 	ret = cc33xx_tx_allocate(wl, wlvif, skb, extra, buf_offset, hlid,
 				 is_gem, &nab_cmd);
 	cc33xx_debug(DEBUG_TX, "cc33xx_tx_allocate %d", ret);
@@ -511,9 +528,12 @@ static int cc33xx_prepare_tx_frame(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	total_len = wlcore_calc_packet_alignment(wl, skb->len);
 	cc33xx_debug(DEBUG_TX, "wlcore_calc_packet_alignment ");
 
-	memcpy(wl->aggr_buf + buf_offset, &nab_cmd, sizeof(struct NAB_tx_header));
-	memcpy(wl->aggr_buf + buf_offset + sizeof(struct NAB_tx_header), skb->data, skb->len);
-	memset(wl->aggr_buf + buf_offset + sizeof(struct NAB_tx_header) + skb->len, 0, total_len - skb->len);
+	memcpy(wl->aggr_buf + buf_offset,
+	       &nab_cmd, sizeof(struct NAB_tx_header));
+	memcpy(wl->aggr_buf + buf_offset + sizeof(struct NAB_tx_header),
+	       skb->data, skb->len);
+	memset(wl->aggr_buf + buf_offset + sizeof(struct NAB_tx_header)
+		+ skb->len, 0, total_len - skb->len);
 
 	/* Revert side effects in the dummy packet skb, so it can be reused */
 	if (is_dummy)
@@ -548,6 +568,45 @@ u32 cc33xx_tx_enabled_rates_get(struct cc33xx *wl, u32 rate_set,
 	return enabled_rates;
 }
 
+static inline int wlcore_tx_get_mac80211_queue(struct cc33xx_vif *wlvif,
+					       int queue)
+{
+	int mac_queue = wlvif->hw_queue_base;
+
+	switch (queue) {
+	case CONF_TX_AC_VO:
+		return mac_queue + 0;
+	case CONF_TX_AC_VI:
+		return mac_queue + 1;
+	case CONF_TX_AC_BE:
+		return mac_queue + 2;
+	case CONF_TX_AC_BK:
+		return mac_queue + 3;
+	default:
+		return mac_queue + 2;
+	}
+}
+
+static void wlcore_wake_queue(struct cc33xx *wl, struct cc33xx_vif *wlvif,
+			      u8 queue, enum wlcore_queue_stop_reason reason)
+{
+	unsigned long flags;
+	int hwq = wlcore_tx_get_mac80211_queue(wlvif, queue);
+
+	spin_lock_irqsave(&wl->wl_lock, flags);
+
+	/* queue should not be clear for this reason */
+	WARN_ON_ONCE(!test_and_clear_bit(reason, &wl->queue_stop_reasons[hwq]));
+
+	if (wl->queue_stop_reasons[hwq])
+		goto out;
+
+	ieee80211_wake_queue(wl->hw, hwq);
+
+out:
+	spin_unlock_irqrestore(&wl->wl_lock, flags);
+}
+
 void cc33xx_handle_tx_low_watermark(struct cc33xx *wl)
 {
 	int i;
@@ -614,7 +673,6 @@ static struct sk_buff *wlcore_lnk_dequeue(struct cc33xx *wl,
 static bool cc33xx_lnk_high_prio(struct cc33xx *wl, u8 hlid,
 				 struct cc33xx_link *lnk)
 {
-
 	u8 thold;
 	struct core_fw_status * core_fw_status = &wl->core_status->fwInfo;
 	unsigned long suspend_bitmap, fast_bitmap, ps_bitmap;
@@ -628,8 +686,7 @@ static bool cc33xx_lnk_high_prio(struct cc33xx *wl, u8 hlid,
 		return false;
 
 	/* the priority thresholds are taken from FW */
-	if (test_bit(hlid, &fast_bitmap) &&
-		!test_bit(hlid, &ps_bitmap))
+	if (test_bit(hlid, &fast_bitmap) && !test_bit(hlid, &ps_bitmap))
 		thold = core_fw_status->tx_fast_link_prio_threshold;
 	else
 		thold = core_fw_status->tx_slow_link_prio_threshold;
@@ -650,8 +707,7 @@ static bool cc33xx_lnk_low_prio(struct cc33xx *wl, u8 hlid,
 
 	if (test_bit(hlid, &suspend_bitmap))
 		thold = core_fw_status->tx_suspend_threshold;
-	else if (test_bit(hlid, &fast_bitmap) &&
-		 !test_bit(hlid, &ps_bitmap))
+	else if (test_bit(hlid, &fast_bitmap) && !test_bit(hlid, &ps_bitmap))
 		thold = core_fw_status->tx_fast_stop_threshold;
 	else
 		thold = core_fw_status->tx_slow_stop_threshold;
@@ -687,18 +743,17 @@ static struct sk_buff *wlcore_vif_dequeue_high_prio(struct cc33xx *wl,
 	int i, h, start_hlid;
 
 	/* start from the link after the last one */
-	start_hlid = (wlvif->last_tx_hlid + 1) % wl->num_links;
+	start_hlid = (wlvif->last_tx_hlid + 1) % CC33XX_MAX_LINKS;
 
 	/* dequeue according to AC, round robin on each link */
-	for (i = 0; i < wl->num_links; i++) {
-		h = (start_hlid + i) % wl->num_links;
+	for (i = 0; i < CC33XX_MAX_LINKS; i++) {
+		h = (start_hlid + i) % CC33XX_MAX_LINKS;
 
 		/* only consider connected stations */
 		if (!test_bit(h, wlvif->links_map))
 			continue;
 
-		skb = wlcore_lnk_dequeue_high_prio(wl, h, ac,
-						   low_prio_hlid);
+		skb = wlcore_lnk_dequeue_high_prio(wl, h, ac, low_prio_hlid);
 		if (!skb)
 			continue;
 
@@ -815,8 +870,8 @@ static void cc33xx_skb_queue_head(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 		skb_queue_head(&wl->links[hlid].tx_queue[q], skb);
 
 		/* make sure we dequeue the same packet next time */
-		wlvif->last_tx_hlid = (hlid + wl->num_links - 1) %
-				      wl->num_links;
+		wlvif->last_tx_hlid = (hlid + CC33XX_MAX_LINKS - 1) %
+				      CC33XX_MAX_LINKS;
 	}
 
 	spin_lock_irqsave(&wl->wl_lock, flags);
@@ -826,14 +881,14 @@ static void cc33xx_skb_queue_head(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	spin_unlock_irqrestore(&wl->wl_lock, flags);
 }
 
-static bool cc33xx_tx_is_data_present(struct sk_buff *skb)
+static inline bool cc33xx_tx_is_data_present(struct sk_buff *skb)
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)(skb->data);
-
 	return ieee80211_is_data_present(hdr->frame_control);
 }
 
-void cc33xx_rearm_rx_streaming(struct cc33xx *wl, unsigned long *active_hlids)
+static void cc33xx_rearm_rx_streaming(struct cc33xx *wl,
+				      unsigned long *active_hlids)
 {
 	struct cc33xx_vif *wlvif;
 	u32 timeout;
@@ -849,7 +904,7 @@ void cc33xx_rearm_rx_streaming(struct cc33xx *wl, unsigned long *active_hlids)
 	timeout = wl->conf.host_conf.rx_streaming.duration;
 	cc33xx_for_each_wlvif_sta(wl, wlvif) {
 		bool found = false;
-		for_each_set_bit(hlid, active_hlids, wl->num_links) {
+		for_each_set_bit(hlid, active_hlids, CC33XX_MAX_LINKS) {
 			if (test_bit(hlid, wlvif->links_map)) {
 				found  = true;
 				break;
@@ -860,9 +915,10 @@ void cc33xx_rearm_rx_streaming(struct cc33xx *wl, unsigned long *active_hlids)
 			continue;
 
 		/* enable rx streaming */
-		if (!test_bit(WLVIF_FLAG_RX_STREAMING_STARTED, &wlvif->flags))
+		if (!test_bit(WLVIF_FLAG_RX_STREAMING_STARTED, &wlvif->flags)) {
 			ieee80211_queue_work(wl->hw,
 					     &wlvif->rx_streaming_enable_work);
+		}
 
 		mod_timer(&wlvif->rx_streaming_timer,
 			  jiffies + msecs_to_jiffies(timeout));
@@ -893,8 +949,6 @@ int wlcore_tx_work_locked(struct cc33xx *wl)
 	int bus_ret = 0;
 	u8 hlid;
 
-
-
 	cc33xx_debug(DEBUG_TX, " Tx work locked");
 
 	memset(wl->aggr_buf,0,0x300);
@@ -905,16 +959,15 @@ int wlcore_tx_work_locked(struct cc33xx *wl)
 		struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 		bool has_data = false;
 
-		cc33xx_debug(DEBUG_TX, " skb dequeue skb: 0x%p data %#lx head %#lx tail %#lx end %#lx", skb, (unsigned long)skb->data, (unsigned long)skb->head, (unsigned long)skb->tail, (unsigned long)skb->end);
+		cc33xx_debug(DEBUG_TX, "skb dequeue skb: 0x%p data %#lx "
+			     "head %#lx tail %#lx end %#lx", skb,
+			     (unsigned long)skb->data, (unsigned long)skb->head,
+			     (unsigned long)skb->tail,(unsigned long)skb->end);
 		wlvif = NULL;
 		if (!cc33xx_is_dummy_packet(wl, skb))
-		{
 			wlvif = cc33xx_vif_to_data(info->control.vif);
-		}
 		else
-		{
 			hlid = CC33XX_SYSTEM_HLID;
-		}
 
 		has_data = wlvif && cc33xx_tx_is_data_present(skb);
 		ret = cc33xx_prepare_tx_frame(wl, wlvif, skb, buf_offset,
@@ -937,7 +990,7 @@ int wlcore_tx_work_locked(struct cc33xx *wl)
 					transfer_len);
 
 			bus_ret = wlcore_write(wl, NAB_DATA_ADDR, wl->aggr_buf,
-			                       transfer_len, true);
+					       transfer_len, true);
 			if (bus_ret < 0)
 				goto out;
 
@@ -964,6 +1017,7 @@ int wlcore_tx_work_locked(struct cc33xx *wl)
 				ieee80211_free_txskb(wl->hw, skb);
 			goto out_ack;
 		}
+
 		last_len = ret;
 		buf_offset += last_len;
 
@@ -975,7 +1029,6 @@ int wlcore_tx_work_locked(struct cc33xx *wl)
 
 out_ack:
 	if (buf_offset) {
-
 		transfer_len = __ALIGN_MASK(buf_offset,
 						CC33XX_BUS_BLOCK_SIZE*2 - 1);
 
@@ -983,15 +1036,16 @@ int wlcore_tx_work_locked(struct cc33xx *wl)
 		memset(wl->aggr_buf + buf_offset, 0x33, padding_size);
 
 		cc33xx_debug(DEBUG_TX, "sdio transaction (926) length: %d ",
-			transfer_len);
+			     transfer_len);
 
 		bus_ret = wlcore_write(wl, NAB_DATA_ADDR, wl->aggr_buf,
-		                       transfer_len, true);
+				       transfer_len, true);
 		if (bus_ret < 0)
 			goto out;
 
 		sent_packets = true;
 	}
+
 	if (sent_packets)
 		cc33xx_handle_tx_low_watermark(wl);
 
@@ -1060,9 +1114,10 @@ void cc33xx_tx_reset_wlvif(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 	int i;
 
 	/* TX failure */
-	for_each_set_bit(i, wlvif->links_map, wl->num_links) {
-		if (wlvif->bss_type == BSS_TYPE_AP_BSS &&
-		    i != wlvif->ap.bcast_hlid && i != wlvif->ap.global_hlid) {
+	for_each_set_bit(i, wlvif->links_map, CC33XX_MAX_LINKS) {
+		if ((wlvif->bss_type == BSS_TYPE_AP_BSS) &&
+		    (i != wlvif->ap.bcast_hlid) &&
+		    (i != wlvif->ap.global_hlid)) {
 			/* this calls cc33xx_clear_link */
 			cc33xx_free_sta(wl, wlvif, i);
 		} else {
@@ -1070,11 +1125,23 @@ void cc33xx_tx_reset_wlvif(struct cc33xx *wl, struct cc33xx_vif *wlvif)
 			cc33xx_clear_link(wl, wlvif, &hlid);
 		}
 	}
+
 	wlvif->last_tx_hlid = 0;
 
 	for (i = 0; i < NUM_TX_QUEUES; i++)
 		wlvif->tx_queue_count[i] = 0;
 }
+
+int cc33xx_tx_total_queue_count(struct cc33xx *wl)
+{
+	int i, count = 0;
+
+	for (i = 0; i < NUM_TX_QUEUES; i++)
+		count += wl->tx_queue_count[i];
+
+	return count;
+}
+
 /* caller must hold wl->mutex and TX must be stopped */
 void cc33xx_tx_reset(struct cc33xx *wl)
 {
@@ -1084,7 +1151,7 @@ void cc33xx_tx_reset(struct cc33xx *wl)
 
 	/* only reset the queues if something bad happened */
 	if (cc33xx_tx_total_queue_count(wl) != 0) {
-		for (i = 0; i < wl->num_links; i++)
+		for (i = 0; i < CC33XX_MAX_LINKS; i++)
 			cc33xx_tx_reset_link_queues(wl, i);
 
 		for (i = 0; i < NUM_TX_QUEUES; i++)
@@ -1098,7 +1165,7 @@ void cc33xx_tx_reset(struct cc33xx *wl)
 	 */
 	cc33xx_handle_tx_low_watermark(wl);
 
-	for (i = 0; i < wl->num_tx_desc; i++) {
+	for (i = 0; i < CC33XX_NUM_TX_DESCRIPTORS; i++) {
 		if (wl->tx_frames[i] == NULL)
 			continue;
 
@@ -1177,7 +1244,7 @@ void cc33xx_tx_flush(struct cc33xx *wl)
 		       CC33XX_TX_FLUSH_TIMEOUT / 1000);
 
 	/* forcibly flush all Tx buffers on our queues */
-	for (i = 0; i < wl->num_links; i++)
+	for (i = 0; i < CC33XX_MAX_LINKS; i++)
 		cc33xx_tx_reset_link_queues(wl, i);
 
 out_wake:
@@ -1210,36 +1277,6 @@ void wlcore_stop_queue_locked(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	ieee80211_stop_queue(wl->hw, hwq);
 }
 
-void wlcore_stop_queue(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 queue,
-		       enum wlcore_queue_stop_reason reason)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&wl->wl_lock, flags);
-	wlcore_stop_queue_locked(wl, wlvif, queue, reason);
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
-}
-
-void wlcore_wake_queue(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 queue,
-		       enum wlcore_queue_stop_reason reason)
-{
-	unsigned long flags;
-	int hwq = wlcore_tx_get_mac80211_queue(wlvif, queue);
-
-	spin_lock_irqsave(&wl->wl_lock, flags);
-
-	/* queue should not be clear for this reason */
-	WARN_ON_ONCE(!test_and_clear_bit(reason, &wl->queue_stop_reasons[hwq]));
-
-	if (wl->queue_stop_reasons[hwq])
-		goto out;
-
-	ieee80211_wake_queue(wl->hw, hwq);
-
-out:
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
-}
-
 void wlcore_stop_queues(struct cc33xx *wl,
 			enum wlcore_queue_stop_reason reason)
 {
@@ -1249,9 +1286,10 @@ void wlcore_stop_queues(struct cc33xx *wl,
 	spin_lock_irqsave(&wl->wl_lock, flags);
 
 	/* mark all possible queues as stopped */
-        for (i = 0; i < WLCORE_NUM_MAC_ADDRESSES * NUM_TX_QUEUES; i++)
-                WARN_ON_ONCE(test_and_set_bit(reason,
+	for (i = 0; i < WLCORE_NUM_MAC_ADDRESSES * NUM_TX_QUEUES; i++) {
+		WARN_ON_ONCE(test_and_set_bit(reason,
 					      &wl->queue_stop_reasons[i]));
+	}
 
 	/* use the global version to make sure all vifs in mac80211 we don't
 	 * know are stopped.
@@ -1270,9 +1308,10 @@ void wlcore_wake_queues(struct cc33xx *wl,
 	spin_lock_irqsave(&wl->wl_lock, flags);
 
 	/* mark all possible queues as awake */
-        for (i = 0; i < WLCORE_NUM_MAC_ADDRESSES * NUM_TX_QUEUES; i++)
+	for (i = 0; i < WLCORE_NUM_MAC_ADDRESSES * NUM_TX_QUEUES; i++) {
 		WARN_ON_ONCE(!test_and_clear_bit(reason,
 						 &wl->queue_stop_reasons[i]));
+	}
 
 	/* use the global version to make sure all vifs in mac80211 we don't
 	 * know are woken up.
@@ -1316,7 +1355,8 @@ bool wlcore_is_queue_stopped_locked(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 	return !!wl->queue_stop_reasons[hwq];
 }
 
-static void cc33xx_tx_complete_packet(struct cc33xx *wl, u8 tx_stat_byte,struct core_fw_status *pCoreFwStatus)
+static void cc33xx_tx_complete_packet(struct cc33xx *wl, u8 tx_stat_byte,
+				      struct core_fw_status *pCoreFwStatus)
 {
 	struct ieee80211_tx_info *info;
 	struct sk_buff *skb;
@@ -1325,15 +1365,14 @@ static void cc33xx_tx_complete_packet(struct cc33xx *wl, u8 tx_stat_byte,struct
 	struct cc33xx_tx_hw_descr *tx_desc;
 	u16 desc_session_idx;
 
-
 	/* check for id legality */
-	if (unlikely(id >= wl->num_tx_desc || wl->tx_frames[id] == NULL)) {
+	if (unlikely(id >= CC33XX_NUM_TX_DESCRIPTORS
+	    || wl->tx_frames[id] == NULL)) {
 		cc33xx_warning("illegal id in tx completion: %d", id);
 
 		print_hex_dump(KERN_DEBUG, "fwInfo local:",
-		            DUMP_PREFIX_OFFSET, 16, 4,
-		            (u8*)(pCoreFwStatus),
-		            sizeof (struct core_fw_status), false);
+			       DUMP_PREFIX_OFFSET, 16, 4, (u8*)(pCoreFwStatus),
+			       sizeof(struct core_fw_status), false);
 
 		cc33xx_queue_recovery_work(wl);
 		return;
@@ -1367,7 +1406,8 @@ static void cc33xx_tx_complete_packet(struct cc33xx *wl, u8 tx_stat_byte,struct
 	 * TODO: update sequence number for encryption? seems to be
 	 * unsupported for now. needed for recovery with encryption.
 	 */
-	/* todo michal - should we fix header ? should we remove the space we added for the ht header? */
+	// todo michal - should we fix header?
+	//should we remove the space we added for the ht header?
 	/* remove private header from packet */
 	skb_pull(skb, sizeof(struct cc33xx_tx_hw_descr));
 
@@ -1380,24 +1420,28 @@ static void cc33xx_tx_complete_packet(struct cc33xx *wl, u8 tx_stat_byte,struct
 		skb_pull(skb, CC33XX_EXTRA_SPACE_TKIP);
 	}
 
-	cc33xx_debug(DEBUG_TX, "tx status id %u skb 0x%p success %d, tx_memblocks %d",
-		     id, skb, tx_success,tx_desc->cc33xx_mem.total_mem_blocks);
-
+	cc33xx_debug(DEBUG_TX,
+		     "tx status id %u skb 0x%p success %d, tx_memblocks %d",
+		     id, skb, tx_success, tx_desc->cc33xx_mem.total_mem_blocks);
 
-	/* in order to update the memory managemetn we should have total_blocks, ac, and hlid */
-	/* update memory managemetn variables - michal michal michal*/
+	/**
+	 * in order to update the memory management
+	 * we should have total_blocks, ac, and hlid
+	 */
+	/* update memory management variables - michal michal michal*/
 	wl->tx_blocks_available += tx_desc->cc33xx_mem.total_mem_blocks;
 	wl->tx_allocated_blocks -= tx_desc->cc33xx_mem.total_mem_blocks;
-	// per queue
+	/* per queue */
 
 	/* prevent wrap-around in freed-packets counter */
 	wl->tx_allocated_pkts[tx_desc->ac]--;
 
 	/* per link */
-	desc_session_idx = (tx_desc->tx_attr & TX_HW_ATTR_SESSION_COUNTER) >> TX_HW_ATTR_OFST_SESSION_COUNTER;
-	if (wl->session_ids[tx_desc->hlid] == desc_session_idx) {
+	desc_session_idx = (tx_desc->tx_attr & TX_HW_ATTR_SESSION_COUNTER) >>
+					TX_HW_ATTR_OFST_SESSION_COUNTER;
+
+	if (wl->session_ids[tx_desc->hlid] == desc_session_idx)
 		wl->links[tx_desc->hlid].allocated_pkts--;
-	}
 
 	cc33xx_free_tx_id(wl, id);
 
@@ -1407,7 +1451,6 @@ static void cc33xx_tx_complete_packet(struct cc33xx *wl, u8 tx_stat_byte,struct
 	/* return the packet to the stack */
 	skb_queue_tail(&wl->deferred_tx_queue, skb);
 	queue_work(wl->freezable_wq, &wl->netstack_work);
-
 }
 
 void cc33xx_tx_immediate_complete(struct cc33xx *wl)
@@ -1417,7 +1460,8 @@ void cc33xx_tx_immediate_complete(struct cc33xx *wl)
 	u8 i;
 
 	claim_core_status_lock(wl);
-	memcpy(&coreFwStatus,&wl->core_status->fwInfo,sizeof(struct core_fw_status));
+	memcpy(&coreFwStatus, &wl->core_status->fwInfo,
+	       sizeof(struct core_fw_status));
 
 	txResultQueueIndex = wl->core_status->fwInfo.txResultQueueIndex;
 	/* Lock guarantees we shadow txResultQueueIndex NOT during
@@ -1426,7 +1470,7 @@ void cc33xx_tx_immediate_complete(struct cc33xx *wl)
 	release_core_status_lock(wl);
 
 	cc33xx_debug(DEBUG_TX, "last released desc = %d, current idx = %d",
-	             wl->last_fw_rls_idx, txResultQueueIndex);
+		     wl->last_fw_rls_idx, txResultQueueIndex);
 
 	/* nothing to do here */
 	if (wl->last_fw_rls_idx == txResultQueueIndex)
@@ -1436,20 +1480,19 @@ void cc33xx_tx_immediate_complete(struct cc33xx *wl)
 
 	if (txResultQueueIndex >= TX_RESULT_QUEUE_SIZE) {
 		cc33xx_error("invalid desc release index %d",
-		             txResultQueueIndex);
+			     txResultQueueIndex);
 		WARN_ON(1);
 		return;
 	}
 
-	cc33xx_debug(DEBUG_TX, "TX result queue! priv last fw idx %d, current resut index %d ",wl->last_fw_rls_idx, txResultQueueIndex);
-	for (i = wl->last_fw_rls_idx;
-	     i != txResultQueueIndex;
-	     i = (i + 1) % TX_RESULT_QUEUE_SIZE) {
-		cc33xx_tx_complete_packet(wl,
-		                          coreFwStatus.txResultQueue[i],&coreFwStatus);
-		                          //wl->core_status->fwInfo.txResultQueue[i],&coreFwStatus);
-
+	cc33xx_debug(DEBUG_TX, "TX result queue! priv last fw idx %d, "
+		     "current resut index %d ",
+		     wl->last_fw_rls_idx, txResultQueueIndex);
 
+	for (i = wl->last_fw_rls_idx; i != txResultQueueIndex;
+	     i = (i + 1) % TX_RESULT_QUEUE_SIZE) {
+		cc33xx_tx_complete_packet(wl, coreFwStatus.txResultQueue[i],
+					  &coreFwStatus);
 	}
 
 	wl->last_fw_rls_idx = txResultQueueIndex;
diff --git a/drivers/net/wireless/ti/cc33xx/tx.h b/drivers/net/wireless/ti/cc33xx/tx.h
index 332a5f7326e5..8261db07d167 100644
--- a/drivers/net/wireless/ti/cc33xx/tx.h
+++ b/drivers/net/wireless/ti/cc33xx/tx.h
@@ -12,9 +12,6 @@
 #define __TX_H__
 
 
-
-
-
 #define CC33XX_TX_HW_BLOCK_SPARE        1
 /* for special cases - namely, TKIP and GEM */
 #define CC33XX_TX_HW_EXTRA_BLOCK_SPARE  2
@@ -26,42 +23,24 @@
 /* Indicates this TX HW frame is not padded to SDIO block size */
 #define CC33XX_TX_CTRL_NOT_PADDED	BIT(7)
 
-/*
- * The FW uses a special bit to indicate a wide channel should be used in
- * the rate policy.
- */
-#define CONF_TX_RATE_USE_WIDE_CHAN BIT(31)
-
 #define TX_HW_MGMT_PKT_LIFETIME_TU       2000
 #define TX_HW_AP_MODE_PKT_LIFETIME_TU    8000
 
-#define TX_HW_ATTR_SAVE_RETRIES          BIT(0)
-#define TX_HW_ATTR_HEADER_PAD            BIT(1)
 #define TX_HW_ATTR_SESSION_COUNTER       (BIT(2) | BIT(3) | BIT(4))
-#define TX_HW_ATTR_RATE_POLICY           (BIT(5) | BIT(6) | BIT(7) | \
-					  BIT(8) | BIT(9))
-#define TX_HW_ATTR_LAST_WORD_PAD         (BIT(10) | BIT(11))
-#define TX_HW_ATTR_TX_CMPLT_REQ          BIT(12)
 #define TX_HW_ATTR_TX_DUMMY_REQ          BIT(13)
 #define TX_HW_ATTR_HOST_ENCRYPT          BIT(14)
 #define TX_HW_ATTR_EAPOL_FRAME           BIT(15)
 
-#define TX_HW_ATTR_OFST_SAVE_RETRIES     0
-#define TX_HW_ATTR_OFST_HEADER_PAD       1
 #define TX_HW_ATTR_OFST_SESSION_COUNTER  2
 #define TX_HW_ATTR_OFST_RATE_POLICY      5
-#define TX_HW_ATTR_OFST_LAST_WORD_PAD    10
-#define TX_HW_ATTR_OFST_TX_CMPLT_REQ     12
-
-#define TX_HW_RESULT_QUEUE_LEN           16
-#define TX_HW_RESULT_QUEUE_LEN_MASK      0xf
 
 #define CC33XX_TX_ALIGN_TO 4
 #define CC33XX_EXTRA_SPACE_TKIP 4
 #define CC33XX_EXTRA_SPACE_AES  8
 #define CC33XX_EXTRA_SPACE_MAX  8
 
-#define CC33XX_TX_EXTRA_HEADROOM (sizeof(struct cc33xx_tx_hw_descr) + IEEE80211_HT_CTL_LEN)
+#define CC33XX_TX_EXTRA_HEADROOM	\
+		(sizeof(struct cc33xx_tx_hw_descr) + IEEE80211_HT_CTL_LEN)
 
 /* Used for management frames and dummy packets */
 #define CC33XX_TID_MGMT 7
@@ -105,7 +84,7 @@ struct cc33xx_tx_hw_descr {
 	u8 tid;
 	/* host link ID (HLID) */
 	u8 hlid;
-	u8  ac;
+	u8 ac;
 	/*
 	* Max delay in TUs until transmission. The last device time the
 	* packet can be transmitted is: start_time + (1024 * life_time)
@@ -115,18 +94,6 @@ struct cc33xx_tx_hw_descr {
 	__le16 tx_attr;
 } __packed;
 
-enum cc33xx_tx_hw_res_status {
-	TX_SUCCESS          = 0,
-	TX_HW_ERROR         = 1,
-	TX_DISABLED         = 2,
-	TX_RETRY_EXCEEDED   = 3,
-	TX_TIMEOUT          = 4,
-	TX_KEY_NOT_FOUND    = 5,
-	TX_PEER_NOT_FOUND   = 6,
-	TX_SESSION_MISMATCH = 7,
-	TX_LINK_NOT_VALID   = 8,
-};
-
 struct cc33xx_tx_hw_res_descr {
 	/* Packet Identifier - same value used in the Tx descriptor.*/
 	u8 id;
@@ -151,14 +118,6 @@ struct cc33xx_tx_hw_res_descr {
 	u8 spare;
 } __packed;
 
-
-
-struct cc33xx_tx_hw_res_if {
-	__le32 tx_result_fw_counter;
-	__le32 tx_result_host_counter;
-	struct cc33xx_tx_hw_res_descr tx_results_queue[TX_HW_RESULT_QUEUE_LEN];
-} __packed;
-
 enum wlcore_queue_stop_reason {
 	WLCORE_QUEUE_STOP_REASON_WATERMARK,
 	WLCORE_QUEUE_STOP_REASON_FW_RESTART,
@@ -166,52 +125,9 @@ enum wlcore_queue_stop_reason {
 	WLCORE_QUEUE_STOP_REASON_SPARE_BLK, /* 18xx specific */
 };
 
-static inline int cc33xx_tx_get_queue(int queue)
-{
-	switch (queue) {
-	case 0:
-		return CONF_TX_AC_VO;
-	case 1:
-		return CONF_TX_AC_VI;
-	case 2:
-		return CONF_TX_AC_BE;
-	case 3:
-		return CONF_TX_AC_BK;
-	default:
-		return CONF_TX_AC_BE;
-	}
-}
-
-static inline
-int wlcore_tx_get_mac80211_queue(struct cc33xx_vif *wlvif, int queue)
-{
-	int mac_queue = wlvif->hw_queue_base;
-
-	switch (queue) {
-	case CONF_TX_AC_VO:
-		return mac_queue + 0;
-	case CONF_TX_AC_VI:
-		return mac_queue + 1;
-	case CONF_TX_AC_BE:
-		return mac_queue + 2;
-	case CONF_TX_AC_BK:
-		return mac_queue + 3;
-	default:
-		return mac_queue + 2;
-	}
-}
-
-static inline int cc33xx_tx_total_queue_count(struct cc33xx *wl)
-{
-	int i, count = 0;
-
-	for (i = 0; i < NUM_TX_QUEUES; i++)
-		count += wl->tx_queue_count[i];
-
-	return count;
-}
-
 
+int cc33xx_tx_get_queue(int queue);
+int cc33xx_tx_total_queue_count(struct cc33xx *wl);
 void cc33xx_tx_immediate_complete(struct cc33xx *wl);
 void cc33xx_tx_work(struct work_struct *work);
 int wlcore_tx_work_locked(struct cc33xx *wl);
@@ -227,16 +143,11 @@ u8 cc33xx_tx_get_hlid(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 void cc33xx_tx_reset_link_queues(struct cc33xx *wl, u8 hlid);
 void cc33xx_handle_tx_low_watermark(struct cc33xx *wl);
 bool cc33xx_is_dummy_packet(struct cc33xx *wl, struct sk_buff *skb);
-void cc33xx_rearm_rx_streaming(struct cc33xx *wl, unsigned long *active_hlids);
 unsigned int wlcore_calc_packet_alignment(struct cc33xx *wl,
 					  unsigned int packet_length);
 void cc33xx_free_tx_id(struct cc33xx *wl, int id);
 void wlcore_stop_queue_locked(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			      u8 queue, enum wlcore_queue_stop_reason reason);
-void wlcore_stop_queue(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 queue,
-		       enum wlcore_queue_stop_reason reason);
-void wlcore_wake_queue(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 queue,
-		       enum wlcore_queue_stop_reason reason);
 void wlcore_stop_queues(struct cc33xx *wl,
 			enum wlcore_queue_stop_reason reason);
 void wlcore_wake_queues(struct cc33xx *wl,
@@ -244,10 +155,9 @@ void wlcore_wake_queues(struct cc33xx *wl,
 bool wlcore_is_queue_stopped_by_reason(struct cc33xx *wl,
 				       struct cc33xx_vif *wlvif, u8 queue,
 				       enum wlcore_queue_stop_reason reason);
-bool
-wlcore_is_queue_stopped_by_reason_locked(struct cc33xx *wl,
-					 struct cc33xx_vif *wlvif,
-					 u8 queue,
+bool wlcore_is_queue_stopped_by_reason_locked(struct cc33xx *wl,
+					      struct cc33xx_vif *wlvif,
+					      u8 queue,
 					 enum wlcore_queue_stop_reason reason);
 bool wlcore_is_queue_stopped_locked(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 				    u8 queue);
@@ -256,4 +166,5 @@ bool wlcore_is_queue_stopped_locked(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 void cc33xx_free_sta(struct cc33xx *wl, struct cc33xx_vif *wlvif, u8 hlid);
 void cc33xx_rearm_tx_watchdog_locked(struct cc33xx *wl);
 
-#endif
+
+#endif /* __TX_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/wlcore.h b/drivers/net/wireless/ti/cc33xx/wlcore.h
index d0efc0c4099a..dc642a5feee5 100644
--- a/drivers/net/wireless/ti/cc33xx/wlcore.h
+++ b/drivers/net/wireless/ti/cc33xx/wlcore.h
@@ -8,11 +8,7 @@
 #ifndef __WLCORE_H__
 #define __WLCORE_H__
 
-#include <linux/platform_device.h>
-
 #include "wlcore_i.h"
-#include "event.h"
-#include "boot.h"
 #include "rx.h"
 
 
@@ -20,7 +16,7 @@
 #define MAJOR_VERSION 	1
 #define MINOR_VERSION 	7
 #define API_VERSION 	0
-#define BUILD_VERSION	27
+#define BUILD_VERSION	114
 
 
 /* The maximum number of Tx descriptors in all chip families */
@@ -30,13 +26,11 @@
 #define CC33XX_INI_PARAM_COMMAND_SIZE (16UL)//size of struct cc33xx_cmd_ini_params_download
 #define CC33XX_INI_CMD_MAX_SIZE      (CC33X_CONF_SIZE + CC33XX_INI_PARAM_COMMAND_SIZE + sizeof(int))
 
-#define CC33XX_CMD_BUFFER_SIZE ((CC33XX_INI_CMD_MAX_SIZE > CC33XX_CMD_MAX_SIZE) ? CC33XX_INI_CMD_MAX_SIZE : CC33XX_CMD_MAX_SIZE)
+#define CC33XX_CMD_BUFFER_SIZE ((CC33XX_INI_CMD_MAX_SIZE > CC33XX_CMD_MAX_SIZE)\
+				? CC33XX_INI_CMD_MAX_SIZE : CC33XX_CMD_MAX_SIZE)
 
 #define WLCORE_NUM_MAC_ADDRESSES 3
 
-/* Texas Instruments pre assigned OUI */
-#define WLCORE_TI_OUI_ADDRESS 0x080028
-
 #define CC33XX_AGGR_BUFFER_SIZE		(8 * PAGE_SIZE)
 
 #define CC33XX_NUM_TX_DESCRIPTORS 32
@@ -65,18 +59,21 @@ struct driver_versions{
 struct driver_fw_versions{
 	struct driver_versions driver_ver;
 	struct cc33xx_acx_fw_versions *fw_ver;
-
 };
 
 struct cc33xx_stats {
 	void *fw_stats;
 	unsigned long fw_stats_update;
-	size_t fw_stats_len;
-
 	unsigned int retry_count;
 	unsigned int excessive_retries;
 };
 
+struct cc33xx_ant_diversity {
+	u8 diversity_enable;
+	s8 rssi_threshold;
+	u8 default_antenna;
+	u8 padding[1];
+};
 
 struct cc33xx {
 	bool initialized;
@@ -86,12 +83,10 @@ struct cc33xx {
 	struct device *dev;
 	struct platform_device *pdev;
 
-
 	struct cc33xx_if_operations *if_ops;
 
 	int wakeirq;
 
-
 	spinlock_t wl_lock;
 
 	enum wlcore_state state;
@@ -130,7 +125,7 @@ struct cc33xx {
 	u8 sta_count;
 	u8 ap_count;
 
-	struct cc33xx_acx_mem_map *target_mem_map;
+	struct cc33xx_acx_mem_map_t *target_mem_map;
 
 	/* Accounting for allocated / available TX blocks on HW */
 
@@ -139,13 +134,10 @@ struct cc33xx {
 
 	/* Accounting for allocated / available Tx packets in HW */
 
-
 	u32 tx_allocated_pkts[NUM_TX_QUEUES];
 
-
 	/* Time-offset between host and chipset clocks */
 
-
 	/* Frames scheduled for transmission, not handled yet */
 	int tx_queue_count[NUM_TX_QUEUES];
 	unsigned long queue_stop_reasons[
@@ -236,8 +228,9 @@ struct cc33xx {
 
 	/*
 	 * wowlan trigger was configured during suspend.
-	 * (currently, only "ANY" trigger is supported)
+	 * (currently, only "ANY" and "PATTERN" trigger is supported)
 	 */
+
 	bool keep_device_power;
 
 	/*
@@ -261,9 +254,6 @@ struct cc33xx {
 	/* number of currently active RX BA sessions */
 	int ba_rx_session_count;
 
-	/* Maximum number of supported RX BA sessions */
-	int ba_rx_session_count_max;
-
 	/* AP-mode - number of currently connected stations */
 	int active_sta_count;
 
@@ -273,27 +263,6 @@ struct cc33xx {
 	/* work to fire when Tx is stuck */
 	struct delayed_work tx_watchdog_work;
 
-	u8 scan_templ_id_2_4;
-	u8 scan_templ_id_5;
-	u8 sched_scan_templ_id_2_4;
-	u8 sched_scan_templ_id_5;
-	u8 max_channels_5;
-
-	/* number of TX descriptors the HW supports. */
-	u32 num_tx_desc;
-	/* number of RX descriptors the HW supports. */
-	u32 num_rx_desc;
-	/* number of links the HW supports */
-	u8 num_links;
-	/* max stations a single AP can support */
-	u8 max_ap_stations;
-
-	/* translate HW Tx rates to standard rate-indices */
-	const u8 **band_rate_to_idx;
-
-	/* size of table for HW rates that can be received from chip */
-	u8 hw_tx_rate_tbl_size;
-
 	/* HW HT (11n) capabilities */
 	struct ieee80211_sta_ht_cap ht_cap[WLCORE_NUM_BANDS];
 
@@ -302,7 +271,8 @@ struct cc33xx {
 	bool radar_debug_mode;
 
 	/* RX Data filter rule state - enabled/disabled */
-	unsigned long rx_filter_enabled[BITS_TO_LONGS(CC33XX_MAX_RX_FILTERS)];//used in CONFIG PM AND W8 Code
+	/* used in CONFIG PM AND W8 Code */
+	unsigned long rx_filter_enabled[BITS_TO_LONGS(CC33XX_MAX_RX_FILTERS)];
 
 	/* mutex for protecting the tx_flush function */
 	struct mutex flush_mutex;
@@ -313,6 +283,16 @@ struct cc33xx {
 	/*ble_enable value - if 0 ble not enabled , if 1 is enabled..cant be disabled after enable*/
 	int ble_enable;
 
+	/* parameters for joining a TWT agreement */
+	int min_wake_duration_usec;
+	int min_wake_interval_mantissa;
+	int min_wake_interval_exponent;
+	int max_wake_interval_mantissa;
+	int max_wake_interval_exponent;
+
+	/* the number of allocated MAC addresses in this chip */
+	int num_mac_addr;
+
 	/* sta role index - if 0 - wlan0 primary station interface, if 1 - wlan2 - secondary station interface*/
 
 	u8 sta_role_idx;
@@ -322,10 +302,6 @@ struct cc33xx {
 	struct completion nvs_loading_complete;
 	struct completion command_complete;
 
-	/* interface combinations supported by the hw */
-	const struct ieee80211_iface_combination *iface_combinations;
-	u8 n_iface_combinations;
-
 	/* dynamic fw traces */
 	u32 dynamic_fw_traces;
 
@@ -345,13 +321,12 @@ struct cc33xx {
 
 	struct driver_fw_versions all_versions;
 
-	char* all_versions_str;
-
 	u8 antenna_selection;
 
 	/* burst mode cfg */
 	u8 burst_disable;
 
+	struct cc33xx_ant_diversity diversity;
 };
 
 int wlcore_probe(struct cc33xx *wl, struct platform_device *pdev);
@@ -359,33 +334,14 @@ int wlcore_remove(struct platform_device *pdev);
 struct ieee80211_hw *wlcore_alloc_hw(u32 aggr_buf_size);
 int wlcore_free_hw(struct cc33xx *wl);
 int wlcore_set_key(struct cc33xx *wl, enum set_key_cmd cmd,
-		   struct ieee80211_vif *vif,
-		   struct ieee80211_sta *sta,
+		   struct ieee80211_vif *vif, struct ieee80211_sta *sta,
 		   struct ieee80211_key_conf *key_conf);
 void wlcore_regdomain_config(struct cc33xx *wl);
 void wlcore_update_inconn_sta(struct cc33xx *wl, struct cc33xx_vif *wlvif,
 			      struct cc33xx_station *wl_sta, bool in_conn);
-bool cc33xx_is_mimo_supported(struct cc33xx *wl);
-
-static inline void
-wlcore_set_ht_cap(struct cc33xx *wl, enum nl80211_band band,
-		  struct ieee80211_sta_ht_cap *ht_cap)
-{
-	memcpy(&wl->ht_cap[band], ht_cap, sizeof(*ht_cap));
-}
-
-/* Tell wlcore not to care about this element when checking the version */
-#define WLCORE_FW_VER_IGNORE	-1
-
-
-/* Firmware image load chunk size */
-#define CHUNK_SIZE	16384
 
 /* Quirks */
 
-/* Each RX/TX transaction requires an end-of-transaction transfer */
-#define WLCORE_QUIRK_END_OF_TRANSACTION		BIT(0)
-
 /* the first start_role(sta) sometimes doesn't work on wl12xx */
 #define WLCORE_QUIRK_START_STA_FAILS		BIT(1)
 
@@ -395,12 +351,6 @@ wlcore_set_ht_cap(struct cc33xx *wl, enum nl80211_band band,
 /* means aggregated Rx packets are aligned to a SDIO block */
 #define WLCORE_QUIRK_RX_BLOCKSIZE_ALIGN		BIT(3)
 
-/* Older firmwares did not implement the FW logger over bus feature */
-#define WLCORE_QUIRK_FWLOG_NOT_IMPLEMENTED	BIT(4)
-
-/* Older firmwares use an old NVS format */
-#define WLCORE_QUIRK_LEGACY_NVS			BIT(5)
-
 /* pad only the last frame in the aggregate buffer */
 #define WLCORE_QUIRK_TX_PAD_LAST_FRAME		BIT(7)
 
@@ -422,75 +372,18 @@ wlcore_set_ht_cap(struct cc33xx *wl, enum nl80211_band band,
 /* TODO: move all these common registers and values elsewhere */
 #define HW_ACCESS_ELP_CTRL_REG		0x1FFFC
 
-/* ELP register commands */
-#define ELPCTRL_WAKE_UP             0x1
-#define ELPCTRL_WAKE_UP_WLAN_READY  0x5
-#define ELPCTRL_SLEEP               0x0
-/* ELP WLAN_READY bit */
-#define ELPCTRL_WLAN_READY          0x2
-
-/*************************************************************************
-
-    Interrupt Trigger Register (Host -> WiLink)
-
-**************************************************************************/
-
-/* Hardware to Embedded CPU Interrupts - first 32-bit register set */
-
-/*
- * The host sets this bit to inform the Wlan
- * FW that a TX packet is in the XFER
- * Buffer #0.
- */
-#define INTR_TRIG_TX_PROC0 BIT(2)
-
-/*
- * The host sets this bit to inform the FW
- * that it read a packet from RX XFER
- * Buffer #0.
- */
-#define INTR_TRIG_RX_PROC0 BIT(3)
-
-#define INTR_TRIG_DEBUG_ACK BIT(4)
-
-#define INTR_TRIG_STATE_CHANGED BIT(5)
-
-/* Hardware to Embedded CPU Interrupts - second 32-bit register set */
-
-/*
- * The host sets this bit to inform the FW
- * that it read a packet from RX XFER
- * Buffer #1.
- */
-#define INTR_TRIG_RX_PROC1 BIT(17)
-
-/*
- * The host sets this bit to inform the Wlan
- * hardware that a TX packet is in the XFER
- * Buffer #1.
- */
-#define INTR_TRIG_TX_PROC1 BIT(18)
-
-#define ACX_SLV_SOFT_RESET_BIT	BIT(1)
-#define SOFT_RESET_MAX_TIME	1000000
-#define SOFT_RESET_STALL_TIME	1000
-
-#define ECPU_CONTROL_HALT	0x00000101
-
-#define WELP_ARM_COMMAND_VAL	0x4
-
 enum CC33xx_FRAME_FORMAT {
- CC33xx_B_SHORT = 0,
- CC33xx_B_LONG,
- CC33xx_LEGACY_OFDM,
- CC33xx_HT_MF,
- CC33xx_HT_GF,
- CC33xx_HE_SU,
- CC33xx_HE_MU,
- CC33xx_HE_SU_ER,
- CC33xx_HE_TB,
- CC33xx_HE_TB_NDP_FB,
- CC33xx_VHT
+	CC33xx_B_SHORT = 0,
+	CC33xx_B_LONG,
+	CC33xx_LEGACY_OFDM,
+	CC33xx_HT_MF,
+	CC33xx_HT_GF,
+	CC33xx_HE_SU,
+	CC33xx_HE_MU,
+	CC33xx_HE_SU_ER,
+	CC33xx_HE_TB,
+	CC33xx_HE_TB_NDP_FB,
+	CC33xx_VHT
 };
 
 /* CC33xx HW Common Definitions */
@@ -501,7 +394,6 @@ enum CC33xx_FRAME_FORMAT {
 #define NAB_CONTROL_ADDR	0x0000BFF8
 #define NAB_STATUS_ADDR		0x0000BFFC
 
-
 #define NAB_SEND_CMD        0x940d // 0x900D
 #define NAB_SEND_FLAGS      0x08
 #define CC33xx_INTERNAL_DESC_SIZE   200
@@ -509,47 +401,68 @@ enum CC33xx_FRAME_FORMAT {
 
 #define TX_RESULT_QUEUE_SIZE  108
 
-
-
 struct control_info_descriptor
 {
-    __le16 type 	:4;
-    __le16 length 	:12;
+	__le16 type 	:4;
+	__le16 length 	:12;
 };
 
 enum control_message_type
 {
-    CTRL_MSG_NONE = 0,
-    CTRL_MSG_EVENT = 1,
-    CTRL_MSG_COMMND_COMPLETE = 2
+	CTRL_MSG_NONE = 0,
+	CTRL_MSG_EVENT = 1,
+	CTRL_MSG_COMMND_COMPLETE = 2
 };
 
 struct core_fw_status
 {
-    u8   txResultQueueIndex;
-    u8   reserved1[3];
-    u8   txResultQueue[TX_RESULT_QUEUE_SIZE];
-    __le32	link_ps_bitmap;                     /* A bitmap (where each bit represents a single HLID) to indicate PS/Active mode of the link */
-    __le32	link_fast_bitmap;                   /* A bitmap (where each bit represents a single HLID) to indicate if the station is in Fast mode */
-    __le32	link_suspend_bitmap;                /* A bitmap (where each bit represents a single HLID) to indicate if a links is suspended/aboout to be suspended*/
-    u8      TxFlowControlAcThreshold;           /* Host TX Flow Control descriptor per AC threshold */
-    u8      tx_ps_threshold;                    /* Host TX Flow Control descriptor PS link threshold */
-    u8      tx_suspend_threshold;               /* Host TX Flow Control descriptor Suspended link threshold */
-    u8      tx_slow_link_prio_threshold;        /* Host TX Flow Control descriptor Slow link threshold */
-    u8      tx_fast_link_prio_threshold;        /* Host TX Flow Control descriptor Fast link threshold */
-    u8      tx_slow_stop_threshold;             /* Host TX Flow Control descriptor Stop Slow link threshold */
-    u8      tx_fast_stop_threshold;             /* Host TX Flow Control descriptor Stop Fast link threshold */
-    u8      reserved2;
-    // Additional information can be added here
+	u8	txResultQueueIndex;
+	u8	reserved1[3];
+	u8	txResultQueue[TX_RESULT_QUEUE_SIZE];
+
+	/* A bitmap (where each bit represents a single HLID)
+	to indicate PS/Active mode of the link */
+	__le32	link_ps_bitmap;
+
+	/* A bitmap (where each bit represents a single HLID)
+	to indicate if the station is in Fast mode */
+	__le32	link_fast_bitmap;
+
+	/* A bitmap (where each bit represents a single HLID)
+	to indicate if a links is suspended/aboout to be suspended */
+	__le32	link_suspend_bitmap;
+
+	/* Host TX Flow Control descriptor per AC threshold */
+	u8      TxFlowControlAcThreshold;
+
+	/* Host TX Flow Control descriptor PS link threshold */
+	u8      tx_ps_threshold;
+
+	/* Host TX Flow Control descriptor Suspended link threshold */
+	u8      tx_suspend_threshold;
+
+	/* Host TX Flow Control descriptor Slow link threshold */
+	u8      tx_slow_link_prio_threshold;
+
+	/* Host TX Flow Control descriptor Fast link threshold */
+	u8      tx_fast_link_prio_threshold;
+
+	/* Host TX Flow Control descriptor Stop Slow link threshold */
+	u8      tx_slow_stop_threshold;
+
+	/* Host TX Flow Control descriptor Stop Fast link threshold */
+	u8      tx_fast_stop_threshold;
+
+	u8      reserved2;
+	/* Additional information can be added here */
 } __packed;
 
 struct core_status {
-    //__le32 bloc_pad[92];
-    __le32 block_pad[28];
-    __le32 host_interrupt_status;
-    __le32 rx_status;
-    struct core_fw_status fwInfo;
-    __le32 tsf;
+	__le32 block_pad[28];
+	__le32 host_interrupt_status;
+	__le32 rx_status;
+	struct core_fw_status fwInfo;
+	__le32 tsf;
 } __packed;
 
 struct NAB_header{
@@ -561,12 +474,8 @@ struct NAB_header{
 /* rx_status lower bytes hold the rx byte count */
 #define RX_BYTE_COUNT_MASK 0xFFFF
 
-
-
-
 #define HINT_NEW_TX_RESULT						0x1
 #define HINT_COMMAND_COMPLETE 					0x2
-#define HINT_RX_DATA_PENDING 					0x4
 #define HINT_ROM_LOADER_INIT_COMPLETE 			0x8
 #define HINT_SECOND_LOADER_INIT_COMPLETE 		0x10
 #define HINT_FW_WAKEUP_COMPLETE 				0x20
@@ -580,25 +489,21 @@ struct NAB_header{
 	HINT_FW_INIT_COMPLETE )
 
 struct NAB_tx_header{
-    __le32 sync;
-    __le16 opcode;
-    __le16 len;
-    __le16 desc_length;
-    u8     sd;
-    u8     flags;
+	__le32 sync;
+	__le16 opcode;
+	__le16 len;
+	__le16 desc_length;
+	u8     sd;
+	u8     flags;
 } __packed;
 
 struct NAB_rx_header{
-    __le32 cnys;
-    __le16 opcode;
-    __le16 len;
-    __le32 rx_desc;
-    __le32 reserved;
+	__le32 cnys;
+	__le16 opcode;
+	__le16 len;
+	__le32 rx_desc;
+	__le32 reserved;
 } __packed;
 
 
-
-
-
-
 #endif /* __WLCORE_H__ */
diff --git a/drivers/net/wireless/ti/cc33xx/wlcore_i.h b/drivers/net/wireless/ti/cc33xx/wlcore_i.h
index b298b469924a..874b3d423bc0 100644
--- a/drivers/net/wireless/ti/cc33xx/wlcore_i.h
+++ b/drivers/net/wireless/ti/cc33xx/wlcore_i.h
@@ -11,15 +11,11 @@
 #ifndef __WLCORE_I_H__
 #define __WLCORE_I_H__
 
-#include <linux/mutex.h>
-#include <linux/completion.h>
-#include <linux/spinlock.h>
-#include <linux/list.h>
-#include <linux/bitops.h>
 #include <net/mac80211.h>
+#include <linux/platform_device.h>
 
 #include "conf.h"
-#include "ini.h"
+
 
 struct cc33xx_family_data {
 	const char *name;
@@ -27,23 +23,17 @@ struct cc33xx_family_data {
 	const char *cfg_name;	/* cfg file */
 };
 
-
 #define CC33XX_TX_SECURITY_LO16(s) ((u16)((s) & 0xffff))
 #define CC33XX_TX_SECURITY_HI32(s) ((u32)(((s) >> 16) & 0xffffffff))
 #define CC33XX_TX_SQN_POST_RECOVERY_PADDING 0xff
 /* Use smaller padding for GEM, as some  APs have issues when it's too big */
 #define CC33XX_TX_SQN_POST_RECOVERY_PADDING_GEM 0x20
 
-
 #define CC33XX_CIPHER_SUITE_GEM 0x00147201
 
 #define CC33XX_BUSY_WORD_LEN (sizeof(u32))
 
-#define CC33XX_ELP_HW_STATE_ASLEEP 0
-#define CC33XX_ELP_HW_STATE_IRQ    1
-
 #define CC33XX_DEFAULT_BEACON_INT  100
-#define CC33XX_DEFAULT_DTIM_PERIOD 1
 
 #define CC33XX_MAX_ROLES           4
 #define CC33XX_INVALID_ROLE_ID     0xff
@@ -51,7 +41,6 @@ struct cc33xx_family_data {
 
 #define CC33XX_MAX_LINKS 21
 
-
 /* the driver supports the 2.4Ghz and 5Ghz bands */
 #define WLCORE_NUM_BANDS           2
 
@@ -80,16 +69,6 @@ enum wlcore_state {
 
 struct cc33xx;
 
-enum {
-	FW_VER_CHIP,
-	FW_VER_IF_TYPE,
-	FW_VER_MAJOR,
-	FW_VER_SUBTYPE,
-	FW_VER_MINOR,
-
-	NUM_FW_VER
-};
-
 #define NUM_TX_QUEUES              4
 
 #define CC33XX_MAX_CHANNELS 64
@@ -126,8 +105,6 @@ struct wlcore_platdev_data {
 	int  gpio_irq_num;
 
 	bool ref_clock_xtal;	/* specify whether the clock is XTAL or not */
-	u32 ref_clock_freq;	/* in Hertz */
-	u32 tcxo_clock_freq;	/* in Hertz, tcxo is always XTAL */
 	bool pwr_in_suspend;
 };
 
@@ -146,10 +123,8 @@ struct cc33xx_ap_key {
 
 enum cc33xx_flags {
 	CC33XX_FLAG_GPIO_POWER,
-	CC33XX_FLAG_TX_QUEUE_STOPPED,
 	CC33XX_FLAG_TX_PENDING,
 	CC33XX_FLAG_IN_ELP,
-	CC33XX_FLAG_IRQ_RUNNING,
 	CC33XX_FLAG_FW_TX_BUSY,
 	CC33XX_FLAG_DUMMY_PACKET_PENDING,
 	CC33XX_FLAG_SUSPENDED,
@@ -221,7 +196,6 @@ struct cc33xx_link {
 #define CC33XX_RX_FILTER_MAX_PATTERN_SIZE			\
 	(CC33XX_RX_FILTER_MAX_FIELDS_SIZE - RX_FILTER_FIELD_OVERHEAD)
 
-#define CC33XX_RX_FILTER_FLAG_MASK                BIT(0)
 #define CC33XX_RX_FILTER_FLAG_IP_HEADER           0
 #define CC33XX_RX_FILTER_FLAG_ETHERNET_HEADER     BIT(1)
 
@@ -436,7 +410,6 @@ struct cc33xx_vif {
 	};
 };
 
-
 static inline struct cc33xx_vif *cc33xx_vif_to_data(struct ieee80211_vif *vif)
 {
 	WARN_ON(!vif);
@@ -474,7 +447,6 @@ int cc33xx_plt_start(struct cc33xx *wl, const enum plt_mode plt_mode);
 int cc33xx_plt_stop(struct cc33xx *wl);
 int cc33xx_recalc_rx_streaming(struct cc33xx *wl, struct cc33xx_vif *wlvif);
 void cc33xx_queue_recovery_work(struct cc33xx *wl);
-size_t cc33xx_copy_fwlog(struct cc33xx *wl, u8 *memblock, size_t maxlen);
 int cc33xx_rx_filter_alloc_field(struct cc33xx_rx_filter *filter,
 				 u16 offset, u8 flags,
 				 const u8 *pattern, u8 len);
@@ -485,9 +457,6 @@ void cc33xx_rx_filter_flatten_fields(struct cc33xx_rx_filter *filter,
 				     u8 *buf);
 void cc33xx_flush_deferred_work(struct cc33xx *wl);
 
-#define JOIN_TIMEOUT 5000 /* 5000 milliseconds to join */
-
-#define SESSION_COUNTER_MAX 6 /* maximum value for the session counter */
 #define SESSION_COUNTER_INVALID 7 /* used with dummy_packet */
 
 #define CC33XX_MAX_TXPWR 21 /* maximum power limit is 21dBm */
@@ -504,8 +473,8 @@ void cc33xx_flush_deferred_work(struct cc33xx *wl);
 #define CC33XX_POWER_ON_SLEEP 200 /* in milliseconds */
 
 /* Macros to handle cc33xx.sta_rate_set */
-#define HW_BG_RATES_MASK	0xffff
 #define HW_HT_RATES_OFFSET	16
 #define HW_MIMO_RATES_OFFSET	24
 
+
 #endif /* __WLCORE_I_H__ */
diff --git a/drivers/tty/serial/8250/8250_omap.c b/drivers/tty/serial/8250/8250_omap.c
index 15e50fe40e4b..42d7a8d30a13 100644
--- a/drivers/tty/serial/8250/8250_omap.c
+++ b/drivers/tty/serial/8250/8250_omap.c
@@ -744,12 +744,12 @@ static void omap_8250_shutdown(struct uart_port *port)
 	struct uart_8250_port *up = up_to_u8250p(port);
 	struct omap8250_priv *priv = port->private_data;
 
+	pm_runtime_get_sync(port->dev);
+
 	flush_work(&priv->qos_work);
 	if (up->dma)
 		omap_8250_rx_dma_flush(up);
 
-	pm_runtime_get_sync(port->dev);
-
 	serial_out(up, UART_OMAP_WER, 0);
 	if (priv->habit & UART_HAS_EFR2)
 		serial_out(up, UART_OMAP_EFR2, 0x0);
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index f25dc6931a5b..98ac8f83d86f 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -235,11 +235,20 @@ ieee80211_determine_chantype(struct ieee80211_sub_if_data *sdata,
 	if (sta_ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) {
 		ieee80211_chandef_ht_oper(ht_oper, chandef);
 	} else {
+
 		mlme_dbg(sdata, "40 MHz not supported\n");
-		/* 40 MHz (and 80 MHz) must be supported for VHT */
-		ret = IEEE80211_CONN_DISABLE_VHT;
-		/* also mark 40 MHz disabled */
-		ret |= IEEE80211_CONN_DISABLE_40MHZ;
+
+		/* 40 MHz (and 80 MHz) must be supported for 5GHZ VHT
+			unless peer allows operating mode notification. If so a 20MHz
+			station can ask from peer to lower bandwidth. */
+		if (channel->band != NL80211_BAND_2GHZ){
+				ret = IEEE80211_CONN_DISABLE_40MHZ;
+		}else{
+				ret = IEEE80211_CONN_DISABLE_VHT;
+				/* also mark 40 MHz disabled */
+				ret |= IEEE80211_CONN_DISABLE_40MHZ;
+		}
+
 		goto out;
 	}
 
@@ -972,6 +981,9 @@ static size_t ieee80211_assoc_link_elems(struct ieee80211_sub_if_data *sdata,
 	int present_elems_len = 0;
 	u8 *pos;
 	int i;
+	u8 opmode_notif = 0;
+	u8 rx_nss = 0;
+	u8 rx_nss_type = 0;
 
 #define ADD_PRESENT_ELEM(id) do {					\
 	/* need a last for termination - we use 0 == SSID */		\
@@ -1079,6 +1091,25 @@ static size_t ieee80211_assoc_link_elems(struct ieee80211_sub_if_data *sdata,
 					     &assoc_data->link[link_id].ap_vht_cap,
 					     assoc_data->link[link_id].conn_flags);
 
+		//Add operation mode notification element when operating at 20 MHz bandwidth
+		if(chanctx_conf->def.width == NL80211_CHAN_WIDTH_20)
+		{
+			/*  Operating Mode Notification element */
+			rx_nss = 0;
+			rx_nss_type= 0;
+			opmode_notif |= IEEE80211_OPMODE_NOTIF_CHANWIDTH_20MHZ;
+			rx_nss <<= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;
+			rx_nss_type <<= (IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT + 3);
+			opmode_notif |= rx_nss;
+			opmode_notif |= rx_nss_type;
+
+			pos = skb_put(skb, 2 + sizeof(u8));
+
+			*pos++ = WLAN_EID_OPMODE_NOTIF;
+			*pos++ = sizeof(u8);
+			*pos++ = opmode_notif;
+		}
+
 		if (link)
 			link->conf->mu_mimo_owner = mu_mimo_owner;
 		ADD_PRESENT_ELEM(WLAN_EID_VHT_CAPABILITY);
@@ -1368,6 +1399,7 @@ static int ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)
 		/* HT, VHT, HE, EHT */
 		size += 2 + sizeof(struct ieee80211_ht_cap);
 		size += 2 + sizeof(struct ieee80211_vht_cap);
+		size += 2 + sizeof(u8); /*VHT operating mode Notification elem*/
 		size += 2 + 1 + sizeof(struct ieee80211_he_cap_elem) +
 			sizeof(struct ieee80211_he_mcs_nss_supp) +
 			IEEE80211_HE_PPE_THRES_MAX_LEN;
@@ -4638,6 +4670,7 @@ static int ieee80211_prep_channel(struct ieee80211_sub_if_data *sdata,
 	int ret;
 	u32 i;
 	bool have_80mhz;
+	bool operating_mode_notif_capable = false;
 
 	rcu_read_lock();
 
@@ -4780,8 +4813,14 @@ static int ieee80211_prep_channel(struct ieee80211_sub_if_data *sdata,
 		break;
 	}
 
-	if (!have_80mhz) {
-		sdata_info(sdata, "80 MHz not supported, disabling VHT\n");
+	//get operating mode notification capable element
+	const u8* extended_cap_ie = ieee80211_bss_get_ie(cbss,WLAN_EID_EXT_CAPABILITY);
+	if ( (extended_cap_ie)  && (extended_cap_ie[1] >= 8) &&
+			(extended_cap_ie[9] & WLAN_EXT_CAPA8_OPMODE_NOTIF))
+			operating_mode_notif_capable = true;
+
+	if ((!have_80mhz) && (!operating_mode_notif_capable)) {
+		sdata_info(sdata, "80 MHz not supported nor operating mode notification capable, disabling VHT\n");
 		*conn_flags |= IEEE80211_CONN_DISABLE_VHT;
 	}
 
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index 1088d90e355b..83a8a9c4500b 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -1843,7 +1843,6 @@ static int ieee80211_build_preq_ies_band(struct ieee80211_sub_if_data *sdata,
 	int ext_rates_len;
 	int shift;
 	u32 rate_flags;
-	bool have_80mhz = false;
 
 	*offset = 0;
 
@@ -1967,17 +1966,8 @@ static int ieee80211_build_preq_ies_band(struct ieee80211_sub_if_data *sdata,
 		*offset = noffset;
 	}
 
-	/* Check if any channel in this sband supports at least 80 MHz */
-	for (i = 0; i < sband->n_channels; i++) {
-		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
-						IEEE80211_CHAN_NO_80MHZ))
-			continue;
-
-		have_80mhz = true;
-		break;
-	}
 
-	if (sband->vht_cap.vht_supported && have_80mhz) {
+	if (sband->vht_cap.vht_supported) {
 		if (end - pos < 2 + sizeof(struct ieee80211_vht_cap))
 			goto out_err;
 		pos = ieee80211_ie_build_vht_cap(pos, &sband->vht_cap,
-- 
2.39.2

